{
  "version": 3,
  "sources": ["routes-module:root.tsx?worker", "../../node_modules/@remix-run/router/history.ts", "../../node_modules/@remix-run/router/utils.ts", "../../node_modules/@remix-run/router/router.ts", "routes-module:routes/_index.tsx?worker", "../../node_modules/@remix-run/server-runtime/dist/mode.js", "../../node_modules/@remix-run/server-runtime/dist/errors.js", "../../node_modules/@remix-run/server-runtime/dist/responses.js", "../app/entry.worker.ts", "../../node_modules/cachified/src/common.ts", "../../node_modules/cachified/src/reporter.ts", "../../node_modules/cachified/src/adapters.ts", "../../node_modules/cachified/src/createBatch.ts", "../../node_modules/cachified/src/assertCacheEntry.ts", "../../node_modules/cachified/src/shouldRefresh.ts", "../../node_modules/cachified/src/checkValue.ts", "../../node_modules/cachified/src/getCachedValue.ts", "../../node_modules/cachified/src/getFreshValue.ts", "../../node_modules/cachified/src/cachified.ts", "../../node_modules/cachified/src/softPurge.ts", "../../node_modules/uint8array-extras/index.js", "../../packages/cache/dist/src/utils.js", "../../packages/cache/dist/src/cache.js", "../../packages/cache/dist/src/storage.js", "../../packages/strategy/dist/src/utils.js", "../../packages/strategy/dist/src/cacheFirst.js", "../../packages/strategy/dist/src/cacheOnly.js", "../../packages/strategy/dist/src/networkFirst.js", "../../packages/strategy/dist/src/staleWhileRevalidate.js", "../../packages/sw/dist/src/private/logger.js", "../../packages/sw/dist/src/utils/worker.js", "../../packages/sw/dist/src/message/message.js", "../../packages/sw/dist/src/message/remixNavigationHandler.js", "../../packages/sync/dist/src/request.js", "../../node_modules/idb/build/wrap-idb-value.js", "../../node_modules/idb/build/index.js", "../../packages/sync/dist/src/db.js", "../../packages/sync/dist/src/store.js", "../../packages/sync/dist/src/queue.js", "../../packages/sync/dist/src/export.js", "../../node_modules/dexie/src/globals/global.ts", "../../node_modules/dexie/src/functions/utils.ts", "../../node_modules/dexie/src/helpers/debug.ts", "../../node_modules/dexie/src/errors/errors.js", "../../node_modules/dexie/src/functions/chaining-functions.js", "../../node_modules/dexie/src/helpers/promise.js", "../../node_modules/dexie/src/functions/temp-transaction.ts", "../../node_modules/dexie/src/globals/constants.ts", "../../node_modules/dexie/src/functions/combine.ts", "../../node_modules/dexie/src/dbcore/keyrange.ts", "../../node_modules/dexie/src/functions/workaround-undefined-primkey.ts", "../../node_modules/dexie/src/classes/table/table.ts", "../../node_modules/dexie/src/helpers/Events.js", "../../node_modules/dexie/src/functions/make-class-constructor.ts", "../../node_modules/dexie/src/classes/table/table-constructor.ts", "../../node_modules/dexie/src/classes/collection/collection-helpers.ts", "../../node_modules/dexie/src/functions/cmp.ts", "../../node_modules/dexie/src/classes/collection/collection.ts", "../../node_modules/dexie/src/classes/collection/collection-constructor.ts", "../../node_modules/dexie/src/functions/compare-functions.ts", "../../node_modules/dexie/src/classes/where-clause/where-clause-helpers.ts", "../../node_modules/dexie/src/classes/where-clause/where-clause.ts", "../../node_modules/dexie/src/classes/where-clause/where-clause-constructor.ts", "../../node_modules/dexie/src/functions/event-wrappers.ts", "../../node_modules/dexie/src/globals/global-events.ts", "../../node_modules/dexie/src/classes/transaction/transaction.ts", "../../node_modules/dexie/src/classes/transaction/transaction-constructor.ts", "../../node_modules/dexie/src/helpers/index-spec.ts", "../../node_modules/dexie/src/helpers/table-schema.ts", "../../node_modules/dexie/src/functions/quirks.ts", "../../node_modules/dexie/src/dbcore/get-key-extractor.ts", "../../node_modules/dexie/src/dbcore/dbcore-indexeddb.ts", "../../node_modules/dexie/src/classes/dexie/generate-middleware-stacks.ts", "../../node_modules/dexie/src/classes/version/schema-helpers.ts", "../../node_modules/dexie/src/classes/version/version.ts", "../../node_modules/dexie/src/classes/version/version-constructor.ts", "../../node_modules/dexie/src/helpers/database-enumerator.ts", "../../node_modules/dexie/src/classes/dexie/vip.ts", "../../node_modules/dexie/node_modules/safari-14-idb-fix/dist/index.js", "../../node_modules/dexie/src/classes/dexie/dexie-open.ts", "../../node_modules/dexie/src/helpers/yield-support.ts", "../../node_modules/dexie/src/classes/dexie/transaction-helpers.ts", "../../node_modules/dexie/src/dbcore/virtual-index-middleware.ts", "../../node_modules/dexie/src/functions/get-object-diff.ts", "../../node_modules/dexie/src/dbcore/get-effective-keys.ts", "../../node_modules/dexie/src/hooks/hooks-middleware.ts", "../../node_modules/dexie/src/dbcore/cache-existing-values-middleware.ts", "../../node_modules/dexie/src/helpers/rangeset.ts", "../../node_modules/dexie/src/live-query/observability-middleware.ts", "../../node_modules/dexie/src/classes/dexie/dexie.ts", "../../node_modules/dexie/src/classes/observable/observable.ts", "../../node_modules/dexie/src/live-query/extend-observability-set.ts", "../../node_modules/dexie/src/live-query/live-query.ts", "../../node_modules/dexie/src/classes/dexie/dexie-dom-dependencies.ts", "../../node_modules/dexie/src/classes/dexie/dexie-static-props.ts", "../../node_modules/dexie/src/live-query/propagate-locally.ts", "../../node_modules/dexie/src/live-query/enable-broadcast.ts", "../../node_modules/dexie/src/index.ts", "../app/database.ts", "entry-module:@remix-pwa/build/magic", "routes-module:routes/basic-caching.tsx?worker", "routes-module:routes/basic-action.tsx?worker", "routes-module:routes/basic-loader.tsx?worker", "routes-module:routes/_app.flights.tsx?worker", "routes-module:routes/strategies.tsx?worker", "routes-module:routes/selection.tsx?worker", "routes-module:routes/sync-away.tsx?worker", "routes-module:routes/_app.tsx?worker", "assets-module:@remix-pwa/dev?assets", "../../packages/worker-runtime/dist/src/utils/handle-request.js", "../../packages/worker-runtime/dist/src/utils/request.js", "../../packages/worker-runtime/dist/src/utils/response.js", "../../packages/worker-runtime/dist/src/service-worker.internal.js"],
  "sourcesContent": ["module.exports = {};", "////////////////////////////////////////////////////////////////////////////////\n//#region Types and Constants\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * Actions represent the type of change to a location value.\n */\nexport enum Action {\n  /**\n   * A POP indicates a change to an arbitrary index in the history stack, such\n   * as a back or forward navigation. It does not describe the direction of the\n   * navigation, only that the current index changed.\n   *\n   * Note: This is the default action for newly created history objects.\n   */\n  Pop = \"POP\",\n\n  /**\n   * A PUSH indicates a new entry being added to the history stack, such as when\n   * a link is clicked and a new page loads. When this happens, all subsequent\n   * entries in the stack are lost.\n   */\n  Push = \"PUSH\",\n\n  /**\n   * A REPLACE indicates the entry at the current index in the history stack\n   * being replaced by a new one.\n   */\n  Replace = \"REPLACE\",\n}\n\n/**\n * The pathname, search, and hash values of a URL.\n */\nexport interface Path {\n  /**\n   * A URL pathname, beginning with a /.\n   */\n  pathname: string;\n\n  /**\n   * A URL search string, beginning with a ?.\n   */\n  search: string;\n\n  /**\n   * A URL fragment identifier, beginning with a #.\n   */\n  hash: string;\n}\n\n// TODO: (v7) Change the Location generic default from `any` to `unknown` and\n// remove Remix `useLocation` wrapper.\n\n/**\n * An entry in a history stack. A location contains information about the\n * URL path, as well as possibly some arbitrary state and a key.\n */\nexport interface Location<State = any> extends Path {\n  /**\n   * A value of arbitrary data associated with this location.\n   */\n  state: State;\n\n  /**\n   * A unique string associated with this location. May be used to safely store\n   * and retrieve data in some other storage API, like `localStorage`.\n   *\n   * Note: This value is always \"default\" on the initial location.\n   */\n  key: string;\n}\n\n/**\n * A change to the current location.\n */\nexport interface Update {\n  /**\n   * The action that triggered the change.\n   */\n  action: Action;\n\n  /**\n   * The new location.\n   */\n  location: Location;\n\n  /**\n   * The delta between this location and the former location in the history stack\n   */\n  delta: number | null;\n}\n\n/**\n * A function that receives notifications about location changes.\n */\nexport interface Listener {\n  (update: Update): void;\n}\n\n/**\n * Describes a location that is the destination of some navigation, either via\n * `history.push` or `history.replace`. This may be either a URL or the pieces\n * of a URL path.\n */\nexport type To = string | Partial<Path>;\n\n/**\n * A history is an interface to the navigation stack. The history serves as the\n * source of truth for the current location, as well as provides a set of\n * methods that may be used to change it.\n *\n * It is similar to the DOM's `window.history` object, but with a smaller, more\n * focused API.\n */\nexport interface History {\n  /**\n   * The last action that modified the current location. This will always be\n   * Action.Pop when a history instance is first created. This value is mutable.\n   */\n  readonly action: Action;\n\n  /**\n   * The current location. This value is mutable.\n   */\n  readonly location: Location;\n\n  /**\n   * Returns a valid href for the given `to` value that may be used as\n   * the value of an <a href> attribute.\n   *\n   * @param to - The destination URL\n   */\n  createHref(to: To): string;\n\n  /**\n   * Returns a URL for the given `to` value\n   *\n   * @param to - The destination URL\n   */\n  createURL(to: To): URL;\n\n  /**\n   * Encode a location the same way window.history would do (no-op for memory\n   * history) so we ensure our PUSH/REPLACE navigations for data routers\n   * behave the same as POP\n   *\n   * @param to Unencoded path\n   */\n  encodeLocation(to: To): Path;\n\n  /**\n   * Pushes a new location onto the history stack, increasing its length by one.\n   * If there were any entries in the stack after the current one, they are\n   * lost.\n   *\n   * @param to - The new URL\n   * @param state - Data to associate with the new location\n   */\n  push(to: To, state?: any): void;\n\n  /**\n   * Replaces the current location in the history stack with a new one.  The\n   * location that was replaced will no longer be available.\n   *\n   * @param to - The new URL\n   * @param state - Data to associate with the new location\n   */\n  replace(to: To, state?: any): void;\n\n  /**\n   * Navigates `n` entries backward/forward in the history stack relative to the\n   * current index. For example, a \"back\" navigation would use go(-1).\n   *\n   * @param delta - The delta in the stack index\n   */\n  go(delta: number): void;\n\n  /**\n   * Sets up a listener that will be called whenever the current location\n   * changes.\n   *\n   * @param listener - A function that will be called when the location changes\n   * @returns unlisten - A function that may be used to stop listening\n   */\n  listen(listener: Listener): () => void;\n}\n\ntype HistoryState = {\n  usr: any;\n  key?: string;\n  idx: number;\n};\n\nconst PopStateEventType = \"popstate\";\n//#endregion\n\n////////////////////////////////////////////////////////////////////////////////\n//#region Memory History\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * A user-supplied object that describes a location. Used when providing\n * entries to `createMemoryHistory` via its `initialEntries` option.\n */\nexport type InitialEntry = string | Partial<Location>;\n\nexport type MemoryHistoryOptions = {\n  initialEntries?: InitialEntry[];\n  initialIndex?: number;\n  v5Compat?: boolean;\n};\n\n/**\n * A memory history stores locations in memory. This is useful in stateful\n * environments where there is no web browser, such as node tests or React\n * Native.\n */\nexport interface MemoryHistory extends History {\n  /**\n   * The current index in the history stack.\n   */\n  readonly index: number;\n}\n\n/**\n * Memory history stores the current location in memory. It is designed for use\n * in stateful non-browser environments like tests and React Native.\n */\nexport function createMemoryHistory(\n  options: MemoryHistoryOptions = {}\n): MemoryHistory {\n  let { initialEntries = [\"/\"], initialIndex, v5Compat = false } = options;\n  let entries: Location[]; // Declare so we can access from createMemoryLocation\n  entries = initialEntries.map((entry, index) =>\n    createMemoryLocation(\n      entry,\n      typeof entry === \"string\" ? null : entry.state,\n      index === 0 ? \"default\" : undefined\n    )\n  );\n  let index = clampIndex(\n    initialIndex == null ? entries.length - 1 : initialIndex\n  );\n  let action = Action.Pop;\n  let listener: Listener | null = null;\n\n  function clampIndex(n: number): number {\n    return Math.min(Math.max(n, 0), entries.length - 1);\n  }\n  function getCurrentLocation(): Location {\n    return entries[index];\n  }\n  function createMemoryLocation(\n    to: To,\n    state: any = null,\n    key?: string\n  ): Location {\n    let location = createLocation(\n      entries ? getCurrentLocation().pathname : \"/\",\n      to,\n      state,\n      key\n    );\n    warning(\n      location.pathname.charAt(0) === \"/\",\n      `relative pathnames are not supported in memory history: ${JSON.stringify(\n        to\n      )}`\n    );\n    return location;\n  }\n\n  function createHref(to: To) {\n    return typeof to === \"string\" ? to : createPath(to);\n  }\n\n  let history: MemoryHistory = {\n    get index() {\n      return index;\n    },\n    get action() {\n      return action;\n    },\n    get location() {\n      return getCurrentLocation();\n    },\n    createHref,\n    createURL(to) {\n      return new URL(createHref(to), \"http://localhost\");\n    },\n    encodeLocation(to: To) {\n      let path = typeof to === \"string\" ? parsePath(to) : to;\n      return {\n        pathname: path.pathname || \"\",\n        search: path.search || \"\",\n        hash: path.hash || \"\",\n      };\n    },\n    push(to, state) {\n      action = Action.Push;\n      let nextLocation = createMemoryLocation(to, state);\n      index += 1;\n      entries.splice(index, entries.length, nextLocation);\n      if (v5Compat && listener) {\n        listener({ action, location: nextLocation, delta: 1 });\n      }\n    },\n    replace(to, state) {\n      action = Action.Replace;\n      let nextLocation = createMemoryLocation(to, state);\n      entries[index] = nextLocation;\n      if (v5Compat && listener) {\n        listener({ action, location: nextLocation, delta: 0 });\n      }\n    },\n    go(delta) {\n      action = Action.Pop;\n      let nextIndex = clampIndex(index + delta);\n      let nextLocation = entries[nextIndex];\n      index = nextIndex;\n      if (listener) {\n        listener({ action, location: nextLocation, delta });\n      }\n    },\n    listen(fn: Listener) {\n      listener = fn;\n      return () => {\n        listener = null;\n      };\n    },\n  };\n\n  return history;\n}\n//#endregion\n\n////////////////////////////////////////////////////////////////////////////////\n//#region Browser History\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * A browser history stores the current location in regular URLs in a web\n * browser environment. This is the standard for most web apps and provides the\n * cleanest URLs the browser's address bar.\n *\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#browserhistory\n */\nexport interface BrowserHistory extends UrlHistory {}\n\nexport type BrowserHistoryOptions = UrlHistoryOptions;\n\n/**\n * Browser history stores the location in regular URLs. This is the standard for\n * most web apps, but it requires some configuration on the server to ensure you\n * serve the same app at multiple URLs.\n *\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createbrowserhistory\n */\nexport function createBrowserHistory(\n  options: BrowserHistoryOptions = {}\n): BrowserHistory {\n  function createBrowserLocation(\n    window: Window,\n    globalHistory: Window[\"history\"]\n  ) {\n    let { pathname, search, hash } = window.location;\n    return createLocation(\n      \"\",\n      { pathname, search, hash },\n      // state defaults to `null` because `window.history.state` does\n      (globalHistory.state && globalHistory.state.usr) || null,\n      (globalHistory.state && globalHistory.state.key) || \"default\"\n    );\n  }\n\n  function createBrowserHref(window: Window, to: To) {\n    return typeof to === \"string\" ? to : createPath(to);\n  }\n\n  return getUrlBasedHistory(\n    createBrowserLocation,\n    createBrowserHref,\n    null,\n    options\n  );\n}\n//#endregion\n\n////////////////////////////////////////////////////////////////////////////////\n//#region Hash History\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * A hash history stores the current location in the fragment identifier portion\n * of the URL in a web browser environment.\n *\n * This is ideal for apps that do not control the server for some reason\n * (because the fragment identifier is never sent to the server), including some\n * shared hosting environments that do not provide fine-grained controls over\n * which pages are served at which URLs.\n *\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#hashhistory\n */\nexport interface HashHistory extends UrlHistory {}\n\nexport type HashHistoryOptions = UrlHistoryOptions;\n\n/**\n * Hash history stores the location in window.location.hash. This makes it ideal\n * for situations where you don't want to send the location to the server for\n * some reason, either because you do cannot configure it or the URL space is\n * reserved for something else.\n *\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createhashhistory\n */\nexport function createHashHistory(\n  options: HashHistoryOptions = {}\n): HashHistory {\n  function createHashLocation(\n    window: Window,\n    globalHistory: Window[\"history\"]\n  ) {\n    let {\n      pathname = \"/\",\n      search = \"\",\n      hash = \"\",\n    } = parsePath(window.location.hash.substr(1));\n\n    // Hash URL should always have a leading / just like window.location.pathname\n    // does, so if an app ends up at a route like /#something then we add a\n    // leading slash so all of our path-matching behaves the same as if it would\n    // in a browser router.  This is particularly important when there exists a\n    // root splat route (<Route path=\"*\">) since that matches internally against\n    // \"/*\" and we'd expect /#something to 404 in a hash router app.\n    if (!pathname.startsWith(\"/\") && !pathname.startsWith(\".\")) {\n      pathname = \"/\" + pathname;\n    }\n\n    return createLocation(\n      \"\",\n      { pathname, search, hash },\n      // state defaults to `null` because `window.history.state` does\n      (globalHistory.state && globalHistory.state.usr) || null,\n      (globalHistory.state && globalHistory.state.key) || \"default\"\n    );\n  }\n\n  function createHashHref(window: Window, to: To) {\n    let base = window.document.querySelector(\"base\");\n    let href = \"\";\n\n    if (base && base.getAttribute(\"href\")) {\n      let url = window.location.href;\n      let hashIndex = url.indexOf(\"#\");\n      href = hashIndex === -1 ? url : url.slice(0, hashIndex);\n    }\n\n    return href + \"#\" + (typeof to === \"string\" ? to : createPath(to));\n  }\n\n  function validateHashLocation(location: Location, to: To) {\n    warning(\n      location.pathname.charAt(0) === \"/\",\n      `relative pathnames are not supported in hash history.push(${JSON.stringify(\n        to\n      )})`\n    );\n  }\n\n  return getUrlBasedHistory(\n    createHashLocation,\n    createHashHref,\n    validateHashLocation,\n    options\n  );\n}\n//#endregion\n\n////////////////////////////////////////////////////////////////////////////////\n//#region UTILS\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * @private\n */\nexport function invariant(value: boolean, message?: string): asserts value;\nexport function invariant<T>(\n  value: T | null | undefined,\n  message?: string\n): asserts value is T;\nexport function invariant(value: any, message?: string) {\n  if (value === false || value === null || typeof value === \"undefined\") {\n    throw new Error(message);\n  }\n}\n\nexport function warning(cond: any, message: string) {\n  if (!cond) {\n    // eslint-disable-next-line no-console\n    if (typeof console !== \"undefined\") console.warn(message);\n\n    try {\n      // Welcome to debugging history!\n      //\n      // This error is thrown as a convenience, so you can more easily\n      // find the source for a warning that appears in the console by\n      // enabling \"pause on exceptions\" in your JavaScript debugger.\n      throw new Error(message);\n      // eslint-disable-next-line no-empty\n    } catch (e) {}\n  }\n}\n\nfunction createKey() {\n  return Math.random().toString(36).substr(2, 8);\n}\n\n/**\n * For browser-based histories, we combine the state and key into an object\n */\nfunction getHistoryState(location: Location, index: number): HistoryState {\n  return {\n    usr: location.state,\n    key: location.key,\n    idx: index,\n  };\n}\n\n/**\n * Creates a Location object with a unique key from the given Path\n */\nexport function createLocation(\n  current: string | Location,\n  to: To,\n  state: any = null,\n  key?: string\n): Readonly<Location> {\n  let location: Readonly<Location> = {\n    pathname: typeof current === \"string\" ? current : current.pathname,\n    search: \"\",\n    hash: \"\",\n    ...(typeof to === \"string\" ? parsePath(to) : to),\n    state,\n    // TODO: This could be cleaned up.  push/replace should probably just take\n    // full Locations now and avoid the need to run through this flow at all\n    // But that's a pretty big refactor to the current test suite so going to\n    // keep as is for the time being and just let any incoming keys take precedence\n    key: (to && (to as Location).key) || key || createKey(),\n  };\n  return location;\n}\n\n/**\n * Creates a string URL path from the given pathname, search, and hash components.\n */\nexport function createPath({\n  pathname = \"/\",\n  search = \"\",\n  hash = \"\",\n}: Partial<Path>) {\n  if (search && search !== \"?\")\n    pathname += search.charAt(0) === \"?\" ? search : \"?\" + search;\n  if (hash && hash !== \"#\")\n    pathname += hash.charAt(0) === \"#\" ? hash : \"#\" + hash;\n  return pathname;\n}\n\n/**\n * Parses a string URL path into its separate pathname, search, and hash components.\n */\nexport function parsePath(path: string): Partial<Path> {\n  let parsedPath: Partial<Path> = {};\n\n  if (path) {\n    let hashIndex = path.indexOf(\"#\");\n    if (hashIndex >= 0) {\n      parsedPath.hash = path.substr(hashIndex);\n      path = path.substr(0, hashIndex);\n    }\n\n    let searchIndex = path.indexOf(\"?\");\n    if (searchIndex >= 0) {\n      parsedPath.search = path.substr(searchIndex);\n      path = path.substr(0, searchIndex);\n    }\n\n    if (path) {\n      parsedPath.pathname = path;\n    }\n  }\n\n  return parsedPath;\n}\n\nexport interface UrlHistory extends History {}\n\nexport type UrlHistoryOptions = {\n  window?: Window;\n  v5Compat?: boolean;\n};\n\nfunction getUrlBasedHistory(\n  getLocation: (window: Window, globalHistory: Window[\"history\"]) => Location,\n  createHref: (window: Window, to: To) => string,\n  validateLocation: ((location: Location, to: To) => void) | null,\n  options: UrlHistoryOptions = {}\n): UrlHistory {\n  let { window = document.defaultView!, v5Compat = false } = options;\n  let globalHistory = window.history;\n  let action = Action.Pop;\n  let listener: Listener | null = null;\n\n  let index = getIndex()!;\n  // Index should only be null when we initialize. If not, it's because the\n  // user called history.pushState or history.replaceState directly, in which\n  // case we should log a warning as it will result in bugs.\n  if (index == null) {\n    index = 0;\n    globalHistory.replaceState({ ...globalHistory.state, idx: index }, \"\");\n  }\n\n  function getIndex(): number {\n    let state = globalHistory.state || { idx: null };\n    return state.idx;\n  }\n\n  function handlePop() {\n    action = Action.Pop;\n    let nextIndex = getIndex();\n    let delta = nextIndex == null ? null : nextIndex - index;\n    index = nextIndex;\n    if (listener) {\n      listener({ action, location: history.location, delta });\n    }\n  }\n\n  function push(to: To, state?: any) {\n    action = Action.Push;\n    let location = createLocation(history.location, to, state);\n    if (validateLocation) validateLocation(location, to);\n\n    index = getIndex() + 1;\n    let historyState = getHistoryState(location, index);\n    let url = history.createHref(location);\n\n    // try...catch because iOS limits us to 100 pushState calls :/\n    try {\n      globalHistory.pushState(historyState, \"\", url);\n    } catch (error) {\n      // If the exception is because `state` can't be serialized, let that throw\n      // outwards just like a replace call would so the dev knows the cause\n      // https://html.spec.whatwg.org/multipage/nav-history-apis.html#shared-history-push/replace-state-steps\n      // https://html.spec.whatwg.org/multipage/structured-data.html#structuredserializeinternal\n      if (error instanceof DOMException && error.name === \"DataCloneError\") {\n        throw error;\n      }\n      // They are going to lose state here, but there is no real\n      // way to warn them about it since the page will refresh...\n      window.location.assign(url);\n    }\n\n    if (v5Compat && listener) {\n      listener({ action, location: history.location, delta: 1 });\n    }\n  }\n\n  function replace(to: To, state?: any) {\n    action = Action.Replace;\n    let location = createLocation(history.location, to, state);\n    if (validateLocation) validateLocation(location, to);\n\n    index = getIndex();\n    let historyState = getHistoryState(location, index);\n    let url = history.createHref(location);\n    globalHistory.replaceState(historyState, \"\", url);\n\n    if (v5Compat && listener) {\n      listener({ action, location: history.location, delta: 0 });\n    }\n  }\n\n  function createURL(to: To): URL {\n    // window.location.origin is \"null\" (the literal string value) in Firefox\n    // under certain conditions, notably when serving from a local HTML file\n    // See https://bugzilla.mozilla.org/show_bug.cgi?id=878297\n    let base =\n      window.location.origin !== \"null\"\n        ? window.location.origin\n        : window.location.href;\n\n    let href = typeof to === \"string\" ? to : createPath(to);\n    invariant(\n      base,\n      `No window.location.(origin|href) available to create URL for href: ${href}`\n    );\n    return new URL(href, base);\n  }\n\n  let history: History = {\n    get action() {\n      return action;\n    },\n    get location() {\n      return getLocation(window, globalHistory);\n    },\n    listen(fn: Listener) {\n      if (listener) {\n        throw new Error(\"A history only accepts one active listener\");\n      }\n      window.addEventListener(PopStateEventType, handlePop);\n      listener = fn;\n\n      return () => {\n        window.removeEventListener(PopStateEventType, handlePop);\n        listener = null;\n      };\n    },\n    createHref(to) {\n      return createHref(window, to);\n    },\n    createURL,\n    encodeLocation(to) {\n      // Encode a Location the same way window.location would\n      let url = createURL(to);\n      return {\n        pathname: url.pathname,\n        search: url.search,\n        hash: url.hash,\n      };\n    },\n    push,\n    replace,\n    go(n) {\n      return globalHistory.go(n);\n    },\n  };\n\n  return history;\n}\n\n//#endregion\n", "import type { Location, Path, To } from \"./history\";\nimport { invariant, parsePath, warning } from \"./history\";\n\n/**\n * Map of routeId -> data returned from a loader/action/error\n */\nexport interface RouteData {\n  [routeId: string]: any;\n}\n\nexport enum ResultType {\n  data = \"data\",\n  deferred = \"deferred\",\n  redirect = \"redirect\",\n  error = \"error\",\n}\n\n/**\n * Successful result from a loader or action\n */\nexport interface SuccessResult {\n  type: ResultType.data;\n  data: any;\n  statusCode?: number;\n  headers?: Headers;\n}\n\n/**\n * Successful defer() result from a loader or action\n */\nexport interface DeferredResult {\n  type: ResultType.deferred;\n  deferredData: DeferredData;\n  statusCode?: number;\n  headers?: Headers;\n}\n\n/**\n * Redirect result from a loader or action\n */\nexport interface RedirectResult {\n  type: ResultType.redirect;\n  status: number;\n  location: string;\n  revalidate: boolean;\n  reloadDocument?: boolean;\n}\n\n/**\n * Unsuccessful result from a loader or action\n */\nexport interface ErrorResult {\n  type: ResultType.error;\n  error: any;\n  headers?: Headers;\n}\n\n/**\n * Result from a loader or action - potentially successful or unsuccessful\n */\nexport type DataResult =\n  | SuccessResult\n  | DeferredResult\n  | RedirectResult\n  | ErrorResult;\n\ntype LowerCaseFormMethod = \"get\" | \"post\" | \"put\" | \"patch\" | \"delete\";\ntype UpperCaseFormMethod = Uppercase<LowerCaseFormMethod>;\n\n/**\n * Users can specify either lowercase or uppercase form methods on <Form>,\n * useSubmit(), <fetcher.Form>, etc.\n */\nexport type HTMLFormMethod = LowerCaseFormMethod | UpperCaseFormMethod;\n\n/**\n * Active navigation/fetcher form methods are exposed in lowercase on the\n * RouterState\n */\nexport type FormMethod = LowerCaseFormMethod;\nexport type MutationFormMethod = Exclude<FormMethod, \"get\">;\n\n/**\n * In v7, active navigation/fetcher form methods are exposed in uppercase on the\n * RouterState.  This is to align with the normalization done via fetch().\n */\nexport type V7_FormMethod = UpperCaseFormMethod;\nexport type V7_MutationFormMethod = Exclude<V7_FormMethod, \"GET\">;\n\nexport type FormEncType =\n  | \"application/x-www-form-urlencoded\"\n  | \"multipart/form-data\"\n  | \"application/json\"\n  | \"text/plain\";\n\n// Thanks https://github.com/sindresorhus/type-fest!\ntype JsonObject = { [Key in string]: JsonValue } & {\n  [Key in string]?: JsonValue | undefined;\n};\ntype JsonArray = JsonValue[] | readonly JsonValue[];\ntype JsonPrimitive = string | number | boolean | null;\ntype JsonValue = JsonPrimitive | JsonObject | JsonArray;\n\n/**\n * @private\n * Internal interface to pass around for action submissions, not intended for\n * external consumption\n */\nexport type Submission =\n  | {\n      formMethod: FormMethod | V7_FormMethod;\n      formAction: string;\n      formEncType: FormEncType;\n      formData: FormData;\n      json: undefined;\n      text: undefined;\n    }\n  | {\n      formMethod: FormMethod | V7_FormMethod;\n      formAction: string;\n      formEncType: FormEncType;\n      formData: undefined;\n      json: JsonValue;\n      text: undefined;\n    }\n  | {\n      formMethod: FormMethod | V7_FormMethod;\n      formAction: string;\n      formEncType: FormEncType;\n      formData: undefined;\n      json: undefined;\n      text: string;\n    };\n\n/**\n * @private\n * Arguments passed to route loader/action functions.  Same for now but we keep\n * this as a private implementation detail in case they diverge in the future.\n */\ninterface DataFunctionArgs<Context> {\n  request: Request;\n  params: Params;\n  context?: Context;\n}\n\n// TODO: (v7) Change the defaults from any to unknown in and remove Remix wrappers:\n//   ActionFunction, ActionFunctionArgs, LoaderFunction, LoaderFunctionArgs\n//   Also, make them a type alias instead of an interface\n\n/**\n * Arguments passed to loader functions\n */\nexport interface LoaderFunctionArgs<Context = any>\n  extends DataFunctionArgs<Context> {}\n\n/**\n * Arguments passed to action functions\n */\nexport interface ActionFunctionArgs<Context = any>\n  extends DataFunctionArgs<Context> {}\n\n/**\n * Loaders and actions can return anything except `undefined` (`null` is a\n * valid return value if there is no data to return).  Responses are preferred\n * and will ease any future migration to Remix\n */\ntype DataFunctionValue = Response | NonNullable<unknown> | null;\n\n/**\n * Route loader function signature\n */\nexport interface LoaderFunction<Context = any> {\n  (args: LoaderFunctionArgs<Context>):\n    | Promise<DataFunctionValue>\n    | DataFunctionValue;\n}\n\n/**\n * Route action function signature\n */\nexport interface ActionFunction<Context = any> {\n  (args: ActionFunctionArgs<Context>):\n    | Promise<DataFunctionValue>\n    | DataFunctionValue;\n}\n\n/**\n * Arguments passed to shouldRevalidate function\n */\nexport interface ShouldRevalidateFunctionArgs {\n  currentUrl: URL;\n  currentParams: AgnosticDataRouteMatch[\"params\"];\n  nextUrl: URL;\n  nextParams: AgnosticDataRouteMatch[\"params\"];\n  formMethod?: Submission[\"formMethod\"];\n  formAction?: Submission[\"formAction\"];\n  formEncType?: Submission[\"formEncType\"];\n  text?: Submission[\"text\"];\n  formData?: Submission[\"formData\"];\n  json?: Submission[\"json\"];\n  actionResult?: any;\n  defaultShouldRevalidate: boolean;\n}\n\n/**\n * Route shouldRevalidate function signature.  This runs after any submission\n * (navigation or fetcher), so we flatten the navigation/fetcher submission\n * onto the arguments.  It shouldn't matter whether it came from a navigation\n * or a fetcher, what really matters is the URLs and the formData since loaders\n * have to re-run based on the data models that were potentially mutated.\n */\nexport interface ShouldRevalidateFunction {\n  (args: ShouldRevalidateFunctionArgs): boolean;\n}\n\n/**\n * Function provided by the framework-aware layers to set `hasErrorBoundary`\n * from the framework-aware `errorElement` prop\n *\n * @deprecated Use `mapRouteProperties` instead\n */\nexport interface DetectErrorBoundaryFunction {\n  (route: AgnosticRouteObject): boolean;\n}\n\n/**\n * Function provided by the framework-aware layers to set any framework-specific\n * properties from framework-agnostic properties\n */\nexport interface MapRoutePropertiesFunction {\n  (route: AgnosticRouteObject): {\n    hasErrorBoundary: boolean;\n  } & Record<string, any>;\n}\n\n/**\n * Keys we cannot change from within a lazy() function. We spread all other keys\n * onto the route. Either they're meaningful to the router, or they'll get\n * ignored.\n */\nexport type ImmutableRouteKey =\n  | \"lazy\"\n  | \"caseSensitive\"\n  | \"path\"\n  | \"id\"\n  | \"index\"\n  | \"children\";\n\nexport const immutableRouteKeys = new Set<ImmutableRouteKey>([\n  \"lazy\",\n  \"caseSensitive\",\n  \"path\",\n  \"id\",\n  \"index\",\n  \"children\",\n]);\n\ntype RequireOne<T, Key = keyof T> = Exclude<\n  {\n    [K in keyof T]: K extends Key ? Omit<T, K> & Required<Pick<T, K>> : never;\n  }[keyof T],\n  undefined\n>;\n\n/**\n * lazy() function to load a route definition, which can add non-matching\n * related properties to a route\n */\nexport interface LazyRouteFunction<R extends AgnosticRouteObject> {\n  (): Promise<RequireOne<Omit<R, ImmutableRouteKey>>>;\n}\n\n/**\n * Base RouteObject with common props shared by all types of routes\n */\ntype AgnosticBaseRouteObject = {\n  caseSensitive?: boolean;\n  path?: string;\n  id?: string;\n  loader?: LoaderFunction;\n  action?: ActionFunction;\n  hasErrorBoundary?: boolean;\n  shouldRevalidate?: ShouldRevalidateFunction;\n  handle?: any;\n  lazy?: LazyRouteFunction<AgnosticBaseRouteObject>;\n};\n\n/**\n * Index routes must not have children\n */\nexport type AgnosticIndexRouteObject = AgnosticBaseRouteObject & {\n  children?: undefined;\n  index: true;\n};\n\n/**\n * Non-index routes may have children, but cannot have index\n */\nexport type AgnosticNonIndexRouteObject = AgnosticBaseRouteObject & {\n  children?: AgnosticRouteObject[];\n  index?: false;\n};\n\n/**\n * A route object represents a logical route, with (optionally) its child\n * routes organized in a tree-like structure.\n */\nexport type AgnosticRouteObject =\n  | AgnosticIndexRouteObject\n  | AgnosticNonIndexRouteObject;\n\nexport type AgnosticDataIndexRouteObject = AgnosticIndexRouteObject & {\n  id: string;\n};\n\nexport type AgnosticDataNonIndexRouteObject = AgnosticNonIndexRouteObject & {\n  children?: AgnosticDataRouteObject[];\n  id: string;\n};\n\n/**\n * A data route object, which is just a RouteObject with a required unique ID\n */\nexport type AgnosticDataRouteObject =\n  | AgnosticDataIndexRouteObject\n  | AgnosticDataNonIndexRouteObject;\n\nexport type RouteManifest = Record<string, AgnosticDataRouteObject | undefined>;\n\n// Recursive helper for finding path parameters in the absence of wildcards\ntype _PathParam<Path extends string> =\n  // split path into individual path segments\n  Path extends `${infer L}/${infer R}`\n    ? _PathParam<L> | _PathParam<R>\n    : // find params after `:`\n    Path extends `:${infer Param}`\n    ? Param extends `${infer Optional}?`\n      ? Optional\n      : Param\n    : // otherwise, there aren't any params present\n      never;\n\n/**\n * Examples:\n * \"/a/b/*\" -> \"*\"\n * \":a\" -> \"a\"\n * \"/a/:b\" -> \"b\"\n * \"/a/blahblahblah:b\" -> \"b\"\n * \"/:a/:b\" -> \"a\" | \"b\"\n * \"/:a/b/:c/*\" -> \"a\" | \"c\" | \"*\"\n */\ntype PathParam<Path extends string> =\n  // check if path is just a wildcard\n  Path extends \"*\" | \"/*\"\n    ? \"*\"\n    : // look for wildcard at the end of the path\n    Path extends `${infer Rest}/*`\n    ? \"*\" | _PathParam<Rest>\n    : // look for params in the absence of wildcards\n      _PathParam<Path>;\n\n// Attempt to parse the given string segment. If it fails, then just return the\n// plain string type as a default fallback. Otherwise, return the union of the\n// parsed string literals that were referenced as dynamic segments in the route.\nexport type ParamParseKey<Segment extends string> =\n  // if you could not find path params, fallback to `string`\n  [PathParam<Segment>] extends [never] ? string : PathParam<Segment>;\n\n/**\n * The parameters that were parsed from the URL path.\n */\nexport type Params<Key extends string = string> = {\n  readonly [key in Key]: string | undefined;\n};\n\n/**\n * A RouteMatch contains info about how a route matched a URL.\n */\nexport interface AgnosticRouteMatch<\n  ParamKey extends string = string,\n  RouteObjectType extends AgnosticRouteObject = AgnosticRouteObject\n> {\n  /**\n   * The names and values of dynamic parameters in the URL.\n   */\n  params: Params<ParamKey>;\n  /**\n   * The portion of the URL pathname that was matched.\n   */\n  pathname: string;\n  /**\n   * The portion of the URL pathname that was matched before child routes.\n   */\n  pathnameBase: string;\n  /**\n   * The route object that was used to match.\n   */\n  route: RouteObjectType;\n}\n\nexport interface AgnosticDataRouteMatch\n  extends AgnosticRouteMatch<string, AgnosticDataRouteObject> {}\n\nfunction isIndexRoute(\n  route: AgnosticRouteObject\n): route is AgnosticIndexRouteObject {\n  return route.index === true;\n}\n\n// Walk the route tree generating unique IDs where necessary, so we are working\n// solely with AgnosticDataRouteObject's within the Router\nexport function convertRoutesToDataRoutes(\n  routes: AgnosticRouteObject[],\n  mapRouteProperties: MapRoutePropertiesFunction,\n  parentPath: number[] = [],\n  manifest: RouteManifest = {}\n): AgnosticDataRouteObject[] {\n  return routes.map((route, index) => {\n    let treePath = [...parentPath, index];\n    let id = typeof route.id === \"string\" ? route.id : treePath.join(\"-\");\n    invariant(\n      route.index !== true || !route.children,\n      `Cannot specify children on an index route`\n    );\n    invariant(\n      !manifest[id],\n      `Found a route id collision on id \"${id}\".  Route ` +\n        \"id's must be globally unique within Data Router usages\"\n    );\n\n    if (isIndexRoute(route)) {\n      let indexRoute: AgnosticDataIndexRouteObject = {\n        ...route,\n        ...mapRouteProperties(route),\n        id,\n      };\n      manifest[id] = indexRoute;\n      return indexRoute;\n    } else {\n      let pathOrLayoutRoute: AgnosticDataNonIndexRouteObject = {\n        ...route,\n        ...mapRouteProperties(route),\n        id,\n        children: undefined,\n      };\n      manifest[id] = pathOrLayoutRoute;\n\n      if (route.children) {\n        pathOrLayoutRoute.children = convertRoutesToDataRoutes(\n          route.children,\n          mapRouteProperties,\n          treePath,\n          manifest\n        );\n      }\n\n      return pathOrLayoutRoute;\n    }\n  });\n}\n\n/**\n * Matches the given routes to a location and returns the match data.\n *\n * @see https://reactrouter.com/utils/match-routes\n */\nexport function matchRoutes<\n  RouteObjectType extends AgnosticRouteObject = AgnosticRouteObject\n>(\n  routes: RouteObjectType[],\n  locationArg: Partial<Location> | string,\n  basename = \"/\"\n): AgnosticRouteMatch<string, RouteObjectType>[] | null {\n  let location =\n    typeof locationArg === \"string\" ? parsePath(locationArg) : locationArg;\n\n  let pathname = stripBasename(location.pathname || \"/\", basename);\n\n  if (pathname == null) {\n    return null;\n  }\n\n  let branches = flattenRoutes(routes);\n  rankRouteBranches(branches);\n\n  let matches = null;\n  for (let i = 0; matches == null && i < branches.length; ++i) {\n    matches = matchRouteBranch<string, RouteObjectType>(\n      branches[i],\n      // Incoming pathnames are generally encoded from either window.location\n      // or from router.navigate, but we want to match against the unencoded\n      // paths in the route definitions.  Memory router locations won't be\n      // encoded here but there also shouldn't be anything to decode so this\n      // should be a safe operation.  This avoids needing matchRoutes to be\n      // history-aware.\n      safelyDecodeURI(pathname)\n    );\n  }\n\n  return matches;\n}\n\nexport interface UIMatch<Data = unknown, Handle = unknown> {\n  id: string;\n  pathname: string;\n  params: AgnosticRouteMatch[\"params\"];\n  data: Data;\n  handle: Handle;\n}\n\nexport function convertRouteMatchToUiMatch(\n  match: AgnosticDataRouteMatch,\n  loaderData: RouteData\n): UIMatch {\n  let { route, pathname, params } = match;\n  return {\n    id: route.id,\n    pathname,\n    params,\n    data: loaderData[route.id],\n    handle: route.handle,\n  };\n}\n\ninterface RouteMeta<\n  RouteObjectType extends AgnosticRouteObject = AgnosticRouteObject\n> {\n  relativePath: string;\n  caseSensitive: boolean;\n  childrenIndex: number;\n  route: RouteObjectType;\n}\n\ninterface RouteBranch<\n  RouteObjectType extends AgnosticRouteObject = AgnosticRouteObject\n> {\n  path: string;\n  score: number;\n  routesMeta: RouteMeta<RouteObjectType>[];\n}\n\nfunction flattenRoutes<\n  RouteObjectType extends AgnosticRouteObject = AgnosticRouteObject\n>(\n  routes: RouteObjectType[],\n  branches: RouteBranch<RouteObjectType>[] = [],\n  parentsMeta: RouteMeta<RouteObjectType>[] = [],\n  parentPath = \"\"\n): RouteBranch<RouteObjectType>[] {\n  let flattenRoute = (\n    route: RouteObjectType,\n    index: number,\n    relativePath?: string\n  ) => {\n    let meta: RouteMeta<RouteObjectType> = {\n      relativePath:\n        relativePath === undefined ? route.path || \"\" : relativePath,\n      caseSensitive: route.caseSensitive === true,\n      childrenIndex: index,\n      route,\n    };\n\n    if (meta.relativePath.startsWith(\"/\")) {\n      invariant(\n        meta.relativePath.startsWith(parentPath),\n        `Absolute route path \"${meta.relativePath}\" nested under path ` +\n          `\"${parentPath}\" is not valid. An absolute child route path ` +\n          `must start with the combined path of all its parent routes.`\n      );\n\n      meta.relativePath = meta.relativePath.slice(parentPath.length);\n    }\n\n    let path = joinPaths([parentPath, meta.relativePath]);\n    let routesMeta = parentsMeta.concat(meta);\n\n    // Add the children before adding this route to the array, so we traverse the\n    // route tree depth-first and child routes appear before their parents in\n    // the \"flattened\" version.\n    if (route.children && route.children.length > 0) {\n      invariant(\n        // Our types know better, but runtime JS may not!\n        // @ts-expect-error\n        route.index !== true,\n        `Index routes must not have child routes. Please remove ` +\n          `all child routes from route path \"${path}\".`\n      );\n\n      flattenRoutes(route.children, branches, routesMeta, path);\n    }\n\n    // Routes without a path shouldn't ever match by themselves unless they are\n    // index routes, so don't add them to the list of possible branches.\n    if (route.path == null && !route.index) {\n      return;\n    }\n\n    branches.push({\n      path,\n      score: computeScore(path, route.index),\n      routesMeta,\n    });\n  };\n  routes.forEach((route, index) => {\n    // coarse-grain check for optional params\n    if (route.path === \"\" || !route.path?.includes(\"?\")) {\n      flattenRoute(route, index);\n    } else {\n      for (let exploded of explodeOptionalSegments(route.path)) {\n        flattenRoute(route, index, exploded);\n      }\n    }\n  });\n\n  return branches;\n}\n\n/**\n * Computes all combinations of optional path segments for a given path,\n * excluding combinations that are ambiguous and of lower priority.\n *\n * For example, `/one/:two?/three/:four?/:five?` explodes to:\n * - `/one/three`\n * - `/one/:two/three`\n * - `/one/three/:four`\n * - `/one/three/:five`\n * - `/one/:two/three/:four`\n * - `/one/:two/three/:five`\n * - `/one/three/:four/:five`\n * - `/one/:two/three/:four/:five`\n */\nfunction explodeOptionalSegments(path: string): string[] {\n  let segments = path.split(\"/\");\n  if (segments.length === 0) return [];\n\n  let [first, ...rest] = segments;\n\n  // Optional path segments are denoted by a trailing `?`\n  let isOptional = first.endsWith(\"?\");\n  // Compute the corresponding required segment: `foo?` -> `foo`\n  let required = first.replace(/\\?$/, \"\");\n\n  if (rest.length === 0) {\n    // Intepret empty string as omitting an optional segment\n    // `[\"one\", \"\", \"three\"]` corresponds to omitting `:two` from `/one/:two?/three` -> `/one/three`\n    return isOptional ? [required, \"\"] : [required];\n  }\n\n  let restExploded = explodeOptionalSegments(rest.join(\"/\"));\n\n  let result: string[] = [];\n\n  // All child paths with the prefix.  Do this for all children before the\n  // optional version for all children, so we get consistent ordering where the\n  // parent optional aspect is preferred as required.  Otherwise, we can get\n  // child sections interspersed where deeper optional segments are higher than\n  // parent optional segments, where for example, /:two would explode _earlier_\n  // then /:one.  By always including the parent as required _for all children_\n  // first, we avoid this issue\n  result.push(\n    ...restExploded.map((subpath) =>\n      subpath === \"\" ? required : [required, subpath].join(\"/\")\n    )\n  );\n\n  // Then, if this is an optional value, add all child versions without\n  if (isOptional) {\n    result.push(...restExploded);\n  }\n\n  // for absolute paths, ensure `/` instead of empty segment\n  return result.map((exploded) =>\n    path.startsWith(\"/\") && exploded === \"\" ? \"/\" : exploded\n  );\n}\n\nfunction rankRouteBranches(branches: RouteBranch[]): void {\n  branches.sort((a, b) =>\n    a.score !== b.score\n      ? b.score - a.score // Higher score first\n      : compareIndexes(\n          a.routesMeta.map((meta) => meta.childrenIndex),\n          b.routesMeta.map((meta) => meta.childrenIndex)\n        )\n  );\n}\n\nconst paramRe = /^:\\w+$/;\nconst dynamicSegmentValue = 3;\nconst indexRouteValue = 2;\nconst emptySegmentValue = 1;\nconst staticSegmentValue = 10;\nconst splatPenalty = -2;\nconst isSplat = (s: string) => s === \"*\";\n\nfunction computeScore(path: string, index: boolean | undefined): number {\n  let segments = path.split(\"/\");\n  let initialScore = segments.length;\n  if (segments.some(isSplat)) {\n    initialScore += splatPenalty;\n  }\n\n  if (index) {\n    initialScore += indexRouteValue;\n  }\n\n  return segments\n    .filter((s) => !isSplat(s))\n    .reduce(\n      (score, segment) =>\n        score +\n        (paramRe.test(segment)\n          ? dynamicSegmentValue\n          : segment === \"\"\n          ? emptySegmentValue\n          : staticSegmentValue),\n      initialScore\n    );\n}\n\nfunction compareIndexes(a: number[], b: number[]): number {\n  let siblings =\n    a.length === b.length && a.slice(0, -1).every((n, i) => n === b[i]);\n\n  return siblings\n    ? // If two routes are siblings, we should try to match the earlier sibling\n      // first. This allows people to have fine-grained control over the matching\n      // behavior by simply putting routes with identical paths in the order they\n      // want them tried.\n      a[a.length - 1] - b[b.length - 1]\n    : // Otherwise, it doesn't really make sense to rank non-siblings by index,\n      // so they sort equally.\n      0;\n}\n\nfunction matchRouteBranch<\n  ParamKey extends string = string,\n  RouteObjectType extends AgnosticRouteObject = AgnosticRouteObject\n>(\n  branch: RouteBranch<RouteObjectType>,\n  pathname: string\n): AgnosticRouteMatch<ParamKey, RouteObjectType>[] | null {\n  let { routesMeta } = branch;\n\n  let matchedParams = {};\n  let matchedPathname = \"/\";\n  let matches: AgnosticRouteMatch<ParamKey, RouteObjectType>[] = [];\n  for (let i = 0; i < routesMeta.length; ++i) {\n    let meta = routesMeta[i];\n    let end = i === routesMeta.length - 1;\n    let remainingPathname =\n      matchedPathname === \"/\"\n        ? pathname\n        : pathname.slice(matchedPathname.length) || \"/\";\n    let match = matchPath(\n      { path: meta.relativePath, caseSensitive: meta.caseSensitive, end },\n      remainingPathname\n    );\n\n    if (!match) return null;\n\n    Object.assign(matchedParams, match.params);\n\n    let route = meta.route;\n\n    matches.push({\n      // TODO: Can this as be avoided?\n      params: matchedParams as Params<ParamKey>,\n      pathname: joinPaths([matchedPathname, match.pathname]),\n      pathnameBase: normalizePathname(\n        joinPaths([matchedPathname, match.pathnameBase])\n      ),\n      route,\n    });\n\n    if (match.pathnameBase !== \"/\") {\n      matchedPathname = joinPaths([matchedPathname, match.pathnameBase]);\n    }\n  }\n\n  return matches;\n}\n\n/**\n * Returns a path with params interpolated.\n *\n * @see https://reactrouter.com/utils/generate-path\n */\nexport function generatePath<Path extends string>(\n  originalPath: Path,\n  params: {\n    [key in PathParam<Path>]: string | null;\n  } = {} as any\n): string {\n  let path: string = originalPath;\n  if (path.endsWith(\"*\") && path !== \"*\" && !path.endsWith(\"/*\")) {\n    warning(\n      false,\n      `Route path \"${path}\" will be treated as if it were ` +\n        `\"${path.replace(/\\*$/, \"/*\")}\" because the \\`*\\` character must ` +\n        `always follow a \\`/\\` in the pattern. To get rid of this warning, ` +\n        `please change the route path to \"${path.replace(/\\*$/, \"/*\")}\".`\n    );\n    path = path.replace(/\\*$/, \"/*\") as Path;\n  }\n\n  // ensure `/` is added at the beginning if the path is absolute\n  const prefix = path.startsWith(\"/\") ? \"/\" : \"\";\n\n  const stringify = (p: any) =>\n    p == null ? \"\" : typeof p === \"string\" ? p : String(p);\n\n  const segments = path\n    .split(/\\/+/)\n    .map((segment, index, array) => {\n      const isLastSegment = index === array.length - 1;\n\n      // only apply the splat if it's the last segment\n      if (isLastSegment && segment === \"*\") {\n        const star = \"*\" as PathParam<Path>;\n        // Apply the splat\n        return stringify(params[star]);\n      }\n\n      const keyMatch = segment.match(/^:(\\w+)(\\??)$/);\n      if (keyMatch) {\n        const [, key, optional] = keyMatch;\n        let param = params[key as PathParam<Path>];\n        invariant(optional === \"?\" || param != null, `Missing \":${key}\" param`);\n        return stringify(param);\n      }\n\n      // Remove any optional markers from optional static segments\n      return segment.replace(/\\?$/g, \"\");\n    })\n    // Remove empty segments\n    .filter((segment) => !!segment);\n\n  return prefix + segments.join(\"/\");\n}\n\n/**\n * A PathPattern is used to match on some portion of a URL pathname.\n */\nexport interface PathPattern<Path extends string = string> {\n  /**\n   * A string to match against a URL pathname. May contain `:id`-style segments\n   * to indicate placeholders for dynamic parameters. May also end with `/*` to\n   * indicate matching the rest of the URL pathname.\n   */\n  path: Path;\n  /**\n   * Should be `true` if the static portions of the `path` should be matched in\n   * the same case.\n   */\n  caseSensitive?: boolean;\n  /**\n   * Should be `true` if this pattern should match the entire URL pathname.\n   */\n  end?: boolean;\n}\n\n/**\n * A PathMatch contains info about how a PathPattern matched on a URL pathname.\n */\nexport interface PathMatch<ParamKey extends string = string> {\n  /**\n   * The names and values of dynamic parameters in the URL.\n   */\n  params: Params<ParamKey>;\n  /**\n   * The portion of the URL pathname that was matched.\n   */\n  pathname: string;\n  /**\n   * The portion of the URL pathname that was matched before child routes.\n   */\n  pathnameBase: string;\n  /**\n   * The pattern that was used to match.\n   */\n  pattern: PathPattern;\n}\n\ntype Mutable<T> = {\n  -readonly [P in keyof T]: T[P];\n};\n\n/**\n * Performs pattern matching on a URL pathname and returns information about\n * the match.\n *\n * @see https://reactrouter.com/utils/match-path\n */\nexport function matchPath<\n  ParamKey extends ParamParseKey<Path>,\n  Path extends string\n>(\n  pattern: PathPattern<Path> | Path,\n  pathname: string\n): PathMatch<ParamKey> | null {\n  if (typeof pattern === \"string\") {\n    pattern = { path: pattern, caseSensitive: false, end: true };\n  }\n\n  let [matcher, paramNames] = compilePath(\n    pattern.path,\n    pattern.caseSensitive,\n    pattern.end\n  );\n\n  let match = pathname.match(matcher);\n  if (!match) return null;\n\n  let matchedPathname = match[0];\n  let pathnameBase = matchedPathname.replace(/(.)\\/+$/, \"$1\");\n  let captureGroups = match.slice(1);\n  let params: Params = paramNames.reduce<Mutable<Params>>(\n    (memo, paramName, index) => {\n      // We need to compute the pathnameBase here using the raw splat value\n      // instead of using params[\"*\"] later because it will be decoded then\n      if (paramName === \"*\") {\n        let splatValue = captureGroups[index] || \"\";\n        pathnameBase = matchedPathname\n          .slice(0, matchedPathname.length - splatValue.length)\n          .replace(/(.)\\/+$/, \"$1\");\n      }\n\n      memo[paramName] = safelyDecodeURIComponent(\n        captureGroups[index] || \"\",\n        paramName\n      );\n      return memo;\n    },\n    {}\n  );\n\n  return {\n    params,\n    pathname: matchedPathname,\n    pathnameBase,\n    pattern,\n  };\n}\n\nfunction compilePath(\n  path: string,\n  caseSensitive = false,\n  end = true\n): [RegExp, string[]] {\n  warning(\n    path === \"*\" || !path.endsWith(\"*\") || path.endsWith(\"/*\"),\n    `Route path \"${path}\" will be treated as if it were ` +\n      `\"${path.replace(/\\*$/, \"/*\")}\" because the \\`*\\` character must ` +\n      `always follow a \\`/\\` in the pattern. To get rid of this warning, ` +\n      `please change the route path to \"${path.replace(/\\*$/, \"/*\")}\".`\n  );\n\n  let paramNames: string[] = [];\n  let regexpSource =\n    \"^\" +\n    path\n      .replace(/\\/*\\*?$/, \"\") // Ignore trailing / and /*, we'll handle it below\n      .replace(/^\\/*/, \"/\") // Make sure it has a leading /\n      .replace(/[\\\\.*+^$?{}|()[\\]]/g, \"\\\\$&\") // Escape special regex chars\n      .replace(/\\/:(\\w+)/g, (_: string, paramName: string) => {\n        paramNames.push(paramName);\n        return \"/([^\\\\/]+)\";\n      });\n\n  if (path.endsWith(\"*\")) {\n    paramNames.push(\"*\");\n    regexpSource +=\n      path === \"*\" || path === \"/*\"\n        ? \"(.*)$\" // Already matched the initial /, just match the rest\n        : \"(?:\\\\/(.+)|\\\\/*)$\"; // Don't include the / in params[\"*\"]\n  } else if (end) {\n    // When matching to the end, ignore trailing slashes\n    regexpSource += \"\\\\/*$\";\n  } else if (path !== \"\" && path !== \"/\") {\n    // If our path is non-empty and contains anything beyond an initial slash,\n    // then we have _some_ form of path in our regex, so we should expect to\n    // match only if we find the end of this path segment.  Look for an optional\n    // non-captured trailing slash (to match a portion of the URL) or the end\n    // of the path (if we've matched to the end).  We used to do this with a\n    // word boundary but that gives false positives on routes like\n    // /user-preferences since `-` counts as a word boundary.\n    regexpSource += \"(?:(?=\\\\/|$))\";\n  } else {\n    // Nothing to match for \"\" or \"/\"\n  }\n\n  let matcher = new RegExp(regexpSource, caseSensitive ? undefined : \"i\");\n\n  return [matcher, paramNames];\n}\n\nfunction safelyDecodeURI(value: string) {\n  try {\n    return decodeURI(value);\n  } catch (error) {\n    warning(\n      false,\n      `The URL path \"${value}\" could not be decoded because it is is a ` +\n        `malformed URL segment. This is probably due to a bad percent ` +\n        `encoding (${error}).`\n    );\n\n    return value;\n  }\n}\n\nfunction safelyDecodeURIComponent(value: string, paramName: string) {\n  try {\n    return decodeURIComponent(value);\n  } catch (error) {\n    warning(\n      false,\n      `The value for the URL param \"${paramName}\" will not be decoded because` +\n        ` the string \"${value}\" is a malformed URL segment. This is probably` +\n        ` due to a bad percent encoding (${error}).`\n    );\n\n    return value;\n  }\n}\n\n/**\n * @private\n */\nexport function stripBasename(\n  pathname: string,\n  basename: string\n): string | null {\n  if (basename === \"/\") return pathname;\n\n  if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {\n    return null;\n  }\n\n  // We want to leave trailing slash behavior in the user's control, so if they\n  // specify a basename with a trailing slash, we should support it\n  let startIndex = basename.endsWith(\"/\")\n    ? basename.length - 1\n    : basename.length;\n  let nextChar = pathname.charAt(startIndex);\n  if (nextChar && nextChar !== \"/\") {\n    // pathname does not start with basename/\n    return null;\n  }\n\n  return pathname.slice(startIndex) || \"/\";\n}\n\n/**\n * Returns a resolved path object relative to the given pathname.\n *\n * @see https://reactrouter.com/utils/resolve-path\n */\nexport function resolvePath(to: To, fromPathname = \"/\"): Path {\n  let {\n    pathname: toPathname,\n    search = \"\",\n    hash = \"\",\n  } = typeof to === \"string\" ? parsePath(to) : to;\n\n  let pathname = toPathname\n    ? toPathname.startsWith(\"/\")\n      ? toPathname\n      : resolvePathname(toPathname, fromPathname)\n    : fromPathname;\n\n  return {\n    pathname,\n    search: normalizeSearch(search),\n    hash: normalizeHash(hash),\n  };\n}\n\nfunction resolvePathname(relativePath: string, fromPathname: string): string {\n  let segments = fromPathname.replace(/\\/+$/, \"\").split(\"/\");\n  let relativeSegments = relativePath.split(\"/\");\n\n  relativeSegments.forEach((segment) => {\n    if (segment === \"..\") {\n      // Keep the root \"\" segment so the pathname starts at /\n      if (segments.length > 1) segments.pop();\n    } else if (segment !== \".\") {\n      segments.push(segment);\n    }\n  });\n\n  return segments.length > 1 ? segments.join(\"/\") : \"/\";\n}\n\nfunction getInvalidPathError(\n  char: string,\n  field: string,\n  dest: string,\n  path: Partial<Path>\n) {\n  return (\n    `Cannot include a '${char}' character in a manually specified ` +\n    `\\`to.${field}\\` field [${JSON.stringify(\n      path\n    )}].  Please separate it out to the ` +\n    `\\`to.${dest}\\` field. Alternatively you may provide the full path as ` +\n    `a string in <Link to=\"...\"> and the router will parse it for you.`\n  );\n}\n\n/**\n * @private\n *\n * When processing relative navigation we want to ignore ancestor routes that\n * do not contribute to the path, such that index/pathless layout routes don't\n * interfere.\n *\n * For example, when moving a route element into an index route and/or a\n * pathless layout route, relative link behavior contained within should stay\n * the same.  Both of the following examples should link back to the root:\n *\n *   <Route path=\"/\">\n *     <Route path=\"accounts\" element={<Link to=\"..\"}>\n *   </Route>\n *\n *   <Route path=\"/\">\n *     <Route path=\"accounts\">\n *       <Route element={<AccountsLayout />}>       // <-- Does not contribute\n *         <Route index element={<Link to=\"..\"} />  // <-- Does not contribute\n *       </Route\n *     </Route>\n *   </Route>\n */\nexport function getPathContributingMatches<\n  T extends AgnosticRouteMatch = AgnosticRouteMatch\n>(matches: T[]) {\n  return matches.filter(\n    (match, index) =>\n      index === 0 || (match.route.path && match.route.path.length > 0)\n  );\n}\n\n/**\n * @private\n */\nexport function resolveTo(\n  toArg: To,\n  routePathnames: string[],\n  locationPathname: string,\n  isPathRelative = false\n): Path {\n  let to: Partial<Path>;\n  if (typeof toArg === \"string\") {\n    to = parsePath(toArg);\n  } else {\n    to = { ...toArg };\n\n    invariant(\n      !to.pathname || !to.pathname.includes(\"?\"),\n      getInvalidPathError(\"?\", \"pathname\", \"search\", to)\n    );\n    invariant(\n      !to.pathname || !to.pathname.includes(\"#\"),\n      getInvalidPathError(\"#\", \"pathname\", \"hash\", to)\n    );\n    invariant(\n      !to.search || !to.search.includes(\"#\"),\n      getInvalidPathError(\"#\", \"search\", \"hash\", to)\n    );\n  }\n\n  let isEmptyPath = toArg === \"\" || to.pathname === \"\";\n  let toPathname = isEmptyPath ? \"/\" : to.pathname;\n\n  let from: string;\n\n  // Routing is relative to the current pathname if explicitly requested.\n  //\n  // If a pathname is explicitly provided in `to`, it should be relative to the\n  // route context. This is explained in `Note on `<Link to>` values` in our\n  // migration guide from v5 as a means of disambiguation between `to` values\n  // that begin with `/` and those that do not. However, this is problematic for\n  // `to` values that do not provide a pathname. `to` can simply be a search or\n  // hash string, in which case we should assume that the navigation is relative\n  // to the current location's pathname and *not* the route pathname.\n  if (isPathRelative || toPathname == null) {\n    from = locationPathname;\n  } else {\n    let routePathnameIndex = routePathnames.length - 1;\n\n    if (toPathname.startsWith(\"..\")) {\n      let toSegments = toPathname.split(\"/\");\n\n      // Each leading .. segment means \"go up one route\" instead of \"go up one\n      // URL segment\".  This is a key difference from how <a href> works and a\n      // major reason we call this a \"to\" value instead of a \"href\".\n      while (toSegments[0] === \"..\") {\n        toSegments.shift();\n        routePathnameIndex -= 1;\n      }\n\n      to.pathname = toSegments.join(\"/\");\n    }\n\n    // If there are more \"..\" segments than parent routes, resolve relative to\n    // the root / URL.\n    from = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : \"/\";\n  }\n\n  let path = resolvePath(to, from);\n\n  // Ensure the pathname has a trailing slash if the original \"to\" had one\n  let hasExplicitTrailingSlash =\n    toPathname && toPathname !== \"/\" && toPathname.endsWith(\"/\");\n  // Or if this was a link to the current path which has a trailing slash\n  let hasCurrentTrailingSlash =\n    (isEmptyPath || toPathname === \".\") && locationPathname.endsWith(\"/\");\n  if (\n    !path.pathname.endsWith(\"/\") &&\n    (hasExplicitTrailingSlash || hasCurrentTrailingSlash)\n  ) {\n    path.pathname += \"/\";\n  }\n\n  return path;\n}\n\n/**\n * @private\n */\nexport function getToPathname(to: To): string | undefined {\n  // Empty strings should be treated the same as / paths\n  return to === \"\" || (to as Path).pathname === \"\"\n    ? \"/\"\n    : typeof to === \"string\"\n    ? parsePath(to).pathname\n    : to.pathname;\n}\n\n/**\n * @private\n */\nexport const joinPaths = (paths: string[]): string =>\n  paths.join(\"/\").replace(/\\/\\/+/g, \"/\");\n\n/**\n * @private\n */\nexport const normalizePathname = (pathname: string): string =>\n  pathname.replace(/\\/+$/, \"\").replace(/^\\/*/, \"/\");\n\n/**\n * @private\n */\nexport const normalizeSearch = (search: string): string =>\n  !search || search === \"?\"\n    ? \"\"\n    : search.startsWith(\"?\")\n    ? search\n    : \"?\" + search;\n\n/**\n * @private\n */\nexport const normalizeHash = (hash: string): string =>\n  !hash || hash === \"#\" ? \"\" : hash.startsWith(\"#\") ? hash : \"#\" + hash;\n\nexport type JsonFunction = <Data>(\n  data: Data,\n  init?: number | ResponseInit\n) => Response;\n\n/**\n * This is a shortcut for creating `application/json` responses. Converts `data`\n * to JSON and sets the `Content-Type` header.\n */\nexport const json: JsonFunction = (data, init = {}) => {\n  let responseInit = typeof init === \"number\" ? { status: init } : init;\n\n  let headers = new Headers(responseInit.headers);\n  if (!headers.has(\"Content-Type\")) {\n    headers.set(\"Content-Type\", \"application/json; charset=utf-8\");\n  }\n\n  return new Response(JSON.stringify(data), {\n    ...responseInit,\n    headers,\n  });\n};\n\nexport interface TrackedPromise extends Promise<any> {\n  _tracked?: boolean;\n  _data?: any;\n  _error?: any;\n}\n\nexport class AbortedDeferredError extends Error {}\n\nexport class DeferredData {\n  private pendingKeysSet: Set<string> = new Set<string>();\n  private controller: AbortController;\n  private abortPromise: Promise<void>;\n  private unlistenAbortSignal: () => void;\n  private subscribers: Set<(aborted: boolean, settledKey?: string) => void> =\n    new Set();\n  data: Record<string, unknown>;\n  init?: ResponseInit;\n  deferredKeys: string[] = [];\n\n  constructor(data: Record<string, unknown>, responseInit?: ResponseInit) {\n    invariant(\n      data && typeof data === \"object\" && !Array.isArray(data),\n      \"defer() only accepts plain objects\"\n    );\n\n    // Set up an AbortController + Promise we can race against to exit early\n    // cancellation\n    let reject: (e: AbortedDeferredError) => void;\n    this.abortPromise = new Promise((_, r) => (reject = r));\n    this.controller = new AbortController();\n    let onAbort = () =>\n      reject(new AbortedDeferredError(\"Deferred data aborted\"));\n    this.unlistenAbortSignal = () =>\n      this.controller.signal.removeEventListener(\"abort\", onAbort);\n    this.controller.signal.addEventListener(\"abort\", onAbort);\n\n    this.data = Object.entries(data).reduce(\n      (acc, [key, value]) =>\n        Object.assign(acc, {\n          [key]: this.trackPromise(key, value),\n        }),\n      {}\n    );\n\n    if (this.done) {\n      // All incoming values were resolved\n      this.unlistenAbortSignal();\n    }\n\n    this.init = responseInit;\n  }\n\n  private trackPromise(\n    key: string,\n    value: Promise<unknown> | unknown\n  ): TrackedPromise | unknown {\n    if (!(value instanceof Promise)) {\n      return value;\n    }\n\n    this.deferredKeys.push(key);\n    this.pendingKeysSet.add(key);\n\n    // We store a little wrapper promise that will be extended with\n    // _data/_error props upon resolve/reject\n    let promise: TrackedPromise = Promise.race([value, this.abortPromise]).then(\n      (data) => this.onSettle(promise, key, undefined, data as unknown),\n      (error) => this.onSettle(promise, key, error as unknown)\n    );\n\n    // Register rejection listeners to avoid uncaught promise rejections on\n    // errors or aborted deferred values\n    promise.catch(() => {});\n\n    Object.defineProperty(promise, \"_tracked\", { get: () => true });\n    return promise;\n  }\n\n  private onSettle(\n    promise: TrackedPromise,\n    key: string,\n    error: unknown,\n    data?: unknown\n  ): unknown {\n    if (\n      this.controller.signal.aborted &&\n      error instanceof AbortedDeferredError\n    ) {\n      this.unlistenAbortSignal();\n      Object.defineProperty(promise, \"_error\", { get: () => error });\n      return Promise.reject(error);\n    }\n\n    this.pendingKeysSet.delete(key);\n\n    if (this.done) {\n      // Nothing left to abort!\n      this.unlistenAbortSignal();\n    }\n\n    // If the promise was resolved/rejected with undefined, we'll throw an error as you\n    // should always resolve with a value or null\n    if (error === undefined && data === undefined) {\n      let undefinedError = new Error(\n        `Deferred data for key \"${key}\" resolved/rejected with \\`undefined\\`, ` +\n          `you must resolve/reject with a value or \\`null\\`.`\n      );\n      Object.defineProperty(promise, \"_error\", { get: () => undefinedError });\n      this.emit(false, key);\n      return Promise.reject(undefinedError);\n    }\n\n    if (data === undefined) {\n      Object.defineProperty(promise, \"_error\", { get: () => error });\n      this.emit(false, key);\n      return Promise.reject(error);\n    }\n\n    Object.defineProperty(promise, \"_data\", { get: () => data });\n    this.emit(false, key);\n    return data;\n  }\n\n  private emit(aborted: boolean, settledKey?: string) {\n    this.subscribers.forEach((subscriber) => subscriber(aborted, settledKey));\n  }\n\n  subscribe(fn: (aborted: boolean, settledKey?: string) => void) {\n    this.subscribers.add(fn);\n    return () => this.subscribers.delete(fn);\n  }\n\n  cancel() {\n    this.controller.abort();\n    this.pendingKeysSet.forEach((v, k) => this.pendingKeysSet.delete(k));\n    this.emit(true);\n  }\n\n  async resolveData(signal: AbortSignal) {\n    let aborted = false;\n    if (!this.done) {\n      let onAbort = () => this.cancel();\n      signal.addEventListener(\"abort\", onAbort);\n      aborted = await new Promise((resolve) => {\n        this.subscribe((aborted) => {\n          signal.removeEventListener(\"abort\", onAbort);\n          if (aborted || this.done) {\n            resolve(aborted);\n          }\n        });\n      });\n    }\n    return aborted;\n  }\n\n  get done() {\n    return this.pendingKeysSet.size === 0;\n  }\n\n  get unwrappedData() {\n    invariant(\n      this.data !== null && this.done,\n      \"Can only unwrap data on initialized and settled deferreds\"\n    );\n\n    return Object.entries(this.data).reduce(\n      (acc, [key, value]) =>\n        Object.assign(acc, {\n          [key]: unwrapTrackedPromise(value),\n        }),\n      {}\n    );\n  }\n\n  get pendingKeys() {\n    return Array.from(this.pendingKeysSet);\n  }\n}\n\nfunction isTrackedPromise(value: any): value is TrackedPromise {\n  return (\n    value instanceof Promise && (value as TrackedPromise)._tracked === true\n  );\n}\n\nfunction unwrapTrackedPromise(value: any) {\n  if (!isTrackedPromise(value)) {\n    return value;\n  }\n\n  if (value._error) {\n    throw value._error;\n  }\n  return value._data;\n}\n\nexport type DeferFunction = (\n  data: Record<string, unknown>,\n  init?: number | ResponseInit\n) => DeferredData;\n\nexport const defer: DeferFunction = (data, init = {}) => {\n  let responseInit = typeof init === \"number\" ? { status: init } : init;\n\n  return new DeferredData(data, responseInit);\n};\n\nexport type RedirectFunction = (\n  url: string,\n  init?: number | ResponseInit\n) => Response;\n\n/**\n * A redirect response. Sets the status code and the `Location` header.\n * Defaults to \"302 Found\".\n */\nexport const redirect: RedirectFunction = (url, init = 302) => {\n  let responseInit = init;\n  if (typeof responseInit === \"number\") {\n    responseInit = { status: responseInit };\n  } else if (typeof responseInit.status === \"undefined\") {\n    responseInit.status = 302;\n  }\n\n  let headers = new Headers(responseInit.headers);\n  headers.set(\"Location\", url);\n\n  return new Response(null, {\n    ...responseInit,\n    headers,\n  });\n};\n\n/**\n * A redirect response that will force a document reload to the new location.\n * Sets the status code and the `Location` header.\n * Defaults to \"302 Found\".\n */\nexport const redirectDocument: RedirectFunction = (url, init) => {\n  let response = redirect(url, init);\n  response.headers.set(\"X-Remix-Reload-Document\", \"true\");\n  return response;\n};\n\n/**\n * @private\n * Utility class we use to hold auto-unwrapped 4xx/5xx Response bodies\n */\nexport class ErrorResponseImpl {\n  status: number;\n  statusText: string;\n  data: any;\n  private error?: Error;\n  private internal: boolean;\n\n  constructor(\n    status: number,\n    statusText: string | undefined,\n    data: any,\n    internal = false\n  ) {\n    this.status = status;\n    this.statusText = statusText || \"\";\n    this.internal = internal;\n    if (data instanceof Error) {\n      this.data = data.toString();\n      this.error = data;\n    } else {\n      this.data = data;\n    }\n  }\n}\n\n// We don't want the class exported since usage of it at runtime is an\n// implementation detail, but we do want to export the shape so folks can\n// build their own abstractions around instances via isRouteErrorResponse()\nexport type ErrorResponse = InstanceType<typeof ErrorResponseImpl>;\n\n/**\n * Check if the given error is an ErrorResponse generated from a 4xx/5xx\n * Response thrown from an action/loader\n */\nexport function isRouteErrorResponse(error: any): error is ErrorResponse {\n  return (\n    error != null &&\n    typeof error.status === \"number\" &&\n    typeof error.statusText === \"string\" &&\n    typeof error.internal === \"boolean\" &&\n    \"data\" in error\n  );\n}\n", "import type { History, Location, Path, To } from \"./history\";\nimport {\n  Action as HistoryAction,\n  createLocation,\n  createPath,\n  invariant,\n  parsePath,\n  warning,\n} from \"./history\";\nimport type {\n  ActionFunction,\n  AgnosticDataRouteMatch,\n  AgnosticDataRouteObject,\n  AgnosticRouteObject,\n  DataResult,\n  DeferredData,\n  DeferredResult,\n  DetectErrorBoundaryFunction,\n  ErrorResult,\n  FormEncType,\n  FormMethod,\n  HTMLFormMethod,\n  ImmutableRouteKey,\n  LoaderFunction,\n  MapRoutePropertiesFunction,\n  MutationFormMethod,\n  RedirectResult,\n  RouteData,\n  RouteManifest,\n  ShouldRevalidateFunctionArgs,\n  Submission,\n  SuccessResult,\n  UIMatch,\n  V7_FormMethod,\n  V7_MutationFormMethod,\n} from \"./utils\";\nimport {\n  ErrorResponseImpl,\n  ResultType,\n  convertRouteMatchToUiMatch,\n  convertRoutesToDataRoutes,\n  getPathContributingMatches,\n  immutableRouteKeys,\n  isRouteErrorResponse,\n  joinPaths,\n  matchRoutes,\n  resolveTo,\n  stripBasename,\n} from \"./utils\";\n\n////////////////////////////////////////////////////////////////////////////////\n//#region Types and Constants\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * A Router instance manages all navigation and data loading/mutations\n */\nexport interface Router {\n  /**\n   * @internal\n   * PRIVATE - DO NOT USE\n   *\n   * Return the basename for the router\n   */\n  get basename(): RouterInit[\"basename\"];\n\n  /**\n   * @internal\n   * PRIVATE - DO NOT USE\n   *\n   * Return the current state of the router\n   */\n  get state(): RouterState;\n\n  /**\n   * @internal\n   * PRIVATE - DO NOT USE\n   *\n   * Return the routes for this router instance\n   */\n  get routes(): AgnosticDataRouteObject[];\n\n  /**\n   * @internal\n   * PRIVATE - DO NOT USE\n   *\n   * Initialize the router, including adding history listeners and kicking off\n   * initial data fetches.  Returns a function to cleanup listeners and abort\n   * any in-progress loads\n   */\n  initialize(): Router;\n\n  /**\n   * @internal\n   * PRIVATE - DO NOT USE\n   *\n   * Subscribe to router.state updates\n   *\n   * @param fn function to call with the new state\n   */\n  subscribe(fn: RouterSubscriber): () => void;\n\n  /**\n   * @internal\n   * PRIVATE - DO NOT USE\n   *\n   * Enable scroll restoration behavior in the router\n   *\n   * @param savedScrollPositions Object that will manage positions, in case\n   *                             it's being restored from sessionStorage\n   * @param getScrollPosition    Function to get the active Y scroll position\n   * @param getKey               Function to get the key to use for restoration\n   */\n  enableScrollRestoration(\n    savedScrollPositions: Record<string, number>,\n    getScrollPosition: GetScrollPositionFunction,\n    getKey?: GetScrollRestorationKeyFunction\n  ): () => void;\n\n  /**\n   * @internal\n   * PRIVATE - DO NOT USE\n   *\n   * Navigate forward/backward in the history stack\n   * @param to Delta to move in the history stack\n   */\n  navigate(to: number): Promise<void>;\n\n  /**\n   * Navigate to the given path\n   * @param to Path to navigate to\n   * @param opts Navigation options (method, submission, etc.)\n   */\n  navigate(to: To | null, opts?: RouterNavigateOptions): Promise<void>;\n\n  /**\n   * @internal\n   * PRIVATE - DO NOT USE\n   *\n   * Trigger a fetcher load/submission\n   *\n   * @param key     Fetcher key\n   * @param routeId Route that owns the fetcher\n   * @param href    href to fetch\n   * @param opts    Fetcher options, (method, submission, etc.)\n   */\n  fetch(\n    key: string,\n    routeId: string,\n    href: string | null,\n    opts?: RouterFetchOptions\n  ): void;\n\n  /**\n   * @internal\n   * PRIVATE - DO NOT USE\n   *\n   * Trigger a revalidation of all current route loaders and fetcher loads\n   */\n  revalidate(): void;\n\n  /**\n   * @internal\n   * PRIVATE - DO NOT USE\n   *\n   * Utility function to create an href for the given location\n   * @param location\n   */\n  createHref(location: Location | URL): string;\n\n  /**\n   * @internal\n   * PRIVATE - DO NOT USE\n   *\n   * Utility function to URL encode a destination path according to the internal\n   * history implementation\n   * @param to\n   */\n  encodeLocation(to: To): Path;\n\n  /**\n   * @internal\n   * PRIVATE - DO NOT USE\n   *\n   * Get/create a fetcher for the given key\n   * @param key\n   */\n  getFetcher<TData = any>(key?: string): Fetcher<TData>;\n\n  /**\n   * @internal\n   * PRIVATE - DO NOT USE\n   *\n   * Delete the fetcher for a given key\n   * @param key\n   */\n  deleteFetcher(key?: string): void;\n\n  /**\n   * @internal\n   * PRIVATE - DO NOT USE\n   *\n   * Cleanup listeners and abort any in-progress loads\n   */\n  dispose(): void;\n\n  /**\n   * @internal\n   * PRIVATE - DO NOT USE\n   *\n   * Get a navigation blocker\n   * @param key The identifier for the blocker\n   * @param fn The blocker function implementation\n   */\n  getBlocker(key: string, fn: BlockerFunction): Blocker;\n\n  /**\n   * @internal\n   * PRIVATE - DO NOT USE\n   *\n   * Delete a navigation blocker\n   * @param key The identifier for the blocker\n   */\n  deleteBlocker(key: string): void;\n\n  /**\n   * @internal\n   * PRIVATE - DO NOT USE\n   *\n   * HMR needs to pass in-flight route updates to React Router\n   * TODO: Replace this with granular route update APIs (addRoute, updateRoute, deleteRoute)\n   */\n  _internalSetRoutes(routes: AgnosticRouteObject[]): void;\n\n  /**\n   * @internal\n   * PRIVATE - DO NOT USE\n   *\n   * Internal fetch AbortControllers accessed by unit tests\n   */\n  _internalFetchControllers: Map<string, AbortController>;\n\n  /**\n   * @internal\n   * PRIVATE - DO NOT USE\n   *\n   * Internal pending DeferredData instances accessed by unit tests\n   */\n  _internalActiveDeferreds: Map<string, DeferredData>;\n}\n\n/**\n * State maintained internally by the router.  During a navigation, all states\n * reflect the the \"old\" location unless otherwise noted.\n */\nexport interface RouterState {\n  /**\n   * The action of the most recent navigation\n   */\n  historyAction: HistoryAction;\n\n  /**\n   * The current location reflected by the router\n   */\n  location: Location;\n\n  /**\n   * The current set of route matches\n   */\n  matches: AgnosticDataRouteMatch[];\n\n  /**\n   * Tracks whether we've completed our initial data load\n   */\n  initialized: boolean;\n\n  /**\n   * Current scroll position we should start at for a new view\n   *  - number -> scroll position to restore to\n   *  - false -> do not restore scroll at all (used during submissions)\n   *  - null -> don't have a saved position, scroll to hash or top of page\n   */\n  restoreScrollPosition: number | false | null;\n\n  /**\n   * Indicate whether this navigation should skip resetting the scroll position\n   * if we are unable to restore the scroll position\n   */\n  preventScrollReset: boolean;\n\n  /**\n   * Tracks the state of the current navigation\n   */\n  navigation: Navigation;\n\n  /**\n   * Tracks any in-progress revalidations\n   */\n  revalidation: RevalidationState;\n\n  /**\n   * Data from the loaders for the current matches\n   */\n  loaderData: RouteData;\n\n  /**\n   * Data from the action for the current matches\n   */\n  actionData: RouteData | null;\n\n  /**\n   * Errors caught from loaders for the current matches\n   */\n  errors: RouteData | null;\n\n  /**\n   * Map of current fetchers\n   */\n  fetchers: Map<string, Fetcher>;\n\n  /**\n   * Map of current blockers\n   */\n  blockers: Map<string, Blocker>;\n}\n\n/**\n * Data that can be passed into hydrate a Router from SSR\n */\nexport type HydrationState = Partial<\n  Pick<RouterState, \"loaderData\" | \"actionData\" | \"errors\">\n>;\n\n/**\n * Future flags to toggle new feature behavior\n */\nexport interface FutureConfig {\n  v7_normalizeFormMethod: boolean;\n  v7_prependBasename: boolean;\n}\n\n/**\n * Initialization options for createRouter\n */\nexport interface RouterInit {\n  routes: AgnosticRouteObject[];\n  history: History;\n  basename?: string;\n  /**\n   * @deprecated Use `mapRouteProperties` instead\n   */\n  detectErrorBoundary?: DetectErrorBoundaryFunction;\n  mapRouteProperties?: MapRoutePropertiesFunction;\n  future?: Partial<FutureConfig>;\n  hydrationData?: HydrationState;\n  window?: Window;\n}\n\n/**\n * State returned from a server-side query() call\n */\nexport interface StaticHandlerContext {\n  basename: Router[\"basename\"];\n  location: RouterState[\"location\"];\n  matches: RouterState[\"matches\"];\n  loaderData: RouterState[\"loaderData\"];\n  actionData: RouterState[\"actionData\"];\n  errors: RouterState[\"errors\"];\n  statusCode: number;\n  loaderHeaders: Record<string, Headers>;\n  actionHeaders: Record<string, Headers>;\n  activeDeferreds: Record<string, DeferredData> | null;\n  _deepestRenderedBoundaryId?: string | null;\n}\n\n/**\n * A StaticHandler instance manages a singular SSR navigation/fetch event\n */\nexport interface StaticHandler {\n  dataRoutes: AgnosticDataRouteObject[];\n  query(\n    request: Request,\n    opts?: { requestContext?: unknown }\n  ): Promise<StaticHandlerContext | Response>;\n  queryRoute(\n    request: Request,\n    opts?: { routeId?: string; requestContext?: unknown }\n  ): Promise<any>;\n}\n\n/**\n * Subscriber function signature for changes to router state\n */\nexport interface RouterSubscriber {\n  (state: RouterState): void;\n}\n\n/**\n * Function signature for determining the key to be used in scroll restoration\n * for a given location\n */\nexport interface GetScrollRestorationKeyFunction {\n  (location: Location, matches: UIMatch[]): string | null;\n}\n\n/**\n * Function signature for determining the current scroll position\n */\nexport interface GetScrollPositionFunction {\n  (): number;\n}\n\nexport type RelativeRoutingType = \"route\" | \"path\";\n\n// Allowed for any navigation or fetch\ntype BaseNavigateOrFetchOptions = {\n  preventScrollReset?: boolean;\n  relative?: RelativeRoutingType;\n};\n\n// Only allowed for navigations\ntype BaseNavigateOptions = BaseNavigateOrFetchOptions & {\n  replace?: boolean;\n  state?: any;\n  fromRouteId?: string;\n};\n\n// Only allowed for submission navigations\ntype BaseSubmissionOptions = {\n  formMethod?: HTMLFormMethod;\n  formEncType?: FormEncType;\n} & (\n  | { formData: FormData; body?: undefined }\n  | { formData?: undefined; body: any }\n);\n\n/**\n * Options for a navigate() call for a normal (non-submission) navigation\n */\ntype LinkNavigateOptions = BaseNavigateOptions;\n\n/**\n * Options for a navigate() call for a submission navigation\n */\ntype SubmissionNavigateOptions = BaseNavigateOptions & BaseSubmissionOptions;\n\n/**\n * Options to pass to navigate() for a navigation\n */\nexport type RouterNavigateOptions =\n  | LinkNavigateOptions\n  | SubmissionNavigateOptions;\n\n/**\n * Options for a fetch() load\n */\ntype LoadFetchOptions = BaseNavigateOrFetchOptions;\n\n/**\n * Options for a fetch() submission\n */\ntype SubmitFetchOptions = BaseNavigateOrFetchOptions & BaseSubmissionOptions;\n\n/**\n * Options to pass to fetch()\n */\nexport type RouterFetchOptions = LoadFetchOptions | SubmitFetchOptions;\n\n/**\n * Potential states for state.navigation\n */\nexport type NavigationStates = {\n  Idle: {\n    state: \"idle\";\n    location: undefined;\n    formMethod: undefined;\n    formAction: undefined;\n    formEncType: undefined;\n    formData: undefined;\n    json: undefined;\n    text: undefined;\n  };\n  Loading: {\n    state: \"loading\";\n    location: Location;\n    formMethod: Submission[\"formMethod\"] | undefined;\n    formAction: Submission[\"formAction\"] | undefined;\n    formEncType: Submission[\"formEncType\"] | undefined;\n    formData: Submission[\"formData\"] | undefined;\n    json: Submission[\"json\"] | undefined;\n    text: Submission[\"text\"] | undefined;\n  };\n  Submitting: {\n    state: \"submitting\";\n    location: Location;\n    formMethod: Submission[\"formMethod\"];\n    formAction: Submission[\"formAction\"];\n    formEncType: Submission[\"formEncType\"];\n    formData: Submission[\"formData\"];\n    json: Submission[\"json\"];\n    text: Submission[\"text\"];\n  };\n};\n\nexport type Navigation = NavigationStates[keyof NavigationStates];\n\nexport type RevalidationState = \"idle\" | \"loading\";\n\n/**\n * Potential states for fetchers\n */\ntype FetcherStates<TData = any> = {\n  Idle: {\n    state: \"idle\";\n    formMethod: undefined;\n    formAction: undefined;\n    formEncType: undefined;\n    text: undefined;\n    formData: undefined;\n    json: undefined;\n    data: TData | undefined;\n  };\n  Loading: {\n    state: \"loading\";\n    formMethod: Submission[\"formMethod\"] | undefined;\n    formAction: Submission[\"formAction\"] | undefined;\n    formEncType: Submission[\"formEncType\"] | undefined;\n    text: Submission[\"text\"] | undefined;\n    formData: Submission[\"formData\"] | undefined;\n    json: Submission[\"json\"] | undefined;\n    data: TData | undefined;\n  };\n  Submitting: {\n    state: \"submitting\";\n    formMethod: Submission[\"formMethod\"];\n    formAction: Submission[\"formAction\"];\n    formEncType: Submission[\"formEncType\"];\n    text: Submission[\"text\"];\n    formData: Submission[\"formData\"];\n    json: Submission[\"json\"];\n    data: TData | undefined;\n  };\n};\n\nexport type Fetcher<TData = any> =\n  FetcherStates<TData>[keyof FetcherStates<TData>];\n\ninterface BlockerBlocked {\n  state: \"blocked\";\n  reset(): void;\n  proceed(): void;\n  location: Location;\n}\n\ninterface BlockerUnblocked {\n  state: \"unblocked\";\n  reset: undefined;\n  proceed: undefined;\n  location: undefined;\n}\n\ninterface BlockerProceeding {\n  state: \"proceeding\";\n  reset: undefined;\n  proceed: undefined;\n  location: Location;\n}\n\nexport type Blocker = BlockerUnblocked | BlockerBlocked | BlockerProceeding;\n\nexport type BlockerFunction = (args: {\n  currentLocation: Location;\n  nextLocation: Location;\n  historyAction: HistoryAction;\n}) => boolean;\n\ninterface ShortCircuitable {\n  /**\n   * startNavigation does not need to complete the navigation because we\n   * redirected or got interrupted\n   */\n  shortCircuited?: boolean;\n}\n\ninterface HandleActionResult extends ShortCircuitable {\n  /**\n   * Error thrown from the current action, keyed by the route containing the\n   * error boundary to render the error.  To be committed to the state after\n   * loaders have completed\n   */\n  pendingActionError?: RouteData;\n  /**\n   * Data returned from the current action, keyed by the route owning the action.\n   * To be committed to the state after loaders have completed\n   */\n  pendingActionData?: RouteData;\n}\n\ninterface HandleLoadersResult extends ShortCircuitable {\n  /**\n   * loaderData returned from the current set of loaders\n   */\n  loaderData?: RouterState[\"loaderData\"];\n  /**\n   * errors thrown from the current set of loaders\n   */\n  errors?: RouterState[\"errors\"];\n}\n\n/**\n * Cached info for active fetcher.load() instances so they can participate\n * in revalidation\n */\ninterface FetchLoadMatch {\n  routeId: string;\n  path: string;\n}\n\n/**\n * Identified fetcher.load() calls that need to be revalidated\n */\ninterface RevalidatingFetcher extends FetchLoadMatch {\n  key: string;\n  match: AgnosticDataRouteMatch | null;\n  matches: AgnosticDataRouteMatch[] | null;\n  controller: AbortController | null;\n}\n\n/**\n * Wrapper object to allow us to throw any response out from callLoaderOrAction\n * for queryRouter while preserving whether or not it was thrown or returned\n * from the loader/action\n */\ninterface QueryRouteResponse {\n  type: ResultType.data | ResultType.error;\n  response: Response;\n}\n\nconst validMutationMethodsArr: MutationFormMethod[] = [\n  \"post\",\n  \"put\",\n  \"patch\",\n  \"delete\",\n];\nconst validMutationMethods = new Set<MutationFormMethod>(\n  validMutationMethodsArr\n);\n\nconst validRequestMethodsArr: FormMethod[] = [\n  \"get\",\n  ...validMutationMethodsArr,\n];\nconst validRequestMethods = new Set<FormMethod>(validRequestMethodsArr);\n\nconst redirectStatusCodes = new Set([301, 302, 303, 307, 308]);\nconst redirectPreserveMethodStatusCodes = new Set([307, 308]);\n\nexport const IDLE_NAVIGATION: NavigationStates[\"Idle\"] = {\n  state: \"idle\",\n  location: undefined,\n  formMethod: undefined,\n  formAction: undefined,\n  formEncType: undefined,\n  formData: undefined,\n  json: undefined,\n  text: undefined,\n};\n\nexport const IDLE_FETCHER: FetcherStates[\"Idle\"] = {\n  state: \"idle\",\n  data: undefined,\n  formMethod: undefined,\n  formAction: undefined,\n  formEncType: undefined,\n  formData: undefined,\n  json: undefined,\n  text: undefined,\n};\n\nexport const IDLE_BLOCKER: BlockerUnblocked = {\n  state: \"unblocked\",\n  proceed: undefined,\n  reset: undefined,\n  location: undefined,\n};\n\nconst ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|\\/\\/)/i;\n\nconst defaultMapRouteProperties: MapRoutePropertiesFunction = (route) => ({\n  hasErrorBoundary: Boolean(route.hasErrorBoundary),\n});\n\n//#endregion\n\n////////////////////////////////////////////////////////////////////////////////\n//#region createRouter\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * Create a router and listen to history POP navigations\n */\nexport function createRouter(init: RouterInit): Router {\n  const routerWindow = init.window\n    ? init.window\n    : typeof window !== \"undefined\"\n    ? window\n    : undefined;\n  const isBrowser =\n    typeof routerWindow !== \"undefined\" &&\n    typeof routerWindow.document !== \"undefined\" &&\n    typeof routerWindow.document.createElement !== \"undefined\";\n  const isServer = !isBrowser;\n\n  invariant(\n    init.routes.length > 0,\n    \"You must provide a non-empty routes array to createRouter\"\n  );\n\n  let mapRouteProperties: MapRoutePropertiesFunction;\n  if (init.mapRouteProperties) {\n    mapRouteProperties = init.mapRouteProperties;\n  } else if (init.detectErrorBoundary) {\n    // If they are still using the deprecated version, wrap it with the new API\n    let detectErrorBoundary = init.detectErrorBoundary;\n    mapRouteProperties = (route) => ({\n      hasErrorBoundary: detectErrorBoundary(route),\n    });\n  } else {\n    mapRouteProperties = defaultMapRouteProperties;\n  }\n\n  // Routes keyed by ID\n  let manifest: RouteManifest = {};\n  // Routes in tree format for matching\n  let dataRoutes = convertRoutesToDataRoutes(\n    init.routes,\n    mapRouteProperties,\n    undefined,\n    manifest\n  );\n  let inFlightDataRoutes: AgnosticDataRouteObject[] | undefined;\n  let basename = init.basename || \"/\";\n  // Config driven behavior flags\n  let future: FutureConfig = {\n    v7_normalizeFormMethod: false,\n    v7_prependBasename: false,\n    ...init.future,\n  };\n  // Cleanup function for history\n  let unlistenHistory: (() => void) | null = null;\n  // Externally-provided functions to call on all state changes\n  let subscribers = new Set<RouterSubscriber>();\n  // Externally-provided object to hold scroll restoration locations during routing\n  let savedScrollPositions: Record<string, number> | null = null;\n  // Externally-provided function to get scroll restoration keys\n  let getScrollRestorationKey: GetScrollRestorationKeyFunction | null = null;\n  // Externally-provided function to get current scroll position\n  let getScrollPosition: GetScrollPositionFunction | null = null;\n  // One-time flag to control the initial hydration scroll restoration.  Because\n  // we don't get the saved positions from <ScrollRestoration /> until _after_\n  // the initial render, we need to manually trigger a separate updateState to\n  // send along the restoreScrollPosition\n  // Set to true if we have `hydrationData` since we assume we were SSR'd and that\n  // SSR did the initial scroll restoration.\n  let initialScrollRestored = init.hydrationData != null;\n\n  let initialMatches = matchRoutes(dataRoutes, init.history.location, basename);\n  let initialErrors: RouteData | null = null;\n\n  if (initialMatches == null) {\n    // If we do not match a user-provided-route, fall back to the root\n    // to allow the error boundary to take over\n    let error = getInternalRouterError(404, {\n      pathname: init.history.location.pathname,\n    });\n    let { matches, route } = getShortCircuitMatches(dataRoutes);\n    initialMatches = matches;\n    initialErrors = { [route.id]: error };\n  }\n\n  let initialized =\n    // All initialMatches need to be loaded before we're ready.  If we have lazy\n    // functions around still then we'll need to run them in initialize()\n    !initialMatches.some((m) => m.route.lazy) &&\n    // And we have to either have no loaders or have been provided hydrationData\n    (!initialMatches.some((m) => m.route.loader) || init.hydrationData != null);\n\n  let router: Router;\n  let state: RouterState = {\n    historyAction: init.history.action,\n    location: init.history.location,\n    matches: initialMatches,\n    initialized,\n    navigation: IDLE_NAVIGATION,\n    // Don't restore on initial updateState() if we were SSR'd\n    restoreScrollPosition: init.hydrationData != null ? false : null,\n    preventScrollReset: false,\n    revalidation: \"idle\",\n    loaderData: (init.hydrationData && init.hydrationData.loaderData) || {},\n    actionData: (init.hydrationData && init.hydrationData.actionData) || null,\n    errors: (init.hydrationData && init.hydrationData.errors) || initialErrors,\n    fetchers: new Map(),\n    blockers: new Map(),\n  };\n\n  // -- Stateful internal variables to manage navigations --\n  // Current navigation in progress (to be committed in completeNavigation)\n  let pendingAction: HistoryAction = HistoryAction.Pop;\n\n  // Should the current navigation prevent the scroll reset if scroll cannot\n  // be restored?\n  let pendingPreventScrollReset = false;\n\n  // AbortController for the active navigation\n  let pendingNavigationController: AbortController | null;\n\n  // We use this to avoid touching history in completeNavigation if a\n  // revalidation is entirely uninterrupted\n  let isUninterruptedRevalidation = false;\n\n  // Use this internal flag to force revalidation of all loaders:\n  //  - submissions (completed or interrupted)\n  //  - useRevalidator()\n  //  - X-Remix-Revalidate (from redirect)\n  let isRevalidationRequired = false;\n\n  // Use this internal array to capture routes that require revalidation due\n  // to a cancelled deferred on action submission\n  let cancelledDeferredRoutes: string[] = [];\n\n  // Use this internal array to capture fetcher loads that were cancelled by an\n  // action navigation and require revalidation\n  let cancelledFetcherLoads: string[] = [];\n\n  // AbortControllers for any in-flight fetchers\n  let fetchControllers = new Map<string, AbortController>();\n\n  // Track loads based on the order in which they started\n  let incrementingLoadId = 0;\n\n  // Track the outstanding pending navigation data load to be compared against\n  // the globally incrementing load when a fetcher load lands after a completed\n  // navigation\n  let pendingNavigationLoadId = -1;\n\n  // Fetchers that triggered data reloads as a result of their actions\n  let fetchReloadIds = new Map<string, number>();\n\n  // Fetchers that triggered redirect navigations\n  let fetchRedirectIds = new Set<string>();\n\n  // Most recent href/match for fetcher.load calls for fetchers\n  let fetchLoadMatches = new Map<string, FetchLoadMatch>();\n\n  // Store DeferredData instances for active route matches.  When a\n  // route loader returns defer() we stick one in here.  Then, when a nested\n  // promise resolves we update loaderData.  If a new navigation starts we\n  // cancel active deferreds for eliminated routes.\n  let activeDeferreds = new Map<string, DeferredData>();\n\n  // Store blocker functions in a separate Map outside of router state since\n  // we don't need to update UI state if they change\n  let blockerFunctions = new Map<string, BlockerFunction>();\n\n  // Flag to ignore the next history update, so we can revert the URL change on\n  // a POP navigation that was blocked by the user without touching router state\n  let ignoreNextHistoryUpdate = false;\n\n  // Initialize the router, all side effects should be kicked off from here.\n  // Implemented as a Fluent API for ease of:\n  //   let router = createRouter(init).initialize();\n  function initialize() {\n    // If history informs us of a POP navigation, start the navigation but do not update\n    // state.  We'll update our own state once the navigation completes\n    unlistenHistory = init.history.listen(\n      ({ action: historyAction, location, delta }) => {\n        // Ignore this event if it was just us resetting the URL from a\n        // blocked POP navigation\n        if (ignoreNextHistoryUpdate) {\n          ignoreNextHistoryUpdate = false;\n          return;\n        }\n\n        warning(\n          blockerFunctions.size === 0 || delta != null,\n          \"You are trying to use a blocker on a POP navigation to a location \" +\n            \"that was not created by @remix-run/router. This will fail silently in \" +\n            \"production. This can happen if you are navigating outside the router \" +\n            \"via `window.history.pushState`/`window.location.hash` instead of using \" +\n            \"router navigation APIs.  This can also happen if you are using \" +\n            \"createHashRouter and the user manually changes the URL.\"\n        );\n\n        let blockerKey = shouldBlockNavigation({\n          currentLocation: state.location,\n          nextLocation: location,\n          historyAction,\n        });\n\n        if (blockerKey && delta != null) {\n          // Restore the URL to match the current UI, but don't update router state\n          ignoreNextHistoryUpdate = true;\n          init.history.go(delta * -1);\n\n          // Put the blocker into a blocked state\n          updateBlocker(blockerKey, {\n            state: \"blocked\",\n            location,\n            proceed() {\n              updateBlocker(blockerKey!, {\n                state: \"proceeding\",\n                proceed: undefined,\n                reset: undefined,\n                location,\n              });\n              // Re-do the same POP navigation we just blocked\n              init.history.go(delta);\n            },\n            reset() {\n              let blockers = new Map(state.blockers);\n              blockers.set(blockerKey!, IDLE_BLOCKER);\n              updateState({ blockers });\n            },\n          });\n          return;\n        }\n\n        return startNavigation(historyAction, location);\n      }\n    );\n\n    // Kick off initial data load if needed.  Use Pop to avoid modifying history\n    // Note we don't do any handling of lazy here.  For SPA's it'll get handled\n    // in the normal navigation flow.  For SSR it's expected that lazy modules are\n    // resolved prior to router creation since we can't go into a fallbackElement\n    // UI for SSR'd apps\n    if (!state.initialized) {\n      startNavigation(HistoryAction.Pop, state.location);\n    }\n\n    return router;\n  }\n\n  // Clean up a router and it's side effects\n  function dispose() {\n    if (unlistenHistory) {\n      unlistenHistory();\n    }\n    subscribers.clear();\n    pendingNavigationController && pendingNavigationController.abort();\n    state.fetchers.forEach((_, key) => deleteFetcher(key));\n    state.blockers.forEach((_, key) => deleteBlocker(key));\n  }\n\n  // Subscribe to state updates for the router\n  function subscribe(fn: RouterSubscriber) {\n    subscribers.add(fn);\n    return () => subscribers.delete(fn);\n  }\n\n  // Update our state and notify the calling context of the change\n  function updateState(newState: Partial<RouterState>): void {\n    state = {\n      ...state,\n      ...newState,\n    };\n    subscribers.forEach((subscriber) => subscriber(state));\n  }\n\n  // Complete a navigation returning the state.navigation back to the IDLE_NAVIGATION\n  // and setting state.[historyAction/location/matches] to the new route.\n  // - Location is a required param\n  // - Navigation will always be set to IDLE_NAVIGATION\n  // - Can pass any other state in newState\n  function completeNavigation(\n    location: Location,\n    newState: Partial<Omit<RouterState, \"action\" | \"location\" | \"navigation\">>\n  ): void {\n    // Deduce if we're in a loading/actionReload state:\n    // - We have committed actionData in the store\n    // - The current navigation was a mutation submission\n    // - We're past the submitting state and into the loading state\n    // - The location being loaded is not the result of a redirect\n    let isActionReload =\n      state.actionData != null &&\n      state.navigation.formMethod != null &&\n      isMutationMethod(state.navigation.formMethod) &&\n      state.navigation.state === \"loading\" &&\n      location.state?._isRedirect !== true;\n\n    let actionData: RouteData | null;\n    if (newState.actionData) {\n      if (Object.keys(newState.actionData).length > 0) {\n        actionData = newState.actionData;\n      } else {\n        // Empty actionData -> clear prior actionData due to an action error\n        actionData = null;\n      }\n    } else if (isActionReload) {\n      // Keep the current data if we're wrapping up the action reload\n      actionData = state.actionData;\n    } else {\n      // Clear actionData on any other completed navigations\n      actionData = null;\n    }\n\n    // Always preserve any existing loaderData from re-used routes\n    let loaderData = newState.loaderData\n      ? mergeLoaderData(\n          state.loaderData,\n          newState.loaderData,\n          newState.matches || [],\n          newState.errors\n        )\n      : state.loaderData;\n\n    // On a successful navigation we can assume we got through all blockers\n    // so we can start fresh\n    let blockers = state.blockers;\n    if (blockers.size > 0) {\n      blockers = new Map(blockers);\n      blockers.forEach((_, k) => blockers.set(k, IDLE_BLOCKER));\n    }\n\n    // Always respect the user flag.  Otherwise don't reset on mutation\n    // submission navigations unless they redirect\n    let preventScrollReset =\n      pendingPreventScrollReset === true ||\n      (state.navigation.formMethod != null &&\n        isMutationMethod(state.navigation.formMethod) &&\n        location.state?._isRedirect !== true);\n\n    if (inFlightDataRoutes) {\n      dataRoutes = inFlightDataRoutes;\n      inFlightDataRoutes = undefined;\n    }\n\n    if (isUninterruptedRevalidation) {\n      // If this was an uninterrupted revalidation then do not touch history\n    } else if (pendingAction === HistoryAction.Pop) {\n      // Do nothing for POP - URL has already been updated\n    } else if (pendingAction === HistoryAction.Push) {\n      init.history.push(location, location.state);\n    } else if (pendingAction === HistoryAction.Replace) {\n      init.history.replace(location, location.state);\n    }\n\n    updateState({\n      ...newState, // matches, errors, fetchers go through as-is\n      actionData,\n      loaderData,\n      historyAction: pendingAction,\n      location,\n      initialized: true,\n      navigation: IDLE_NAVIGATION,\n      revalidation: \"idle\",\n      restoreScrollPosition: getSavedScrollPosition(\n        location,\n        newState.matches || state.matches\n      ),\n      preventScrollReset,\n      blockers,\n    });\n\n    // Reset stateful navigation vars\n    pendingAction = HistoryAction.Pop;\n    pendingPreventScrollReset = false;\n    isUninterruptedRevalidation = false;\n    isRevalidationRequired = false;\n    cancelledDeferredRoutes = [];\n    cancelledFetcherLoads = [];\n  }\n\n  // Trigger a navigation event, which can either be a numerical POP or a PUSH\n  // replace with an optional submission\n  async function navigate(\n    to: number | To | null,\n    opts?: RouterNavigateOptions\n  ): Promise<void> {\n    if (typeof to === \"number\") {\n      init.history.go(to);\n      return;\n    }\n\n    let normalizedPath = normalizeTo(\n      state.location,\n      state.matches,\n      basename,\n      future.v7_prependBasename,\n      to,\n      opts?.fromRouteId,\n      opts?.relative\n    );\n    let { path, submission, error } = normalizeNavigateOptions(\n      future.v7_normalizeFormMethod,\n      false,\n      normalizedPath,\n      opts\n    );\n\n    let currentLocation = state.location;\n    let nextLocation = createLocation(state.location, path, opts && opts.state);\n\n    // When using navigate as a PUSH/REPLACE we aren't reading an already-encoded\n    // URL from window.location, so we need to encode it here so the behavior\n    // remains the same as POP and non-data-router usages.  new URL() does all\n    // the same encoding we'd get from a history.pushState/window.location read\n    // without having to touch history\n    nextLocation = {\n      ...nextLocation,\n      ...init.history.encodeLocation(nextLocation),\n    };\n\n    let userReplace = opts && opts.replace != null ? opts.replace : undefined;\n\n    let historyAction = HistoryAction.Push;\n\n    if (userReplace === true) {\n      historyAction = HistoryAction.Replace;\n    } else if (userReplace === false) {\n      // no-op\n    } else if (\n      submission != null &&\n      isMutationMethod(submission.formMethod) &&\n      submission.formAction === state.location.pathname + state.location.search\n    ) {\n      // By default on submissions to the current location we REPLACE so that\n      // users don't have to double-click the back button to get to the prior\n      // location.  If the user redirects to a different location from the\n      // action/loader this will be ignored and the redirect will be a PUSH\n      historyAction = HistoryAction.Replace;\n    }\n\n    let preventScrollReset =\n      opts && \"preventScrollReset\" in opts\n        ? opts.preventScrollReset === true\n        : undefined;\n\n    let blockerKey = shouldBlockNavigation({\n      currentLocation,\n      nextLocation,\n      historyAction,\n    });\n\n    if (blockerKey) {\n      // Put the blocker into a blocked state\n      updateBlocker(blockerKey, {\n        state: \"blocked\",\n        location: nextLocation,\n        proceed() {\n          updateBlocker(blockerKey!, {\n            state: \"proceeding\",\n            proceed: undefined,\n            reset: undefined,\n            location: nextLocation,\n          });\n          // Send the same navigation through\n          navigate(to, opts);\n        },\n        reset() {\n          let blockers = new Map(state.blockers);\n          blockers.set(blockerKey!, IDLE_BLOCKER);\n          updateState({ blockers });\n        },\n      });\n      return;\n    }\n\n    return await startNavigation(historyAction, nextLocation, {\n      submission,\n      // Send through the formData serialization error if we have one so we can\n      // render at the right error boundary after we match routes\n      pendingError: error,\n      preventScrollReset,\n      replace: opts && opts.replace,\n    });\n  }\n\n  // Revalidate all current loaders.  If a navigation is in progress or if this\n  // is interrupted by a navigation, allow this to \"succeed\" by calling all\n  // loaders during the next loader round\n  function revalidate() {\n    interruptActiveLoads();\n    updateState({ revalidation: \"loading\" });\n\n    // If we're currently submitting an action, we don't need to start a new\n    // navigation, we'll just let the follow up loader execution call all loaders\n    if (state.navigation.state === \"submitting\") {\n      return;\n    }\n\n    // If we're currently in an idle state, start a new navigation for the current\n    // action/location and mark it as uninterrupted, which will skip the history\n    // update in completeNavigation\n    if (state.navigation.state === \"idle\") {\n      startNavigation(state.historyAction, state.location, {\n        startUninterruptedRevalidation: true,\n      });\n      return;\n    }\n\n    // Otherwise, if we're currently in a loading state, just start a new\n    // navigation to the navigation.location but do not trigger an uninterrupted\n    // revalidation so that history correctly updates once the navigation completes\n    startNavigation(\n      pendingAction || state.historyAction,\n      state.navigation.location,\n      { overrideNavigation: state.navigation }\n    );\n  }\n\n  // Start a navigation to the given action/location.  Can optionally provide a\n  // overrideNavigation which will override the normalLoad in the case of a redirect\n  // navigation\n  async function startNavigation(\n    historyAction: HistoryAction,\n    location: Location,\n    opts?: {\n      submission?: Submission;\n      fetcherSubmission?: Submission;\n      overrideNavigation?: Navigation;\n      pendingError?: ErrorResponseImpl;\n      startUninterruptedRevalidation?: boolean;\n      preventScrollReset?: boolean;\n      replace?: boolean;\n    }\n  ): Promise<void> {\n    // Abort any in-progress navigations and start a new one. Unset any ongoing\n    // uninterrupted revalidations unless told otherwise, since we want this\n    // new navigation to update history normally\n    pendingNavigationController && pendingNavigationController.abort();\n    pendingNavigationController = null;\n    pendingAction = historyAction;\n    isUninterruptedRevalidation =\n      (opts && opts.startUninterruptedRevalidation) === true;\n\n    // Save the current scroll position every time we start a new navigation,\n    // and track whether we should reset scroll on completion\n    saveScrollPosition(state.location, state.matches);\n    pendingPreventScrollReset = (opts && opts.preventScrollReset) === true;\n\n    let routesToUse = inFlightDataRoutes || dataRoutes;\n    let loadingNavigation = opts && opts.overrideNavigation;\n    let matches = matchRoutes(routesToUse, location, basename);\n\n    // Short circuit with a 404 on the root error boundary if we match nothing\n    if (!matches) {\n      let error = getInternalRouterError(404, { pathname: location.pathname });\n      let { matches: notFoundMatches, route } =\n        getShortCircuitMatches(routesToUse);\n      // Cancel all pending deferred on 404s since we don't keep any routes\n      cancelActiveDeferreds();\n      completeNavigation(location, {\n        matches: notFoundMatches,\n        loaderData: {},\n        errors: {\n          [route.id]: error,\n        },\n      });\n      return;\n    }\n\n    // Short circuit if it's only a hash change and not a revalidation or\n    // mutation submission.\n    //\n    // Ignore on initial page loads because since the initial load will always\n    // be \"same hash\".  For example, on /page#hash and submit a <Form method=\"post\">\n    // which will default to a navigation to /page\n    if (\n      state.initialized &&\n      !isRevalidationRequired &&\n      isHashChangeOnly(state.location, location) &&\n      !(opts && opts.submission && isMutationMethod(opts.submission.formMethod))\n    ) {\n      completeNavigation(location, { matches });\n      return;\n    }\n\n    // Create a controller/Request for this navigation\n    pendingNavigationController = new AbortController();\n    let request = createClientSideRequest(\n      init.history,\n      location,\n      pendingNavigationController.signal,\n      opts && opts.submission\n    );\n    let pendingActionData: RouteData | undefined;\n    let pendingError: RouteData | undefined;\n\n    if (opts && opts.pendingError) {\n      // If we have a pendingError, it means the user attempted a GET submission\n      // with binary FormData so assign here and skip to handleLoaders.  That\n      // way we handle calling loaders above the boundary etc.  It's not really\n      // different from an actionError in that sense.\n      pendingError = {\n        [findNearestBoundary(matches).route.id]: opts.pendingError,\n      };\n    } else if (\n      opts &&\n      opts.submission &&\n      isMutationMethod(opts.submission.formMethod)\n    ) {\n      // Call action if we received an action submission\n      let actionOutput = await handleAction(\n        request,\n        location,\n        opts.submission,\n        matches,\n        { replace: opts.replace }\n      );\n\n      if (actionOutput.shortCircuited) {\n        return;\n      }\n\n      pendingActionData = actionOutput.pendingActionData;\n      pendingError = actionOutput.pendingActionError;\n      loadingNavigation = getLoadingNavigation(location, opts.submission);\n\n      // Create a GET request for the loaders\n      request = new Request(request.url, { signal: request.signal });\n    }\n\n    // Call loaders\n    let { shortCircuited, loaderData, errors } = await handleLoaders(\n      request,\n      location,\n      matches,\n      loadingNavigation,\n      opts && opts.submission,\n      opts && opts.fetcherSubmission,\n      opts && opts.replace,\n      pendingActionData,\n      pendingError\n    );\n\n    if (shortCircuited) {\n      return;\n    }\n\n    // Clean up now that the action/loaders have completed.  Don't clean up if\n    // we short circuited because pendingNavigationController will have already\n    // been assigned to a new controller for the next navigation\n    pendingNavigationController = null;\n\n    completeNavigation(location, {\n      matches,\n      ...(pendingActionData ? { actionData: pendingActionData } : {}),\n      loaderData,\n      errors,\n    });\n  }\n\n  // Call the action matched by the leaf route for this navigation and handle\n  // redirects/errors\n  async function handleAction(\n    request: Request,\n    location: Location,\n    submission: Submission,\n    matches: AgnosticDataRouteMatch[],\n    opts: { replace?: boolean } = {}\n  ): Promise<HandleActionResult> {\n    interruptActiveLoads();\n\n    // Put us in a submitting state\n    let navigation = getSubmittingNavigation(location, submission);\n    updateState({ navigation });\n\n    // Call our action and get the result\n    let result: DataResult;\n    let actionMatch = getTargetMatch(matches, location);\n\n    if (!actionMatch.route.action && !actionMatch.route.lazy) {\n      result = {\n        type: ResultType.error,\n        error: getInternalRouterError(405, {\n          method: request.method,\n          pathname: location.pathname,\n          routeId: actionMatch.route.id,\n        }),\n      };\n    } else {\n      result = await callLoaderOrAction(\n        \"action\",\n        request,\n        actionMatch,\n        matches,\n        manifest,\n        mapRouteProperties,\n        basename\n      );\n\n      if (request.signal.aborted) {\n        return { shortCircuited: true };\n      }\n    }\n\n    if (isRedirectResult(result)) {\n      let replace: boolean;\n      if (opts && opts.replace != null) {\n        replace = opts.replace;\n      } else {\n        // If the user didn't explicity indicate replace behavior, replace if\n        // we redirected to the exact same location we're currently at to avoid\n        // double back-buttons\n        replace =\n          result.location === state.location.pathname + state.location.search;\n      }\n      await startRedirectNavigation(state, result, { submission, replace });\n      return { shortCircuited: true };\n    }\n\n    if (isErrorResult(result)) {\n      // Store off the pending error - we use it to determine which loaders\n      // to call and will commit it when we complete the navigation\n      let boundaryMatch = findNearestBoundary(matches, actionMatch.route.id);\n\n      // By default, all submissions are REPLACE navigations, but if the\n      // action threw an error that'll be rendered in an errorElement, we fall\n      // back to PUSH so that the user can use the back button to get back to\n      // the pre-submission form location to try again\n      if ((opts && opts.replace) !== true) {\n        pendingAction = HistoryAction.Push;\n      }\n\n      return {\n        // Send back an empty object we can use to clear out any prior actionData\n        pendingActionData: {},\n        pendingActionError: { [boundaryMatch.route.id]: result.error },\n      };\n    }\n\n    if (isDeferredResult(result)) {\n      throw getInternalRouterError(400, { type: \"defer-action\" });\n    }\n\n    return {\n      pendingActionData: { [actionMatch.route.id]: result.data },\n    };\n  }\n\n  // Call all applicable loaders for the given matches, handling redirects,\n  // errors, etc.\n  async function handleLoaders(\n    request: Request,\n    location: Location,\n    matches: AgnosticDataRouteMatch[],\n    overrideNavigation?: Navigation,\n    submission?: Submission,\n    fetcherSubmission?: Submission,\n    replace?: boolean,\n    pendingActionData?: RouteData,\n    pendingError?: RouteData\n  ): Promise<HandleLoadersResult> {\n    // Figure out the right navigation we want to use for data loading\n    let loadingNavigation =\n      overrideNavigation || getLoadingNavigation(location, submission);\n\n    // If this was a redirect from an action we don't have a \"submission\" but\n    // we have it on the loading navigation so use that if available\n    let activeSubmission =\n      submission ||\n      fetcherSubmission ||\n      getSubmissionFromNavigation(loadingNavigation);\n\n    let routesToUse = inFlightDataRoutes || dataRoutes;\n    let [matchesToLoad, revalidatingFetchers] = getMatchesToLoad(\n      init.history,\n      state,\n      matches,\n      activeSubmission,\n      location,\n      isRevalidationRequired,\n      cancelledDeferredRoutes,\n      cancelledFetcherLoads,\n      fetchLoadMatches,\n      fetchRedirectIds,\n      routesToUse,\n      basename,\n      pendingActionData,\n      pendingError\n    );\n\n    // Cancel pending deferreds for no-longer-matched routes or routes we're\n    // about to reload.  Note that if this is an action reload we would have\n    // already cancelled all pending deferreds so this would be a no-op\n    cancelActiveDeferreds(\n      (routeId) =>\n        !(matches && matches.some((m) => m.route.id === routeId)) ||\n        (matchesToLoad && matchesToLoad.some((m) => m.route.id === routeId))\n    );\n\n    pendingNavigationLoadId = ++incrementingLoadId;\n\n    // Short circuit if we have no loaders to run\n    if (matchesToLoad.length === 0 && revalidatingFetchers.length === 0) {\n      let updatedFetchers = markFetchRedirectsDone();\n      completeNavigation(location, {\n        matches,\n        loaderData: {},\n        // Commit pending error if we're short circuiting\n        errors: pendingError || null,\n        ...(pendingActionData ? { actionData: pendingActionData } : {}),\n        ...(updatedFetchers ? { fetchers: new Map(state.fetchers) } : {}),\n      });\n      return { shortCircuited: true };\n    }\n\n    // If this is an uninterrupted revalidation, we remain in our current idle\n    // state.  If not, we need to switch to our loading state and load data,\n    // preserving any new action data or existing action data (in the case of\n    // a revalidation interrupting an actionReload)\n    if (!isUninterruptedRevalidation) {\n      revalidatingFetchers.forEach((rf) => {\n        let fetcher = state.fetchers.get(rf.key);\n        let revalidatingFetcher = getLoadingFetcher(\n          undefined,\n          fetcher ? fetcher.data : undefined\n        );\n        state.fetchers.set(rf.key, revalidatingFetcher);\n      });\n      let actionData = pendingActionData || state.actionData;\n      updateState({\n        navigation: loadingNavigation,\n        ...(actionData\n          ? Object.keys(actionData).length === 0\n            ? { actionData: null }\n            : { actionData }\n          : {}),\n        ...(revalidatingFetchers.length > 0\n          ? { fetchers: new Map(state.fetchers) }\n          : {}),\n      });\n    }\n\n    revalidatingFetchers.forEach((rf) => {\n      if (fetchControllers.has(rf.key)) {\n        abortFetcher(rf.key);\n      }\n      if (rf.controller) {\n        // Fetchers use an independent AbortController so that aborting a fetcher\n        // (via deleteFetcher) does not abort the triggering navigation that\n        // triggered the revalidation\n        fetchControllers.set(rf.key, rf.controller);\n      }\n    });\n\n    // Proxy navigation abort through to revalidation fetchers\n    let abortPendingFetchRevalidations = () =>\n      revalidatingFetchers.forEach((f) => abortFetcher(f.key));\n    if (pendingNavigationController) {\n      pendingNavigationController.signal.addEventListener(\n        \"abort\",\n        abortPendingFetchRevalidations\n      );\n    }\n\n    let { results, loaderResults, fetcherResults } =\n      await callLoadersAndMaybeResolveData(\n        state.matches,\n        matches,\n        matchesToLoad,\n        revalidatingFetchers,\n        request\n      );\n\n    if (request.signal.aborted) {\n      return { shortCircuited: true };\n    }\n\n    // Clean up _after_ loaders have completed.  Don't clean up if we short\n    // circuited because fetchControllers would have been aborted and\n    // reassigned to new controllers for the next navigation\n    if (pendingNavigationController) {\n      pendingNavigationController.signal.removeEventListener(\n        \"abort\",\n        abortPendingFetchRevalidations\n      );\n    }\n    revalidatingFetchers.forEach((rf) => fetchControllers.delete(rf.key));\n\n    // If any loaders returned a redirect Response, start a new REPLACE navigation\n    let redirect = findRedirect(results);\n    if (redirect) {\n      if (redirect.idx >= matchesToLoad.length) {\n        // If this redirect came from a fetcher make sure we mark it in\n        // fetchRedirectIds so it doesn't get revalidated on the next set of\n        // loader executions\n        let fetcherKey =\n          revalidatingFetchers[redirect.idx - matchesToLoad.length].key;\n        fetchRedirectIds.add(fetcherKey);\n      }\n      await startRedirectNavigation(state, redirect.result, { replace });\n      return { shortCircuited: true };\n    }\n\n    // Process and commit output from loaders\n    let { loaderData, errors } = processLoaderData(\n      state,\n      matches,\n      matchesToLoad,\n      loaderResults,\n      pendingError,\n      revalidatingFetchers,\n      fetcherResults,\n      activeDeferreds\n    );\n\n    // Wire up subscribers to update loaderData as promises settle\n    activeDeferreds.forEach((deferredData, routeId) => {\n      deferredData.subscribe((aborted) => {\n        // Note: No need to updateState here since the TrackedPromise on\n        // loaderData is stable across resolve/reject\n        // Remove this instance if we were aborted or if promises have settled\n        if (aborted || deferredData.done) {\n          activeDeferreds.delete(routeId);\n        }\n      });\n    });\n\n    let updatedFetchers = markFetchRedirectsDone();\n    let didAbortFetchLoads = abortStaleFetchLoads(pendingNavigationLoadId);\n    let shouldUpdateFetchers =\n      updatedFetchers || didAbortFetchLoads || revalidatingFetchers.length > 0;\n\n    return {\n      loaderData,\n      errors,\n      ...(shouldUpdateFetchers ? { fetchers: new Map(state.fetchers) } : {}),\n    };\n  }\n\n  function getFetcher<TData = any>(key: string): Fetcher<TData> {\n    return state.fetchers.get(key) || IDLE_FETCHER;\n  }\n\n  // Trigger a fetcher load/submit for the given fetcher key\n  function fetch(\n    key: string,\n    routeId: string,\n    href: string | null,\n    opts?: RouterFetchOptions\n  ) {\n    if (isServer) {\n      throw new Error(\n        \"router.fetch() was called during the server render, but it shouldn't be. \" +\n          \"You are likely calling a useFetcher() method in the body of your component. \" +\n          \"Try moving it to a useEffect or a callback.\"\n      );\n    }\n\n    if (fetchControllers.has(key)) abortFetcher(key);\n\n    let routesToUse = inFlightDataRoutes || dataRoutes;\n    let normalizedPath = normalizeTo(\n      state.location,\n      state.matches,\n      basename,\n      future.v7_prependBasename,\n      href,\n      routeId,\n      opts?.relative\n    );\n    let matches = matchRoutes(routesToUse, normalizedPath, basename);\n\n    if (!matches) {\n      setFetcherError(\n        key,\n        routeId,\n        getInternalRouterError(404, { pathname: normalizedPath })\n      );\n      return;\n    }\n\n    let { path, submission, error } = normalizeNavigateOptions(\n      future.v7_normalizeFormMethod,\n      true,\n      normalizedPath,\n      opts\n    );\n\n    if (error) {\n      setFetcherError(key, routeId, error);\n      return;\n    }\n\n    let match = getTargetMatch(matches, path);\n\n    pendingPreventScrollReset = (opts && opts.preventScrollReset) === true;\n\n    if (submission && isMutationMethod(submission.formMethod)) {\n      handleFetcherAction(key, routeId, path, match, matches, submission);\n      return;\n    }\n\n    // Store off the match so we can call it's shouldRevalidate on subsequent\n    // revalidations\n    fetchLoadMatches.set(key, { routeId, path });\n    handleFetcherLoader(key, routeId, path, match, matches, submission);\n  }\n\n  // Call the action for the matched fetcher.submit(), and then handle redirects,\n  // errors, and revalidation\n  async function handleFetcherAction(\n    key: string,\n    routeId: string,\n    path: string,\n    match: AgnosticDataRouteMatch,\n    requestMatches: AgnosticDataRouteMatch[],\n    submission: Submission\n  ) {\n    interruptActiveLoads();\n    fetchLoadMatches.delete(key);\n\n    if (!match.route.action && !match.route.lazy) {\n      let error = getInternalRouterError(405, {\n        method: submission.formMethod,\n        pathname: path,\n        routeId: routeId,\n      });\n      setFetcherError(key, routeId, error);\n      return;\n    }\n\n    // Put this fetcher into it's submitting state\n    let existingFetcher = state.fetchers.get(key);\n    let fetcher = getSubmittingFetcher(submission, existingFetcher);\n    state.fetchers.set(key, fetcher);\n    updateState({ fetchers: new Map(state.fetchers) });\n\n    // Call the action for the fetcher\n    let abortController = new AbortController();\n    let fetchRequest = createClientSideRequest(\n      init.history,\n      path,\n      abortController.signal,\n      submission\n    );\n    fetchControllers.set(key, abortController);\n\n    let originatingLoadId = incrementingLoadId;\n    let actionResult = await callLoaderOrAction(\n      \"action\",\n      fetchRequest,\n      match,\n      requestMatches,\n      manifest,\n      mapRouteProperties,\n      basename\n    );\n\n    if (fetchRequest.signal.aborted) {\n      // We can delete this so long as we weren't aborted by ou our own fetcher\n      // re-submit which would have put _new_ controller is in fetchControllers\n      if (fetchControllers.get(key) === abortController) {\n        fetchControllers.delete(key);\n      }\n      return;\n    }\n\n    if (isRedirectResult(actionResult)) {\n      fetchControllers.delete(key);\n      if (pendingNavigationLoadId > originatingLoadId) {\n        // A new navigation was kicked off after our action started, so that\n        // should take precedence over this redirect navigation.  We already\n        // set isRevalidationRequired so all loaders for the new route should\n        // fire unless opted out via shouldRevalidate\n        let doneFetcher = getDoneFetcher(undefined);\n        state.fetchers.set(key, doneFetcher);\n        updateState({ fetchers: new Map(state.fetchers) });\n        return;\n      } else {\n        fetchRedirectIds.add(key);\n        let loadingFetcher = getLoadingFetcher(submission);\n        state.fetchers.set(key, loadingFetcher);\n        updateState({ fetchers: new Map(state.fetchers) });\n\n        return startRedirectNavigation(state, actionResult, {\n          fetcherSubmission: submission,\n        });\n      }\n    }\n\n    // Process any non-redirect errors thrown\n    if (isErrorResult(actionResult)) {\n      setFetcherError(key, routeId, actionResult.error);\n      return;\n    }\n\n    if (isDeferredResult(actionResult)) {\n      throw getInternalRouterError(400, { type: \"defer-action\" });\n    }\n\n    // Start the data load for current matches, or the next location if we're\n    // in the middle of a navigation\n    let nextLocation = state.navigation.location || state.location;\n    let revalidationRequest = createClientSideRequest(\n      init.history,\n      nextLocation,\n      abortController.signal\n    );\n    let routesToUse = inFlightDataRoutes || dataRoutes;\n    let matches =\n      state.navigation.state !== \"idle\"\n        ? matchRoutes(routesToUse, state.navigation.location, basename)\n        : state.matches;\n\n    invariant(matches, \"Didn't find any matches after fetcher action\");\n\n    let loadId = ++incrementingLoadId;\n    fetchReloadIds.set(key, loadId);\n\n    let loadFetcher = getLoadingFetcher(submission, actionResult.data);\n    state.fetchers.set(key, loadFetcher);\n\n    let [matchesToLoad, revalidatingFetchers] = getMatchesToLoad(\n      init.history,\n      state,\n      matches,\n      submission,\n      nextLocation,\n      isRevalidationRequired,\n      cancelledDeferredRoutes,\n      cancelledFetcherLoads,\n      fetchLoadMatches,\n      fetchRedirectIds,\n      routesToUse,\n      basename,\n      { [match.route.id]: actionResult.data },\n      undefined // No need to send through errors since we short circuit above\n    );\n\n    // Put all revalidating fetchers into the loading state, except for the\n    // current fetcher which we want to keep in it's current loading state which\n    // contains it's action submission info + action data\n    revalidatingFetchers\n      .filter((rf) => rf.key !== key)\n      .forEach((rf) => {\n        let staleKey = rf.key;\n        let existingFetcher = state.fetchers.get(staleKey);\n        let revalidatingFetcher = getLoadingFetcher(\n          undefined,\n          existingFetcher ? existingFetcher.data : undefined\n        );\n        state.fetchers.set(staleKey, revalidatingFetcher);\n        if (fetchControllers.has(staleKey)) {\n          abortFetcher(staleKey);\n        }\n        if (rf.controller) {\n          fetchControllers.set(staleKey, rf.controller);\n        }\n      });\n\n    updateState({ fetchers: new Map(state.fetchers) });\n\n    let abortPendingFetchRevalidations = () =>\n      revalidatingFetchers.forEach((rf) => abortFetcher(rf.key));\n\n    abortController.signal.addEventListener(\n      \"abort\",\n      abortPendingFetchRevalidations\n    );\n\n    let { results, loaderResults, fetcherResults } =\n      await callLoadersAndMaybeResolveData(\n        state.matches,\n        matches,\n        matchesToLoad,\n        revalidatingFetchers,\n        revalidationRequest\n      );\n\n    if (abortController.signal.aborted) {\n      return;\n    }\n\n    abortController.signal.removeEventListener(\n      \"abort\",\n      abortPendingFetchRevalidations\n    );\n\n    fetchReloadIds.delete(key);\n    fetchControllers.delete(key);\n    revalidatingFetchers.forEach((r) => fetchControllers.delete(r.key));\n\n    let redirect = findRedirect(results);\n    if (redirect) {\n      if (redirect.idx >= matchesToLoad.length) {\n        // If this redirect came from a fetcher make sure we mark it in\n        // fetchRedirectIds so it doesn't get revalidated on the next set of\n        // loader executions\n        let fetcherKey =\n          revalidatingFetchers[redirect.idx - matchesToLoad.length].key;\n        fetchRedirectIds.add(fetcherKey);\n      }\n      return startRedirectNavigation(state, redirect.result);\n    }\n\n    // Process and commit output from loaders\n    let { loaderData, errors } = processLoaderData(\n      state,\n      state.matches,\n      matchesToLoad,\n      loaderResults,\n      undefined,\n      revalidatingFetchers,\n      fetcherResults,\n      activeDeferreds\n    );\n\n    // Since we let revalidations complete even if the submitting fetcher was\n    // deleted, only put it back to idle if it hasn't been deleted\n    if (state.fetchers.has(key)) {\n      let doneFetcher = getDoneFetcher(actionResult.data);\n      state.fetchers.set(key, doneFetcher);\n    }\n\n    let didAbortFetchLoads = abortStaleFetchLoads(loadId);\n\n    // If we are currently in a navigation loading state and this fetcher is\n    // more recent than the navigation, we want the newer data so abort the\n    // navigation and complete it with the fetcher data\n    if (\n      state.navigation.state === \"loading\" &&\n      loadId > pendingNavigationLoadId\n    ) {\n      invariant(pendingAction, \"Expected pending action\");\n      pendingNavigationController && pendingNavigationController.abort();\n\n      completeNavigation(state.navigation.location, {\n        matches,\n        loaderData,\n        errors,\n        fetchers: new Map(state.fetchers),\n      });\n    } else {\n      // otherwise just update with the fetcher data, preserving any existing\n      // loaderData for loaders that did not need to reload.  We have to\n      // manually merge here since we aren't going through completeNavigation\n      updateState({\n        errors,\n        loaderData: mergeLoaderData(\n          state.loaderData,\n          loaderData,\n          matches,\n          errors\n        ),\n        ...(didAbortFetchLoads || revalidatingFetchers.length > 0\n          ? { fetchers: new Map(state.fetchers) }\n          : {}),\n      });\n      isRevalidationRequired = false;\n    }\n  }\n\n  // Call the matched loader for fetcher.load(), handling redirects, errors, etc.\n  async function handleFetcherLoader(\n    key: string,\n    routeId: string,\n    path: string,\n    match: AgnosticDataRouteMatch,\n    matches: AgnosticDataRouteMatch[],\n    submission?: Submission\n  ) {\n    let existingFetcher = state.fetchers.get(key);\n    // Put this fetcher into it's loading state\n    let loadingFetcher = getLoadingFetcher(\n      submission,\n      existingFetcher ? existingFetcher.data : undefined\n    );\n    state.fetchers.set(key, loadingFetcher);\n    updateState({ fetchers: new Map(state.fetchers) });\n\n    // Call the loader for this fetcher route match\n    let abortController = new AbortController();\n    let fetchRequest = createClientSideRequest(\n      init.history,\n      path,\n      abortController.signal\n    );\n    fetchControllers.set(key, abortController);\n\n    let originatingLoadId = incrementingLoadId;\n    let result: DataResult = await callLoaderOrAction(\n      \"loader\",\n      fetchRequest,\n      match,\n      matches,\n      manifest,\n      mapRouteProperties,\n      basename\n    );\n\n    // Deferred isn't supported for fetcher loads, await everything and treat it\n    // as a normal load.  resolveDeferredData will return undefined if this\n    // fetcher gets aborted, so we just leave result untouched and short circuit\n    // below if that happens\n    if (isDeferredResult(result)) {\n      result =\n        (await resolveDeferredData(result, fetchRequest.signal, true)) ||\n        result;\n    }\n\n    // We can delete this so long as we weren't aborted by our our own fetcher\n    // re-load which would have put _new_ controller is in fetchControllers\n    if (fetchControllers.get(key) === abortController) {\n      fetchControllers.delete(key);\n    }\n\n    if (fetchRequest.signal.aborted) {\n      return;\n    }\n\n    // If the loader threw a redirect Response, start a new REPLACE navigation\n    if (isRedirectResult(result)) {\n      if (pendingNavigationLoadId > originatingLoadId) {\n        // A new navigation was kicked off after our loader started, so that\n        // should take precedence over this redirect navigation\n        let doneFetcher = getDoneFetcher(undefined);\n        state.fetchers.set(key, doneFetcher);\n        updateState({ fetchers: new Map(state.fetchers) });\n        return;\n      } else {\n        fetchRedirectIds.add(key);\n        await startRedirectNavigation(state, result);\n        return;\n      }\n    }\n\n    // Process any non-redirect errors thrown\n    if (isErrorResult(result)) {\n      let boundaryMatch = findNearestBoundary(state.matches, routeId);\n      state.fetchers.delete(key);\n      // TODO: In remix, this would reset to IDLE_NAVIGATION if it was a catch -\n      // do we need to behave any differently with our non-redirect errors?\n      // What if it was a non-redirect Response?\n      updateState({\n        fetchers: new Map(state.fetchers),\n        errors: {\n          [boundaryMatch.route.id]: result.error,\n        },\n      });\n      return;\n    }\n\n    invariant(!isDeferredResult(result), \"Unhandled fetcher deferred data\");\n\n    // Put the fetcher back into an idle state\n    let doneFetcher = getDoneFetcher(result.data);\n    state.fetchers.set(key, doneFetcher);\n    updateState({ fetchers: new Map(state.fetchers) });\n  }\n\n  /**\n   * Utility function to handle redirects returned from an action or loader.\n   * Normally, a redirect \"replaces\" the navigation that triggered it.  So, for\n   * example:\n   *\n   *  - user is on /a\n   *  - user clicks a link to /b\n   *  - loader for /b redirects to /c\n   *\n   * In a non-JS app the browser would track the in-flight navigation to /b and\n   * then replace it with /c when it encountered the redirect response.  In\n   * the end it would only ever update the URL bar with /c.\n   *\n   * In client-side routing using pushState/replaceState, we aim to emulate\n   * this behavior and we also do not update history until the end of the\n   * navigation (including processed redirects).  This means that we never\n   * actually touch history until we've processed redirects, so we just use\n   * the history action from the original navigation (PUSH or REPLACE).\n   */\n  async function startRedirectNavigation(\n    state: RouterState,\n    redirect: RedirectResult,\n    {\n      submission,\n      fetcherSubmission,\n      replace,\n    }: {\n      submission?: Submission;\n      fetcherSubmission?: Submission;\n      replace?: boolean;\n    } = {}\n  ) {\n    if (redirect.revalidate) {\n      isRevalidationRequired = true;\n    }\n\n    let redirectLocation = createLocation(state.location, redirect.location, {\n      _isRedirect: true,\n    });\n    invariant(\n      redirectLocation,\n      \"Expected a location on the redirect navigation\"\n    );\n\n    if (isBrowser) {\n      let isDocumentReload = false;\n\n      if (redirect.reloadDocument) {\n        // Hard reload if the response contained X-Remix-Reload-Document\n        isDocumentReload = true;\n      } else if (ABSOLUTE_URL_REGEX.test(redirect.location)) {\n        const url = init.history.createURL(redirect.location);\n        isDocumentReload =\n          // Hard reload if it's an absolute URL to a new origin\n          url.origin !== routerWindow.location.origin ||\n          // Hard reload if it's an absolute URL that does not match our basename\n          stripBasename(url.pathname, basename) == null;\n      }\n\n      if (isDocumentReload) {\n        if (replace) {\n          routerWindow.location.replace(redirect.location);\n        } else {\n          routerWindow.location.assign(redirect.location);\n        }\n        return;\n      }\n    }\n\n    // There's no need to abort on redirects, since we don't detect the\n    // redirect until the action/loaders have settled\n    pendingNavigationController = null;\n\n    let redirectHistoryAction =\n      replace === true ? HistoryAction.Replace : HistoryAction.Push;\n\n    // Use the incoming submission if provided, fallback on the active one in\n    // state.navigation\n    let { formMethod, formAction, formEncType } = state.navigation;\n    if (\n      !submission &&\n      !fetcherSubmission &&\n      formMethod &&\n      formAction &&\n      formEncType\n    ) {\n      submission = getSubmissionFromNavigation(state.navigation);\n    }\n\n    // If this was a 307/308 submission we want to preserve the HTTP method and\n    // re-submit the GET/POST/PUT/PATCH/DELETE as a submission navigation to the\n    // redirected location\n    let activeSubmission = submission || fetcherSubmission;\n    if (\n      redirectPreserveMethodStatusCodes.has(redirect.status) &&\n      activeSubmission &&\n      isMutationMethod(activeSubmission.formMethod)\n    ) {\n      await startNavigation(redirectHistoryAction, redirectLocation, {\n        submission: {\n          ...activeSubmission,\n          formAction: redirect.location,\n        },\n        // Preserve this flag across redirects\n        preventScrollReset: pendingPreventScrollReset,\n      });\n    } else {\n      // If we have a navigation submission, we will preserve it through the\n      // redirect navigation\n      let overrideNavigation = getLoadingNavigation(\n        redirectLocation,\n        submission\n      );\n      await startNavigation(redirectHistoryAction, redirectLocation, {\n        overrideNavigation,\n        // Send fetcher submissions through for shouldRevalidate\n        fetcherSubmission,\n        // Preserve this flag across redirects\n        preventScrollReset: pendingPreventScrollReset,\n      });\n    }\n  }\n\n  async function callLoadersAndMaybeResolveData(\n    currentMatches: AgnosticDataRouteMatch[],\n    matches: AgnosticDataRouteMatch[],\n    matchesToLoad: AgnosticDataRouteMatch[],\n    fetchersToLoad: RevalidatingFetcher[],\n    request: Request\n  ) {\n    // Call all navigation loaders and revalidating fetcher loaders in parallel,\n    // then slice off the results into separate arrays so we can handle them\n    // accordingly\n    let results = await Promise.all([\n      ...matchesToLoad.map((match) =>\n        callLoaderOrAction(\n          \"loader\",\n          request,\n          match,\n          matches,\n          manifest,\n          mapRouteProperties,\n          basename\n        )\n      ),\n      ...fetchersToLoad.map((f) => {\n        if (f.matches && f.match && f.controller) {\n          return callLoaderOrAction(\n            \"loader\",\n            createClientSideRequest(init.history, f.path, f.controller.signal),\n            f.match,\n            f.matches,\n            manifest,\n            mapRouteProperties,\n            basename\n          );\n        } else {\n          let error: ErrorResult = {\n            type: ResultType.error,\n            error: getInternalRouterError(404, { pathname: f.path }),\n          };\n          return error;\n        }\n      }),\n    ]);\n    let loaderResults = results.slice(0, matchesToLoad.length);\n    let fetcherResults = results.slice(matchesToLoad.length);\n\n    await Promise.all([\n      resolveDeferredResults(\n        currentMatches,\n        matchesToLoad,\n        loaderResults,\n        loaderResults.map(() => request.signal),\n        false,\n        state.loaderData\n      ),\n      resolveDeferredResults(\n        currentMatches,\n        fetchersToLoad.map((f) => f.match),\n        fetcherResults,\n        fetchersToLoad.map((f) => (f.controller ? f.controller.signal : null)),\n        true\n      ),\n    ]);\n\n    return { results, loaderResults, fetcherResults };\n  }\n\n  function interruptActiveLoads() {\n    // Every interruption triggers a revalidation\n    isRevalidationRequired = true;\n\n    // Cancel pending route-level deferreds and mark cancelled routes for\n    // revalidation\n    cancelledDeferredRoutes.push(...cancelActiveDeferreds());\n\n    // Abort in-flight fetcher loads\n    fetchLoadMatches.forEach((_, key) => {\n      if (fetchControllers.has(key)) {\n        cancelledFetcherLoads.push(key);\n        abortFetcher(key);\n      }\n    });\n  }\n\n  function setFetcherError(key: string, routeId: string, error: any) {\n    let boundaryMatch = findNearestBoundary(state.matches, routeId);\n    deleteFetcher(key);\n    updateState({\n      errors: {\n        [boundaryMatch.route.id]: error,\n      },\n      fetchers: new Map(state.fetchers),\n    });\n  }\n\n  function deleteFetcher(key: string): void {\n    let fetcher = state.fetchers.get(key);\n    // Don't abort the controller if this is a deletion of a fetcher.submit()\n    // in it's loading phase since - we don't want to abort the corresponding\n    // revalidation and want them to complete and land\n    if (\n      fetchControllers.has(key) &&\n      !(fetcher && fetcher.state === \"loading\" && fetchReloadIds.has(key))\n    ) {\n      abortFetcher(key);\n    }\n    fetchLoadMatches.delete(key);\n    fetchReloadIds.delete(key);\n    fetchRedirectIds.delete(key);\n    state.fetchers.delete(key);\n  }\n\n  function abortFetcher(key: string) {\n    let controller = fetchControllers.get(key);\n    invariant(controller, `Expected fetch controller: ${key}`);\n    controller.abort();\n    fetchControllers.delete(key);\n  }\n\n  function markFetchersDone(keys: string[]) {\n    for (let key of keys) {\n      let fetcher = getFetcher(key);\n      let doneFetcher = getDoneFetcher(fetcher.data);\n      state.fetchers.set(key, doneFetcher);\n    }\n  }\n\n  function markFetchRedirectsDone(): boolean {\n    let doneKeys = [];\n    let updatedFetchers = false;\n    for (let key of fetchRedirectIds) {\n      let fetcher = state.fetchers.get(key);\n      invariant(fetcher, `Expected fetcher: ${key}`);\n      if (fetcher.state === \"loading\") {\n        fetchRedirectIds.delete(key);\n        doneKeys.push(key);\n        updatedFetchers = true;\n      }\n    }\n    markFetchersDone(doneKeys);\n    return updatedFetchers;\n  }\n\n  function abortStaleFetchLoads(landedId: number): boolean {\n    let yeetedKeys = [];\n    for (let [key, id] of fetchReloadIds) {\n      if (id < landedId) {\n        let fetcher = state.fetchers.get(key);\n        invariant(fetcher, `Expected fetcher: ${key}`);\n        if (fetcher.state === \"loading\") {\n          abortFetcher(key);\n          fetchReloadIds.delete(key);\n          yeetedKeys.push(key);\n        }\n      }\n    }\n    markFetchersDone(yeetedKeys);\n    return yeetedKeys.length > 0;\n  }\n\n  function getBlocker(key: string, fn: BlockerFunction) {\n    let blocker: Blocker = state.blockers.get(key) || IDLE_BLOCKER;\n\n    if (blockerFunctions.get(key) !== fn) {\n      blockerFunctions.set(key, fn);\n    }\n\n    return blocker;\n  }\n\n  function deleteBlocker(key: string) {\n    state.blockers.delete(key);\n    blockerFunctions.delete(key);\n  }\n\n  // Utility function to update blockers, ensuring valid state transitions\n  function updateBlocker(key: string, newBlocker: Blocker) {\n    let blocker = state.blockers.get(key) || IDLE_BLOCKER;\n\n    // Poor mans state machine :)\n    // https://mermaid.live/edit#pako:eNqVkc9OwzAMxl8l8nnjAYrEtDIOHEBIgwvKJTReGy3_lDpIqO27k6awMG0XcrLlnz87nwdonESogKXXBuE79rq75XZO3-yHds0RJVuv70YrPlUrCEe2HfrORS3rubqZfuhtpg5C9wk5tZ4VKcRUq88q9Z8RS0-48cE1iHJkL0ugbHuFLus9L6spZy8nX9MP2CNdomVaposqu3fGayT8T8-jJQwhepo_UtpgBQaDEUom04dZhAN1aJBDlUKJBxE1ceB2Smj0Mln-IBW5AFU2dwUiktt_2Qaq2dBfaKdEup85UV7Yd-dKjlnkabl2Pvr0DTkTreM\n    invariant(\n      (blocker.state === \"unblocked\" && newBlocker.state === \"blocked\") ||\n        (blocker.state === \"blocked\" && newBlocker.state === \"blocked\") ||\n        (blocker.state === \"blocked\" && newBlocker.state === \"proceeding\") ||\n        (blocker.state === \"blocked\" && newBlocker.state === \"unblocked\") ||\n        (blocker.state === \"proceeding\" && newBlocker.state === \"unblocked\"),\n      `Invalid blocker state transition: ${blocker.state} -> ${newBlocker.state}`\n    );\n\n    let blockers = new Map(state.blockers);\n    blockers.set(key, newBlocker);\n    updateState({ blockers });\n  }\n\n  function shouldBlockNavigation({\n    currentLocation,\n    nextLocation,\n    historyAction,\n  }: {\n    currentLocation: Location;\n    nextLocation: Location;\n    historyAction: HistoryAction;\n  }): string | undefined {\n    if (blockerFunctions.size === 0) {\n      return;\n    }\n\n    // We ony support a single active blocker at the moment since we don't have\n    // any compelling use cases for multi-blocker yet\n    if (blockerFunctions.size > 1) {\n      warning(false, \"A router only supports one blocker at a time\");\n    }\n\n    let entries = Array.from(blockerFunctions.entries());\n    let [blockerKey, blockerFunction] = entries[entries.length - 1];\n    let blocker = state.blockers.get(blockerKey);\n\n    if (blocker && blocker.state === \"proceeding\") {\n      // If the blocker is currently proceeding, we don't need to re-check\n      // it and can let this navigation continue\n      return;\n    }\n\n    // At this point, we know we're unblocked/blocked so we need to check the\n    // user-provided blocker function\n    if (blockerFunction({ currentLocation, nextLocation, historyAction })) {\n      return blockerKey;\n    }\n  }\n\n  function cancelActiveDeferreds(\n    predicate?: (routeId: string) => boolean\n  ): string[] {\n    let cancelledRouteIds: string[] = [];\n    activeDeferreds.forEach((dfd, routeId) => {\n      if (!predicate || predicate(routeId)) {\n        // Cancel the deferred - but do not remove from activeDeferreds here -\n        // we rely on the subscribers to do that so our tests can assert proper\n        // cleanup via _internalActiveDeferreds\n        dfd.cancel();\n        cancelledRouteIds.push(routeId);\n        activeDeferreds.delete(routeId);\n      }\n    });\n    return cancelledRouteIds;\n  }\n\n  // Opt in to capturing and reporting scroll positions during navigations,\n  // used by the <ScrollRestoration> component\n  function enableScrollRestoration(\n    positions: Record<string, number>,\n    getPosition: GetScrollPositionFunction,\n    getKey?: GetScrollRestorationKeyFunction\n  ) {\n    savedScrollPositions = positions;\n    getScrollPosition = getPosition;\n    getScrollRestorationKey = getKey || null;\n\n    // Perform initial hydration scroll restoration, since we miss the boat on\n    // the initial updateState() because we've not yet rendered <ScrollRestoration/>\n    // and therefore have no savedScrollPositions available\n    if (!initialScrollRestored && state.navigation === IDLE_NAVIGATION) {\n      initialScrollRestored = true;\n      let y = getSavedScrollPosition(state.location, state.matches);\n      if (y != null) {\n        updateState({ restoreScrollPosition: y });\n      }\n    }\n\n    return () => {\n      savedScrollPositions = null;\n      getScrollPosition = null;\n      getScrollRestorationKey = null;\n    };\n  }\n\n  function getScrollKey(location: Location, matches: AgnosticDataRouteMatch[]) {\n    if (getScrollRestorationKey) {\n      let key = getScrollRestorationKey(\n        location,\n        matches.map((m) => convertRouteMatchToUiMatch(m, state.loaderData))\n      );\n      return key || location.key;\n    }\n    return location.key;\n  }\n\n  function saveScrollPosition(\n    location: Location,\n    matches: AgnosticDataRouteMatch[]\n  ): void {\n    if (savedScrollPositions && getScrollPosition) {\n      let key = getScrollKey(location, matches);\n      savedScrollPositions[key] = getScrollPosition();\n    }\n  }\n\n  function getSavedScrollPosition(\n    location: Location,\n    matches: AgnosticDataRouteMatch[]\n  ): number | null {\n    if (savedScrollPositions) {\n      let key = getScrollKey(location, matches);\n      let y = savedScrollPositions[key];\n      if (typeof y === \"number\") {\n        return y;\n      }\n    }\n    return null;\n  }\n\n  function _internalSetRoutes(newRoutes: AgnosticDataRouteObject[]) {\n    manifest = {};\n    inFlightDataRoutes = convertRoutesToDataRoutes(\n      newRoutes,\n      mapRouteProperties,\n      undefined,\n      manifest\n    );\n  }\n\n  router = {\n    get basename() {\n      return basename;\n    },\n    get state() {\n      return state;\n    },\n    get routes() {\n      return dataRoutes;\n    },\n    initialize,\n    subscribe,\n    enableScrollRestoration,\n    navigate,\n    fetch,\n    revalidate,\n    // Passthrough to history-aware createHref used by useHref so we get proper\n    // hash-aware URLs in DOM paths\n    createHref: (to: To) => init.history.createHref(to),\n    encodeLocation: (to: To) => init.history.encodeLocation(to),\n    getFetcher,\n    deleteFetcher,\n    dispose,\n    getBlocker,\n    deleteBlocker,\n    _internalFetchControllers: fetchControllers,\n    _internalActiveDeferreds: activeDeferreds,\n    // TODO: Remove setRoutes, it's temporary to avoid dealing with\n    // updating the tree while validating the update algorithm.\n    _internalSetRoutes,\n  };\n\n  return router;\n}\n//#endregion\n\n////////////////////////////////////////////////////////////////////////////////\n//#region createStaticHandler\n////////////////////////////////////////////////////////////////////////////////\n\nexport const UNSAFE_DEFERRED_SYMBOL = Symbol(\"deferred\");\n\nexport interface CreateStaticHandlerOptions {\n  basename?: string;\n  /**\n   * @deprecated Use `mapRouteProperties` instead\n   */\n  detectErrorBoundary?: DetectErrorBoundaryFunction;\n  mapRouteProperties?: MapRoutePropertiesFunction;\n}\n\nexport function createStaticHandler(\n  routes: AgnosticRouteObject[],\n  opts?: CreateStaticHandlerOptions\n): StaticHandler {\n  invariant(\n    routes.length > 0,\n    \"You must provide a non-empty routes array to createStaticHandler\"\n  );\n\n  let manifest: RouteManifest = {};\n  let basename = (opts ? opts.basename : null) || \"/\";\n  let mapRouteProperties: MapRoutePropertiesFunction;\n  if (opts?.mapRouteProperties) {\n    mapRouteProperties = opts.mapRouteProperties;\n  } else if (opts?.detectErrorBoundary) {\n    // If they are still using the deprecated version, wrap it with the new API\n    let detectErrorBoundary = opts.detectErrorBoundary;\n    mapRouteProperties = (route) => ({\n      hasErrorBoundary: detectErrorBoundary(route),\n    });\n  } else {\n    mapRouteProperties = defaultMapRouteProperties;\n  }\n\n  let dataRoutes = convertRoutesToDataRoutes(\n    routes,\n    mapRouteProperties,\n    undefined,\n    manifest\n  );\n\n  /**\n   * The query() method is intended for document requests, in which we want to\n   * call an optional action and potentially multiple loaders for all nested\n   * routes.  It returns a StaticHandlerContext object, which is very similar\n   * to the router state (location, loaderData, actionData, errors, etc.) and\n   * also adds SSR-specific information such as the statusCode and headers\n   * from action/loaders Responses.\n   *\n   * It _should_ never throw and should report all errors through the\n   * returned context.errors object, properly associating errors to their error\n   * boundary.  Additionally, it tracks _deepestRenderedBoundaryId which can be\n   * used to emulate React error boundaries during SSr by performing a second\n   * pass only down to the boundaryId.\n   *\n   * The one exception where we do not return a StaticHandlerContext is when a\n   * redirect response is returned or thrown from any action/loader.  We\n   * propagate that out and return the raw Response so the HTTP server can\n   * return it directly.\n   */\n  async function query(\n    request: Request,\n    { requestContext }: { requestContext?: unknown } = {}\n  ): Promise<StaticHandlerContext | Response> {\n    let url = new URL(request.url);\n    let method = request.method;\n    let location = createLocation(\"\", createPath(url), null, \"default\");\n    let matches = matchRoutes(dataRoutes, location, basename);\n\n    // SSR supports HEAD requests while SPA doesn't\n    if (!isValidMethod(method) && method !== \"HEAD\") {\n      let error = getInternalRouterError(405, { method });\n      let { matches: methodNotAllowedMatches, route } =\n        getShortCircuitMatches(dataRoutes);\n      return {\n        basename,\n        location,\n        matches: methodNotAllowedMatches,\n        loaderData: {},\n        actionData: null,\n        errors: {\n          [route.id]: error,\n        },\n        statusCode: error.status,\n        loaderHeaders: {},\n        actionHeaders: {},\n        activeDeferreds: null,\n      };\n    } else if (!matches) {\n      let error = getInternalRouterError(404, { pathname: location.pathname });\n      let { matches: notFoundMatches, route } =\n        getShortCircuitMatches(dataRoutes);\n      return {\n        basename,\n        location,\n        matches: notFoundMatches,\n        loaderData: {},\n        actionData: null,\n        errors: {\n          [route.id]: error,\n        },\n        statusCode: error.status,\n        loaderHeaders: {},\n        actionHeaders: {},\n        activeDeferreds: null,\n      };\n    }\n\n    let result = await queryImpl(request, location, matches, requestContext);\n    if (isResponse(result)) {\n      return result;\n    }\n\n    // When returning StaticHandlerContext, we patch back in the location here\n    // since we need it for React Context.  But this helps keep our submit and\n    // loadRouteData operating on a Request instead of a Location\n    return { location, basename, ...result };\n  }\n\n  /**\n   * The queryRoute() method is intended for targeted route requests, either\n   * for fetch ?_data requests or resource route requests.  In this case, we\n   * are only ever calling a single action or loader, and we are returning the\n   * returned value directly.  In most cases, this will be a Response returned\n   * from the action/loader, but it may be a primitive or other value as well -\n   * and in such cases the calling context should handle that accordingly.\n   *\n   * We do respect the throw/return differentiation, so if an action/loader\n   * throws, then this method will throw the value.  This is important so we\n   * can do proper boundary identification in Remix where a thrown Response\n   * must go to the Catch Boundary but a returned Response is happy-path.\n   *\n   * One thing to note is that any Router-initiated Errors that make sense\n   * to associate with a status code will be thrown as an ErrorResponse\n   * instance which include the raw Error, such that the calling context can\n   * serialize the error as they see fit while including the proper response\n   * code.  Examples here are 404 and 405 errors that occur prior to reaching\n   * any user-defined loaders.\n   */\n  async function queryRoute(\n    request: Request,\n    {\n      routeId,\n      requestContext,\n    }: { requestContext?: unknown; routeId?: string } = {}\n  ): Promise<any> {\n    let url = new URL(request.url);\n    let method = request.method;\n    let location = createLocation(\"\", createPath(url), null, \"default\");\n    let matches = matchRoutes(dataRoutes, location, basename);\n\n    // SSR supports HEAD requests while SPA doesn't\n    if (!isValidMethod(method) && method !== \"HEAD\" && method !== \"OPTIONS\") {\n      throw getInternalRouterError(405, { method });\n    } else if (!matches) {\n      throw getInternalRouterError(404, { pathname: location.pathname });\n    }\n\n    let match = routeId\n      ? matches.find((m) => m.route.id === routeId)\n      : getTargetMatch(matches, location);\n\n    if (routeId && !match) {\n      throw getInternalRouterError(403, {\n        pathname: location.pathname,\n        routeId,\n      });\n    } else if (!match) {\n      // This should never hit I don't think?\n      throw getInternalRouterError(404, { pathname: location.pathname });\n    }\n\n    let result = await queryImpl(\n      request,\n      location,\n      matches,\n      requestContext,\n      match\n    );\n    if (isResponse(result)) {\n      return result;\n    }\n\n    let error = result.errors ? Object.values(result.errors)[0] : undefined;\n    if (error !== undefined) {\n      // If we got back result.errors, that means the loader/action threw\n      // _something_ that wasn't a Response, but it's not guaranteed/required\n      // to be an `instanceof Error` either, so we have to use throw here to\n      // preserve the \"error\" state outside of queryImpl.\n      throw error;\n    }\n\n    // Pick off the right state value to return\n    if (result.actionData) {\n      return Object.values(result.actionData)[0];\n    }\n\n    if (result.loaderData) {\n      let data = Object.values(result.loaderData)[0];\n      if (result.activeDeferreds?.[match.route.id]) {\n        data[UNSAFE_DEFERRED_SYMBOL] = result.activeDeferreds[match.route.id];\n      }\n      return data;\n    }\n\n    return undefined;\n  }\n\n  async function queryImpl(\n    request: Request,\n    location: Location,\n    matches: AgnosticDataRouteMatch[],\n    requestContext: unknown,\n    routeMatch?: AgnosticDataRouteMatch\n  ): Promise<Omit<StaticHandlerContext, \"location\" | \"basename\"> | Response> {\n    invariant(\n      request.signal,\n      \"query()/queryRoute() requests must contain an AbortController signal\"\n    );\n\n    try {\n      if (isMutationMethod(request.method.toLowerCase())) {\n        let result = await submit(\n          request,\n          matches,\n          routeMatch || getTargetMatch(matches, location),\n          requestContext,\n          routeMatch != null\n        );\n        return result;\n      }\n\n      let result = await loadRouteData(\n        request,\n        matches,\n        requestContext,\n        routeMatch\n      );\n      return isResponse(result)\n        ? result\n        : {\n            ...result,\n            actionData: null,\n            actionHeaders: {},\n          };\n    } catch (e) {\n      // If the user threw/returned a Response in callLoaderOrAction, we throw\n      // it to bail out and then return or throw here based on whether the user\n      // returned or threw\n      if (isQueryRouteResponse(e)) {\n        if (e.type === ResultType.error) {\n          throw e.response;\n        }\n        return e.response;\n      }\n      // Redirects are always returned since they don't propagate to catch\n      // boundaries\n      if (isRedirectResponse(e)) {\n        return e;\n      }\n      throw e;\n    }\n  }\n\n  async function submit(\n    request: Request,\n    matches: AgnosticDataRouteMatch[],\n    actionMatch: AgnosticDataRouteMatch,\n    requestContext: unknown,\n    isRouteRequest: boolean\n  ): Promise<Omit<StaticHandlerContext, \"location\" | \"basename\"> | Response> {\n    let result: DataResult;\n\n    if (!actionMatch.route.action && !actionMatch.route.lazy) {\n      let error = getInternalRouterError(405, {\n        method: request.method,\n        pathname: new URL(request.url).pathname,\n        routeId: actionMatch.route.id,\n      });\n      if (isRouteRequest) {\n        throw error;\n      }\n      result = {\n        type: ResultType.error,\n        error,\n      };\n    } else {\n      result = await callLoaderOrAction(\n        \"action\",\n        request,\n        actionMatch,\n        matches,\n        manifest,\n        mapRouteProperties,\n        basename,\n        { isStaticRequest: true, isRouteRequest, requestContext }\n      );\n\n      if (request.signal.aborted) {\n        let method = isRouteRequest ? \"queryRoute\" : \"query\";\n        throw new Error(\n          `${method}() call aborted: ${request.method} ${request.url}`\n        );\n      }\n    }\n\n    if (isRedirectResult(result)) {\n      // Uhhhh - this should never happen, we should always throw these from\n      // callLoaderOrAction, but the type narrowing here keeps TS happy and we\n      // can get back on the \"throw all redirect responses\" train here should\n      // this ever happen :/\n      throw new Response(null, {\n        status: result.status,\n        headers: {\n          Location: result.location,\n        },\n      });\n    }\n\n    if (isDeferredResult(result)) {\n      let error = getInternalRouterError(400, { type: \"defer-action\" });\n      if (isRouteRequest) {\n        throw error;\n      }\n      result = {\n        type: ResultType.error,\n        error,\n      };\n    }\n\n    if (isRouteRequest) {\n      // Note: This should only be non-Response values if we get here, since\n      // isRouteRequest should throw any Response received in callLoaderOrAction\n      if (isErrorResult(result)) {\n        throw result.error;\n      }\n\n      return {\n        matches: [actionMatch],\n        loaderData: {},\n        actionData: { [actionMatch.route.id]: result.data },\n        errors: null,\n        // Note: statusCode + headers are unused here since queryRoute will\n        // return the raw Response or value\n        statusCode: 200,\n        loaderHeaders: {},\n        actionHeaders: {},\n        activeDeferreds: null,\n      };\n    }\n\n    if (isErrorResult(result)) {\n      // Store off the pending error - we use it to determine which loaders\n      // to call and will commit it when we complete the navigation\n      let boundaryMatch = findNearestBoundary(matches, actionMatch.route.id);\n      let context = await loadRouteData(\n        request,\n        matches,\n        requestContext,\n        undefined,\n        {\n          [boundaryMatch.route.id]: result.error,\n        }\n      );\n\n      // action status codes take precedence over loader status codes\n      return {\n        ...context,\n        statusCode: isRouteErrorResponse(result.error)\n          ? result.error.status\n          : 500,\n        actionData: null,\n        actionHeaders: {\n          ...(result.headers ? { [actionMatch.route.id]: result.headers } : {}),\n        },\n      };\n    }\n\n    // Create a GET request for the loaders\n    let loaderRequest = new Request(request.url, {\n      headers: request.headers,\n      redirect: request.redirect,\n      signal: request.signal,\n    });\n    let context = await loadRouteData(loaderRequest, matches, requestContext);\n\n    return {\n      ...context,\n      // action status codes take precedence over loader status codes\n      ...(result.statusCode ? { statusCode: result.statusCode } : {}),\n      actionData: {\n        [actionMatch.route.id]: result.data,\n      },\n      actionHeaders: {\n        ...(result.headers ? { [actionMatch.route.id]: result.headers } : {}),\n      },\n    };\n  }\n\n  async function loadRouteData(\n    request: Request,\n    matches: AgnosticDataRouteMatch[],\n    requestContext: unknown,\n    routeMatch?: AgnosticDataRouteMatch,\n    pendingActionError?: RouteData\n  ): Promise<\n    | Omit<\n        StaticHandlerContext,\n        \"location\" | \"basename\" | \"actionData\" | \"actionHeaders\"\n      >\n    | Response\n  > {\n    let isRouteRequest = routeMatch != null;\n\n    // Short circuit if we have no loaders to run (queryRoute())\n    if (\n      isRouteRequest &&\n      !routeMatch?.route.loader &&\n      !routeMatch?.route.lazy\n    ) {\n      throw getInternalRouterError(400, {\n        method: request.method,\n        pathname: new URL(request.url).pathname,\n        routeId: routeMatch?.route.id,\n      });\n    }\n\n    let requestMatches = routeMatch\n      ? [routeMatch]\n      : getLoaderMatchesUntilBoundary(\n          matches,\n          Object.keys(pendingActionError || {})[0]\n        );\n    let matchesToLoad = requestMatches.filter(\n      (m) => m.route.loader || m.route.lazy\n    );\n\n    // Short circuit if we have no loaders to run (query())\n    if (matchesToLoad.length === 0) {\n      return {\n        matches,\n        // Add a null for all matched routes for proper revalidation on the client\n        loaderData: matches.reduce(\n          (acc, m) => Object.assign(acc, { [m.route.id]: null }),\n          {}\n        ),\n        errors: pendingActionError || null,\n        statusCode: 200,\n        loaderHeaders: {},\n        activeDeferreds: null,\n      };\n    }\n\n    let results = await Promise.all([\n      ...matchesToLoad.map((match) =>\n        callLoaderOrAction(\n          \"loader\",\n          request,\n          match,\n          matches,\n          manifest,\n          mapRouteProperties,\n          basename,\n          { isStaticRequest: true, isRouteRequest, requestContext }\n        )\n      ),\n    ]);\n\n    if (request.signal.aborted) {\n      let method = isRouteRequest ? \"queryRoute\" : \"query\";\n      throw new Error(\n        `${method}() call aborted: ${request.method} ${request.url}`\n      );\n    }\n\n    // Process and commit output from loaders\n    let activeDeferreds = new Map<string, DeferredData>();\n    let context = processRouteLoaderData(\n      matches,\n      matchesToLoad,\n      results,\n      pendingActionError,\n      activeDeferreds\n    );\n\n    // Add a null for any non-loader matches for proper revalidation on the client\n    let executedLoaders = new Set<string>(\n      matchesToLoad.map((match) => match.route.id)\n    );\n    matches.forEach((match) => {\n      if (!executedLoaders.has(match.route.id)) {\n        context.loaderData[match.route.id] = null;\n      }\n    });\n\n    return {\n      ...context,\n      matches,\n      activeDeferreds:\n        activeDeferreds.size > 0\n          ? Object.fromEntries(activeDeferreds.entries())\n          : null,\n    };\n  }\n\n  return {\n    dataRoutes,\n    query,\n    queryRoute,\n  };\n}\n\n//#endregion\n\n////////////////////////////////////////////////////////////////////////////////\n//#region Helpers\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * Given an existing StaticHandlerContext and an error thrown at render time,\n * provide an updated StaticHandlerContext suitable for a second SSR render\n */\nexport function getStaticContextFromError(\n  routes: AgnosticDataRouteObject[],\n  context: StaticHandlerContext,\n  error: any\n) {\n  let newContext: StaticHandlerContext = {\n    ...context,\n    statusCode: 500,\n    errors: {\n      [context._deepestRenderedBoundaryId || routes[0].id]: error,\n    },\n  };\n  return newContext;\n}\n\nfunction isSubmissionNavigation(\n  opts: RouterNavigateOptions\n): opts is SubmissionNavigateOptions {\n  return (\n    opts != null &&\n    ((\"formData\" in opts && opts.formData != null) ||\n      (\"body\" in opts && opts.body !== undefined))\n  );\n}\n\nfunction normalizeTo(\n  location: Path,\n  matches: AgnosticDataRouteMatch[],\n  basename: string,\n  prependBasename: boolean,\n  to: To | null,\n  fromRouteId?: string,\n  relative?: RelativeRoutingType\n) {\n  let contextualMatches: AgnosticDataRouteMatch[];\n  let activeRouteMatch: AgnosticDataRouteMatch | undefined;\n  if (fromRouteId != null && relative !== \"path\") {\n    // Grab matches up to the calling route so our route-relative logic is\n    // relative to the correct source route.  When using relative:path,\n    // fromRouteId is ignored since that is always relative to the current\n    // location path\n    contextualMatches = [];\n    for (let match of matches) {\n      contextualMatches.push(match);\n      if (match.route.id === fromRouteId) {\n        activeRouteMatch = match;\n        break;\n      }\n    }\n  } else {\n    contextualMatches = matches;\n    activeRouteMatch = matches[matches.length - 1];\n  }\n\n  // Resolve the relative path\n  let path = resolveTo(\n    to ? to : \".\",\n    getPathContributingMatches(contextualMatches).map((m) => m.pathnameBase),\n    stripBasename(location.pathname, basename) || location.pathname,\n    relative === \"path\"\n  );\n\n  // When `to` is not specified we inherit search/hash from the current\n  // location, unlike when to=\".\" and we just inherit the path.\n  // See https://github.com/remix-run/remix/issues/927\n  if (to == null) {\n    path.search = location.search;\n    path.hash = location.hash;\n  }\n\n  // Add an ?index param for matched index routes if we don't already have one\n  if (\n    (to == null || to === \"\" || to === \".\") &&\n    activeRouteMatch &&\n    activeRouteMatch.route.index &&\n    !hasNakedIndexQuery(path.search)\n  ) {\n    path.search = path.search\n      ? path.search.replace(/^\\?/, \"?index&\")\n      : \"?index\";\n  }\n\n  // If we're operating within a basename, prepend it to the pathname.  If\n  // this is a root navigation, then just use the raw basename which allows\n  // the basename to have full control over the presence of a trailing slash\n  // on root actions\n  if (prependBasename && basename !== \"/\") {\n    path.pathname =\n      path.pathname === \"/\" ? basename : joinPaths([basename, path.pathname]);\n  }\n\n  return createPath(path);\n}\n\n// Normalize navigation options by converting formMethod=GET formData objects to\n// URLSearchParams so they behave identically to links with query params\nfunction normalizeNavigateOptions(\n  normalizeFormMethod: boolean,\n  isFetcher: boolean,\n  path: string,\n  opts?: RouterNavigateOptions\n): {\n  path: string;\n  submission?: Submission;\n  error?: ErrorResponseImpl;\n} {\n  // Return location verbatim on non-submission navigations\n  if (!opts || !isSubmissionNavigation(opts)) {\n    return { path };\n  }\n\n  if (opts.formMethod && !isValidMethod(opts.formMethod)) {\n    return {\n      path,\n      error: getInternalRouterError(405, { method: opts.formMethod }),\n    };\n  }\n\n  let getInvalidBodyError = () => ({\n    path,\n    error: getInternalRouterError(400, { type: \"invalid-body\" }),\n  });\n\n  // Create a Submission on non-GET navigations\n  let rawFormMethod = opts.formMethod || \"get\";\n  let formMethod = normalizeFormMethod\n    ? (rawFormMethod.toUpperCase() as V7_FormMethod)\n    : (rawFormMethod.toLowerCase() as FormMethod);\n  let formAction = stripHashFromPath(path);\n\n  if (opts.body !== undefined) {\n    if (opts.formEncType === \"text/plain\") {\n      // text only support POST/PUT/PATCH/DELETE submissions\n      if (!isMutationMethod(formMethod)) {\n        return getInvalidBodyError();\n      }\n\n      let text =\n        typeof opts.body === \"string\"\n          ? opts.body\n          : opts.body instanceof FormData ||\n            opts.body instanceof URLSearchParams\n          ? // https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#plain-text-form-data\n            Array.from(opts.body.entries()).reduce(\n              (acc, [name, value]) => `${acc}${name}=${value}\\n`,\n              \"\"\n            )\n          : String(opts.body);\n\n      return {\n        path,\n        submission: {\n          formMethod,\n          formAction,\n          formEncType: opts.formEncType,\n          formData: undefined,\n          json: undefined,\n          text,\n        },\n      };\n    } else if (opts.formEncType === \"application/json\") {\n      // json only supports POST/PUT/PATCH/DELETE submissions\n      if (!isMutationMethod(formMethod)) {\n        return getInvalidBodyError();\n      }\n\n      try {\n        let json =\n          typeof opts.body === \"string\" ? JSON.parse(opts.body) : opts.body;\n\n        return {\n          path,\n          submission: {\n            formMethod,\n            formAction,\n            formEncType: opts.formEncType,\n            formData: undefined,\n            json,\n            text: undefined,\n          },\n        };\n      } catch (e) {\n        return getInvalidBodyError();\n      }\n    }\n  }\n\n  invariant(\n    typeof FormData === \"function\",\n    \"FormData is not available in this environment\"\n  );\n\n  let searchParams: URLSearchParams;\n  let formData: FormData;\n\n  if (opts.formData) {\n    searchParams = convertFormDataToSearchParams(opts.formData);\n    formData = opts.formData;\n  } else if (opts.body instanceof FormData) {\n    searchParams = convertFormDataToSearchParams(opts.body);\n    formData = opts.body;\n  } else if (opts.body instanceof URLSearchParams) {\n    searchParams = opts.body;\n    formData = convertSearchParamsToFormData(searchParams);\n  } else if (opts.body == null) {\n    searchParams = new URLSearchParams();\n    formData = new FormData();\n  } else {\n    try {\n      searchParams = new URLSearchParams(opts.body);\n      formData = convertSearchParamsToFormData(searchParams);\n    } catch (e) {\n      return getInvalidBodyError();\n    }\n  }\n\n  let submission: Submission = {\n    formMethod,\n    formAction,\n    formEncType:\n      (opts && opts.formEncType) || \"application/x-www-form-urlencoded\",\n    formData,\n    json: undefined,\n    text: undefined,\n  };\n\n  if (isMutationMethod(submission.formMethod)) {\n    return { path, submission };\n  }\n\n  // Flatten submission onto URLSearchParams for GET submissions\n  let parsedPath = parsePath(path);\n  // On GET navigation submissions we can drop the ?index param from the\n  // resulting location since all loaders will run.  But fetcher GET submissions\n  // only run a single loader so we need to preserve any incoming ?index params\n  if (isFetcher && parsedPath.search && hasNakedIndexQuery(parsedPath.search)) {\n    searchParams.append(\"index\", \"\");\n  }\n  parsedPath.search = `?${searchParams}`;\n\n  return { path: createPath(parsedPath), submission };\n}\n\n// Filter out all routes below any caught error as they aren't going to\n// render so we don't need to load them\nfunction getLoaderMatchesUntilBoundary(\n  matches: AgnosticDataRouteMatch[],\n  boundaryId?: string\n) {\n  let boundaryMatches = matches;\n  if (boundaryId) {\n    let index = matches.findIndex((m) => m.route.id === boundaryId);\n    if (index >= 0) {\n      boundaryMatches = matches.slice(0, index);\n    }\n  }\n  return boundaryMatches;\n}\n\nfunction getMatchesToLoad(\n  history: History,\n  state: RouterState,\n  matches: AgnosticDataRouteMatch[],\n  submission: Submission | undefined,\n  location: Location,\n  isRevalidationRequired: boolean,\n  cancelledDeferredRoutes: string[],\n  cancelledFetcherLoads: string[],\n  fetchLoadMatches: Map<string, FetchLoadMatch>,\n  fetchRedirectIds: Set<string>,\n  routesToUse: AgnosticDataRouteObject[],\n  basename: string | undefined,\n  pendingActionData?: RouteData,\n  pendingError?: RouteData\n): [AgnosticDataRouteMatch[], RevalidatingFetcher[]] {\n  let actionResult = pendingError\n    ? Object.values(pendingError)[0]\n    : pendingActionData\n    ? Object.values(pendingActionData)[0]\n    : undefined;\n\n  let currentUrl = history.createURL(state.location);\n  let nextUrl = history.createURL(location);\n\n  // Pick navigation matches that are net-new or qualify for revalidation\n  let boundaryId = pendingError ? Object.keys(pendingError)[0] : undefined;\n  let boundaryMatches = getLoaderMatchesUntilBoundary(matches, boundaryId);\n\n  let navigationMatches = boundaryMatches.filter((match, index) => {\n    if (match.route.lazy) {\n      // We haven't loaded this route yet so we don't know if it's got a loader!\n      return true;\n    }\n    if (match.route.loader == null) {\n      return false;\n    }\n\n    // Always call the loader on new route instances and pending defer cancellations\n    if (\n      isNewLoader(state.loaderData, state.matches[index], match) ||\n      cancelledDeferredRoutes.some((id) => id === match.route.id)\n    ) {\n      return true;\n    }\n\n    // This is the default implementation for when we revalidate.  If the route\n    // provides it's own implementation, then we give them full control but\n    // provide this value so they can leverage it if needed after they check\n    // their own specific use cases\n    let currentRouteMatch = state.matches[index];\n    let nextRouteMatch = match;\n\n    return shouldRevalidateLoader(match, {\n      currentUrl,\n      currentParams: currentRouteMatch.params,\n      nextUrl,\n      nextParams: nextRouteMatch.params,\n      ...submission,\n      actionResult,\n      defaultShouldRevalidate:\n        // Forced revalidation due to submission, useRevalidator, or X-Remix-Revalidate\n        isRevalidationRequired ||\n        // Clicked the same link, resubmitted a GET form\n        currentUrl.pathname + currentUrl.search ===\n          nextUrl.pathname + nextUrl.search ||\n        // Search params affect all loaders\n        currentUrl.search !== nextUrl.search ||\n        isNewRouteInstance(currentRouteMatch, nextRouteMatch),\n    });\n  });\n\n  // Pick fetcher.loads that need to be revalidated\n  let revalidatingFetchers: RevalidatingFetcher[] = [];\n  fetchLoadMatches.forEach((f, key) => {\n    // Don't revalidate if fetcher won't be present in the subsequent render\n    if (!matches.some((m) => m.route.id === f.routeId)) {\n      return;\n    }\n\n    let fetcherMatches = matchRoutes(routesToUse, f.path, basename);\n\n    // If the fetcher path no longer matches, push it in with null matches so\n    // we can trigger a 404 in callLoadersAndMaybeResolveData.  Note this is\n    // currently only a use-case for Remix HMR where the route tree can change\n    // at runtime and remove a route previously loaded via a fetcher\n    if (!fetcherMatches) {\n      revalidatingFetchers.push({\n        key,\n        routeId: f.routeId,\n        path: f.path,\n        matches: null,\n        match: null,\n        controller: null,\n      });\n      return;\n    }\n\n    // Revalidating fetchers are decoupled from the route matches since they\n    // load from a static href.  They revalidate based on explicit revalidation\n    // (submission, useRevalidator, or X-Remix-Revalidate)\n    let fetcher = state.fetchers.get(key);\n    let fetcherMatch = getTargetMatch(fetcherMatches, f.path);\n\n    let shouldRevalidate = false;\n    if (fetchRedirectIds.has(key)) {\n      // Never trigger a revalidation of an actively redirecting fetcher\n      shouldRevalidate = false;\n    } else if (cancelledFetcherLoads.includes(key)) {\n      // Always revalidate if the fetcher was cancelled\n      shouldRevalidate = true;\n    } else if (\n      fetcher &&\n      fetcher.state !== \"idle\" &&\n      fetcher.data === undefined\n    ) {\n      // If the fetcher hasn't ever completed loading yet, then this isn't a\n      // revalidation, it would just be a brand new load if an explicit\n      // revalidation is required\n      shouldRevalidate = isRevalidationRequired;\n    } else {\n      // Otherwise fall back on any user-defined shouldRevalidate, defaulting\n      // to explicit revalidations only\n      shouldRevalidate = shouldRevalidateLoader(fetcherMatch, {\n        currentUrl,\n        currentParams: state.matches[state.matches.length - 1].params,\n        nextUrl,\n        nextParams: matches[matches.length - 1].params,\n        ...submission,\n        actionResult,\n        defaultShouldRevalidate: isRevalidationRequired,\n      });\n    }\n\n    if (shouldRevalidate) {\n      revalidatingFetchers.push({\n        key,\n        routeId: f.routeId,\n        path: f.path,\n        matches: fetcherMatches,\n        match: fetcherMatch,\n        controller: new AbortController(),\n      });\n    }\n  });\n\n  return [navigationMatches, revalidatingFetchers];\n}\n\nfunction isNewLoader(\n  currentLoaderData: RouteData,\n  currentMatch: AgnosticDataRouteMatch,\n  match: AgnosticDataRouteMatch\n) {\n  let isNew =\n    // [a] -> [a, b]\n    !currentMatch ||\n    // [a, b] -> [a, c]\n    match.route.id !== currentMatch.route.id;\n\n  // Handle the case that we don't have data for a re-used route, potentially\n  // from a prior error or from a cancelled pending deferred\n  let isMissingData = currentLoaderData[match.route.id] === undefined;\n\n  // Always load if this is a net-new route or we don't yet have data\n  return isNew || isMissingData;\n}\n\nfunction isNewRouteInstance(\n  currentMatch: AgnosticDataRouteMatch,\n  match: AgnosticDataRouteMatch\n) {\n  let currentPath = currentMatch.route.path;\n  return (\n    // param change for this match, /users/123 -> /users/456\n    currentMatch.pathname !== match.pathname ||\n    // splat param changed, which is not present in match.path\n    // e.g. /files/images/avatar.jpg -> files/finances.xls\n    (currentPath != null &&\n      currentPath.endsWith(\"*\") &&\n      currentMatch.params[\"*\"] !== match.params[\"*\"])\n  );\n}\n\nfunction shouldRevalidateLoader(\n  loaderMatch: AgnosticDataRouteMatch,\n  arg: ShouldRevalidateFunctionArgs\n) {\n  if (loaderMatch.route.shouldRevalidate) {\n    let routeChoice = loaderMatch.route.shouldRevalidate(arg);\n    if (typeof routeChoice === \"boolean\") {\n      return routeChoice;\n    }\n  }\n\n  return arg.defaultShouldRevalidate;\n}\n\n/**\n * Execute route.lazy() methods to lazily load route modules (loader, action,\n * shouldRevalidate) and update the routeManifest in place which shares objects\n * with dataRoutes so those get updated as well.\n */\nasync function loadLazyRouteModule(\n  route: AgnosticDataRouteObject,\n  mapRouteProperties: MapRoutePropertiesFunction,\n  manifest: RouteManifest\n) {\n  if (!route.lazy) {\n    return;\n  }\n\n  let lazyRoute = await route.lazy();\n\n  // If the lazy route function was executed and removed by another parallel\n  // call then we can return - first lazy() to finish wins because the return\n  // value of lazy is expected to be static\n  if (!route.lazy) {\n    return;\n  }\n\n  let routeToUpdate = manifest[route.id];\n  invariant(routeToUpdate, \"No route found in manifest\");\n\n  // Update the route in place.  This should be safe because there's no way\n  // we could yet be sitting on this route as we can't get there without\n  // resolving lazy() first.\n  //\n  // This is different than the HMR \"update\" use-case where we may actively be\n  // on the route being updated.  The main concern boils down to \"does this\n  // mutation affect any ongoing navigations or any current state.matches\n  // values?\".  If not, it should be safe to update in place.\n  let routeUpdates: Record<string, any> = {};\n  for (let lazyRouteProperty in lazyRoute) {\n    let staticRouteValue =\n      routeToUpdate[lazyRouteProperty as keyof typeof routeToUpdate];\n\n    let isPropertyStaticallyDefined =\n      staticRouteValue !== undefined &&\n      // This property isn't static since it should always be updated based\n      // on the route updates\n      lazyRouteProperty !== \"hasErrorBoundary\";\n\n    warning(\n      !isPropertyStaticallyDefined,\n      `Route \"${routeToUpdate.id}\" has a static property \"${lazyRouteProperty}\" ` +\n        `defined but its lazy function is also returning a value for this property. ` +\n        `The lazy route property \"${lazyRouteProperty}\" will be ignored.`\n    );\n\n    if (\n      !isPropertyStaticallyDefined &&\n      !immutableRouteKeys.has(lazyRouteProperty as ImmutableRouteKey)\n    ) {\n      routeUpdates[lazyRouteProperty] =\n        lazyRoute[lazyRouteProperty as keyof typeof lazyRoute];\n    }\n  }\n\n  // Mutate the route with the provided updates.  Do this first so we pass\n  // the updated version to mapRouteProperties\n  Object.assign(routeToUpdate, routeUpdates);\n\n  // Mutate the `hasErrorBoundary` property on the route based on the route\n  // updates and remove the `lazy` function so we don't resolve the lazy\n  // route again.\n  Object.assign(routeToUpdate, {\n    // To keep things framework agnostic, we use the provided\n    // `mapRouteProperties` (or wrapped `detectErrorBoundary`) function to\n    // set the framework-aware properties (`element`/`hasErrorBoundary`) since\n    // the logic will differ between frameworks.\n    ...mapRouteProperties(routeToUpdate),\n    lazy: undefined,\n  });\n}\n\nasync function callLoaderOrAction(\n  type: \"loader\" | \"action\",\n  request: Request,\n  match: AgnosticDataRouteMatch,\n  matches: AgnosticDataRouteMatch[],\n  manifest: RouteManifest,\n  mapRouteProperties: MapRoutePropertiesFunction,\n  basename: string,\n  opts: {\n    isStaticRequest?: boolean;\n    isRouteRequest?: boolean;\n    requestContext?: unknown;\n  } = {}\n): Promise<DataResult> {\n  let resultType;\n  let result;\n  let onReject: (() => void) | undefined;\n\n  let runHandler = (handler: ActionFunction | LoaderFunction) => {\n    // Setup a promise we can race against so that abort signals short circuit\n    let reject: () => void;\n    let abortPromise = new Promise((_, r) => (reject = r));\n    onReject = () => reject();\n    request.signal.addEventListener(\"abort\", onReject);\n    return Promise.race([\n      handler({\n        request,\n        params: match.params,\n        context: opts.requestContext,\n      }),\n      abortPromise,\n    ]);\n  };\n\n  try {\n    let handler = match.route[type];\n\n    if (match.route.lazy) {\n      if (handler) {\n        // Run statically defined handler in parallel with lazy()\n        let handlerError;\n        let values = await Promise.all([\n          // If the handler throws, don't let it immediately bubble out,\n          // since we need to let the lazy() execution finish so we know if this\n          // route has a boundary that can handle the error\n          runHandler(handler).catch((e) => {\n            handlerError = e;\n          }),\n          loadLazyRouteModule(match.route, mapRouteProperties, manifest),\n        ]);\n        if (handlerError) {\n          throw handlerError;\n        }\n        result = values[0];\n      } else {\n        // Load lazy route module, then run any returned handler\n        await loadLazyRouteModule(match.route, mapRouteProperties, manifest);\n\n        handler = match.route[type];\n        if (handler) {\n          // Handler still run even if we got interrupted to maintain consistency\n          // with un-abortable behavior of handler execution on non-lazy or\n          // previously-lazy-loaded routes\n          result = await runHandler(handler);\n        } else if (type === \"action\") {\n          let url = new URL(request.url);\n          let pathname = url.pathname + url.search;\n          throw getInternalRouterError(405, {\n            method: request.method,\n            pathname,\n            routeId: match.route.id,\n          });\n        } else {\n          // lazy() route has no loader to run.  Short circuit here so we don't\n          // hit the invariant below that errors on returning undefined.\n          return { type: ResultType.data, data: undefined };\n        }\n      }\n    } else if (!handler) {\n      let url = new URL(request.url);\n      let pathname = url.pathname + url.search;\n      throw getInternalRouterError(404, {\n        pathname,\n      });\n    } else {\n      result = await runHandler(handler);\n    }\n\n    invariant(\n      result !== undefined,\n      `You defined ${type === \"action\" ? \"an action\" : \"a loader\"} for route ` +\n        `\"${match.route.id}\" but didn't return anything from your \\`${type}\\` ` +\n        `function. Please return a value or \\`null\\`.`\n    );\n  } catch (e) {\n    resultType = ResultType.error;\n    result = e;\n  } finally {\n    if (onReject) {\n      request.signal.removeEventListener(\"abort\", onReject);\n    }\n  }\n\n  if (isResponse(result)) {\n    let status = result.status;\n\n    // Process redirects\n    if (redirectStatusCodes.has(status)) {\n      let location = result.headers.get(\"Location\");\n      invariant(\n        location,\n        \"Redirects returned/thrown from loaders/actions must have a Location header\"\n      );\n\n      // Support relative routing in internal redirects\n      if (!ABSOLUTE_URL_REGEX.test(location)) {\n        location = normalizeTo(\n          new URL(request.url),\n          matches.slice(0, matches.indexOf(match) + 1),\n          basename,\n          true,\n          location\n        );\n      } else if (!opts.isStaticRequest) {\n        // Strip off the protocol+origin for same-origin + same-basename absolute\n        // redirects. If this is a static request, we can let it go back to the\n        // browser as-is\n        let currentUrl = new URL(request.url);\n        let url = location.startsWith(\"//\")\n          ? new URL(currentUrl.protocol + location)\n          : new URL(location);\n        let isSameBasename = stripBasename(url.pathname, basename) != null;\n        if (url.origin === currentUrl.origin && isSameBasename) {\n          location = url.pathname + url.search + url.hash;\n        }\n      }\n\n      // Don't process redirects in the router during static requests requests.\n      // Instead, throw the Response and let the server handle it with an HTTP\n      // redirect.  We also update the Location header in place in this flow so\n      // basename and relative routing is taken into account\n      if (opts.isStaticRequest) {\n        result.headers.set(\"Location\", location);\n        throw result;\n      }\n\n      return {\n        type: ResultType.redirect,\n        status,\n        location,\n        revalidate: result.headers.get(\"X-Remix-Revalidate\") !== null,\n        reloadDocument: result.headers.get(\"X-Remix-Reload-Document\") !== null,\n      };\n    }\n\n    // For SSR single-route requests, we want to hand Responses back directly\n    // without unwrapping.  We do this with the QueryRouteResponse wrapper\n    // interface so we can know whether it was returned or thrown\n    if (opts.isRouteRequest) {\n      let queryRouteResponse: QueryRouteResponse = {\n        type:\n          resultType === ResultType.error ? ResultType.error : ResultType.data,\n        response: result,\n      };\n      throw queryRouteResponse;\n    }\n\n    let data: any;\n    let contentType = result.headers.get(\"Content-Type\");\n    // Check between word boundaries instead of startsWith() due to the last\n    // paragraph of https://httpwg.org/specs/rfc9110.html#field.content-type\n    if (contentType && /\\bapplication\\/json\\b/.test(contentType)) {\n      data = await result.json();\n    } else {\n      data = await result.text();\n    }\n\n    if (resultType === ResultType.error) {\n      return {\n        type: resultType,\n        error: new ErrorResponseImpl(status, result.statusText, data),\n        headers: result.headers,\n      };\n    }\n\n    return {\n      type: ResultType.data,\n      data,\n      statusCode: result.status,\n      headers: result.headers,\n    };\n  }\n\n  if (resultType === ResultType.error) {\n    return { type: resultType, error: result };\n  }\n\n  if (isDeferredData(result)) {\n    return {\n      type: ResultType.deferred,\n      deferredData: result,\n      statusCode: result.init?.status,\n      headers: result.init?.headers && new Headers(result.init.headers),\n    };\n  }\n\n  return { type: ResultType.data, data: result };\n}\n\n// Utility method for creating the Request instances for loaders/actions during\n// client-side navigations and fetches.  During SSR we will always have a\n// Request instance from the static handler (query/queryRoute)\nfunction createClientSideRequest(\n  history: History,\n  location: string | Location,\n  signal: AbortSignal,\n  submission?: Submission\n): Request {\n  let url = history.createURL(stripHashFromPath(location)).toString();\n  let init: RequestInit = { signal };\n\n  if (submission && isMutationMethod(submission.formMethod)) {\n    let { formMethod, formEncType } = submission;\n    // Didn't think we needed this but it turns out unlike other methods, patch\n    // won't be properly normalized to uppercase and results in a 405 error.\n    // See: https://fetch.spec.whatwg.org/#concept-method\n    init.method = formMethod.toUpperCase();\n\n    if (formEncType === \"application/json\") {\n      init.headers = new Headers({ \"Content-Type\": formEncType });\n      init.body = JSON.stringify(submission.json);\n    } else if (formEncType === \"text/plain\") {\n      // Content-Type is inferred (https://fetch.spec.whatwg.org/#dom-request)\n      init.body = submission.text;\n    } else if (\n      formEncType === \"application/x-www-form-urlencoded\" &&\n      submission.formData\n    ) {\n      // Content-Type is inferred (https://fetch.spec.whatwg.org/#dom-request)\n      init.body = convertFormDataToSearchParams(submission.formData);\n    } else {\n      // Content-Type is inferred (https://fetch.spec.whatwg.org/#dom-request)\n      init.body = submission.formData;\n    }\n  }\n\n  return new Request(url, init);\n}\n\nfunction convertFormDataToSearchParams(formData: FormData): URLSearchParams {\n  let searchParams = new URLSearchParams();\n\n  for (let [key, value] of formData.entries()) {\n    // https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#converting-an-entry-list-to-a-list-of-name-value-pairs\n    searchParams.append(key, typeof value === \"string\" ? value : value.name);\n  }\n\n  return searchParams;\n}\n\nfunction convertSearchParamsToFormData(\n  searchParams: URLSearchParams\n): FormData {\n  let formData = new FormData();\n  for (let [key, value] of searchParams.entries()) {\n    formData.append(key, value);\n  }\n  return formData;\n}\n\nfunction processRouteLoaderData(\n  matches: AgnosticDataRouteMatch[],\n  matchesToLoad: AgnosticDataRouteMatch[],\n  results: DataResult[],\n  pendingError: RouteData | undefined,\n  activeDeferreds: Map<string, DeferredData>\n): {\n  loaderData: RouterState[\"loaderData\"];\n  errors: RouterState[\"errors\"] | null;\n  statusCode: number;\n  loaderHeaders: Record<string, Headers>;\n} {\n  // Fill in loaderData/errors from our loaders\n  let loaderData: RouterState[\"loaderData\"] = {};\n  let errors: RouterState[\"errors\"] | null = null;\n  let statusCode: number | undefined;\n  let foundError = false;\n  let loaderHeaders: Record<string, Headers> = {};\n\n  // Process loader results into state.loaderData/state.errors\n  results.forEach((result, index) => {\n    let id = matchesToLoad[index].route.id;\n    invariant(\n      !isRedirectResult(result),\n      \"Cannot handle redirect results in processLoaderData\"\n    );\n    if (isErrorResult(result)) {\n      // Look upwards from the matched route for the closest ancestor\n      // error boundary, defaulting to the root match\n      let boundaryMatch = findNearestBoundary(matches, id);\n      let error = result.error;\n      // If we have a pending action error, we report it at the highest-route\n      // that throws a loader error, and then clear it out to indicate that\n      // it was consumed\n      if (pendingError) {\n        error = Object.values(pendingError)[0];\n        pendingError = undefined;\n      }\n\n      errors = errors || {};\n\n      // Prefer higher error values if lower errors bubble to the same boundary\n      if (errors[boundaryMatch.route.id] == null) {\n        errors[boundaryMatch.route.id] = error;\n      }\n\n      // Clear our any prior loaderData for the throwing route\n      loaderData[id] = undefined;\n\n      // Once we find our first (highest) error, we set the status code and\n      // prevent deeper status codes from overriding\n      if (!foundError) {\n        foundError = true;\n        statusCode = isRouteErrorResponse(result.error)\n          ? result.error.status\n          : 500;\n      }\n      if (result.headers) {\n        loaderHeaders[id] = result.headers;\n      }\n    } else {\n      if (isDeferredResult(result)) {\n        activeDeferreds.set(id, result.deferredData);\n        loaderData[id] = result.deferredData.data;\n      } else {\n        loaderData[id] = result.data;\n      }\n\n      // Error status codes always override success status codes, but if all\n      // loaders are successful we take the deepest status code.\n      if (\n        result.statusCode != null &&\n        result.statusCode !== 200 &&\n        !foundError\n      ) {\n        statusCode = result.statusCode;\n      }\n      if (result.headers) {\n        loaderHeaders[id] = result.headers;\n      }\n    }\n  });\n\n  // If we didn't consume the pending action error (i.e., all loaders\n  // resolved), then consume it here.  Also clear out any loaderData for the\n  // throwing route\n  if (pendingError) {\n    errors = pendingError;\n    loaderData[Object.keys(pendingError)[0]] = undefined;\n  }\n\n  return {\n    loaderData,\n    errors,\n    statusCode: statusCode || 200,\n    loaderHeaders,\n  };\n}\n\nfunction processLoaderData(\n  state: RouterState,\n  matches: AgnosticDataRouteMatch[],\n  matchesToLoad: AgnosticDataRouteMatch[],\n  results: DataResult[],\n  pendingError: RouteData | undefined,\n  revalidatingFetchers: RevalidatingFetcher[],\n  fetcherResults: DataResult[],\n  activeDeferreds: Map<string, DeferredData>\n): {\n  loaderData: RouterState[\"loaderData\"];\n  errors?: RouterState[\"errors\"];\n} {\n  let { loaderData, errors } = processRouteLoaderData(\n    matches,\n    matchesToLoad,\n    results,\n    pendingError,\n    activeDeferreds\n  );\n\n  // Process results from our revalidating fetchers\n  for (let index = 0; index < revalidatingFetchers.length; index++) {\n    let { key, match, controller } = revalidatingFetchers[index];\n    invariant(\n      fetcherResults !== undefined && fetcherResults[index] !== undefined,\n      \"Did not find corresponding fetcher result\"\n    );\n    let result = fetcherResults[index];\n\n    // Process fetcher non-redirect errors\n    if (controller && controller.signal.aborted) {\n      // Nothing to do for aborted fetchers\n      continue;\n    } else if (isErrorResult(result)) {\n      let boundaryMatch = findNearestBoundary(state.matches, match?.route.id);\n      if (!(errors && errors[boundaryMatch.route.id])) {\n        errors = {\n          ...errors,\n          [boundaryMatch.route.id]: result.error,\n        };\n      }\n      state.fetchers.delete(key);\n    } else if (isRedirectResult(result)) {\n      // Should never get here, redirects should get processed above, but we\n      // keep this to type narrow to a success result in the else\n      invariant(false, \"Unhandled fetcher revalidation redirect\");\n    } else if (isDeferredResult(result)) {\n      // Should never get here, deferred data should be awaited for fetchers\n      // in resolveDeferredResults\n      invariant(false, \"Unhandled fetcher deferred data\");\n    } else {\n      let doneFetcher = getDoneFetcher(result.data);\n      state.fetchers.set(key, doneFetcher);\n    }\n  }\n\n  return { loaderData, errors };\n}\n\nfunction mergeLoaderData(\n  loaderData: RouteData,\n  newLoaderData: RouteData,\n  matches: AgnosticDataRouteMatch[],\n  errors: RouteData | null | undefined\n): RouteData {\n  let mergedLoaderData = { ...newLoaderData };\n  for (let match of matches) {\n    let id = match.route.id;\n    if (newLoaderData.hasOwnProperty(id)) {\n      if (newLoaderData[id] !== undefined) {\n        mergedLoaderData[id] = newLoaderData[id];\n      } else {\n        // No-op - this is so we ignore existing data if we have a key in the\n        // incoming object with an undefined value, which is how we unset a prior\n        // loaderData if we encounter a loader error\n      }\n    } else if (loaderData[id] !== undefined && match.route.loader) {\n      // Preserve existing keys not included in newLoaderData and where a loader\n      // wasn't removed by HMR\n      mergedLoaderData[id] = loaderData[id];\n    }\n\n    if (errors && errors.hasOwnProperty(id)) {\n      // Don't keep any loader data below the boundary\n      break;\n    }\n  }\n  return mergedLoaderData;\n}\n\n// Find the nearest error boundary, looking upwards from the leaf route (or the\n// route specified by routeId) for the closest ancestor error boundary,\n// defaulting to the root match\nfunction findNearestBoundary(\n  matches: AgnosticDataRouteMatch[],\n  routeId?: string\n): AgnosticDataRouteMatch {\n  let eligibleMatches = routeId\n    ? matches.slice(0, matches.findIndex((m) => m.route.id === routeId) + 1)\n    : [...matches];\n  return (\n    eligibleMatches.reverse().find((m) => m.route.hasErrorBoundary === true) ||\n    matches[0]\n  );\n}\n\nfunction getShortCircuitMatches(routes: AgnosticDataRouteObject[]): {\n  matches: AgnosticDataRouteMatch[];\n  route: AgnosticDataRouteObject;\n} {\n  // Prefer a root layout route if present, otherwise shim in a route object\n  let route = routes.find((r) => r.index || !r.path || r.path === \"/\") || {\n    id: `__shim-error-route__`,\n  };\n\n  return {\n    matches: [\n      {\n        params: {},\n        pathname: \"\",\n        pathnameBase: \"\",\n        route,\n      },\n    ],\n    route,\n  };\n}\n\nfunction getInternalRouterError(\n  status: number,\n  {\n    pathname,\n    routeId,\n    method,\n    type,\n  }: {\n    pathname?: string;\n    routeId?: string;\n    method?: string;\n    type?: \"defer-action\" | \"invalid-body\";\n  } = {}\n) {\n  let statusText = \"Unknown Server Error\";\n  let errorMessage = \"Unknown @remix-run/router error\";\n\n  if (status === 400) {\n    statusText = \"Bad Request\";\n    if (method && pathname && routeId) {\n      errorMessage =\n        `You made a ${method} request to \"${pathname}\" but ` +\n        `did not provide a \\`loader\\` for route \"${routeId}\", ` +\n        `so there is no way to handle the request.`;\n    } else if (type === \"defer-action\") {\n      errorMessage = \"defer() is not supported in actions\";\n    } else if (type === \"invalid-body\") {\n      errorMessage = \"Unable to encode submission body\";\n    }\n  } else if (status === 403) {\n    statusText = \"Forbidden\";\n    errorMessage = `Route \"${routeId}\" does not match URL \"${pathname}\"`;\n  } else if (status === 404) {\n    statusText = \"Not Found\";\n    errorMessage = `No route matches URL \"${pathname}\"`;\n  } else if (status === 405) {\n    statusText = \"Method Not Allowed\";\n    if (method && pathname && routeId) {\n      errorMessage =\n        `You made a ${method.toUpperCase()} request to \"${pathname}\" but ` +\n        `did not provide an \\`action\\` for route \"${routeId}\", ` +\n        `so there is no way to handle the request.`;\n    } else if (method) {\n      errorMessage = `Invalid request method \"${method.toUpperCase()}\"`;\n    }\n  }\n\n  return new ErrorResponseImpl(\n    status || 500,\n    statusText,\n    new Error(errorMessage),\n    true\n  );\n}\n\n// Find any returned redirect errors, starting from the lowest match\nfunction findRedirect(\n  results: DataResult[]\n): { result: RedirectResult; idx: number } | undefined {\n  for (let i = results.length - 1; i >= 0; i--) {\n    let result = results[i];\n    if (isRedirectResult(result)) {\n      return { result, idx: i };\n    }\n  }\n}\n\nfunction stripHashFromPath(path: To) {\n  let parsedPath = typeof path === \"string\" ? parsePath(path) : path;\n  return createPath({ ...parsedPath, hash: \"\" });\n}\n\nfunction isHashChangeOnly(a: Location, b: Location): boolean {\n  if (a.pathname !== b.pathname || a.search !== b.search) {\n    return false;\n  }\n\n  if (a.hash === \"\") {\n    // /page -> /page#hash\n    return b.hash !== \"\";\n  } else if (a.hash === b.hash) {\n    // /page#hash -> /page#hash\n    return true;\n  } else if (b.hash !== \"\") {\n    // /page#hash -> /page#other\n    return true;\n  }\n\n  // If the hash is removed the browser will re-perform a request to the server\n  // /page#hash -> /page\n  return false;\n}\n\nfunction isDeferredResult(result: DataResult): result is DeferredResult {\n  return result.type === ResultType.deferred;\n}\n\nfunction isErrorResult(result: DataResult): result is ErrorResult {\n  return result.type === ResultType.error;\n}\n\nfunction isRedirectResult(result?: DataResult): result is RedirectResult {\n  return (result && result.type) === ResultType.redirect;\n}\n\nexport function isDeferredData(value: any): value is DeferredData {\n  let deferred: DeferredData = value;\n  return (\n    deferred &&\n    typeof deferred === \"object\" &&\n    typeof deferred.data === \"object\" &&\n    typeof deferred.subscribe === \"function\" &&\n    typeof deferred.cancel === \"function\" &&\n    typeof deferred.resolveData === \"function\"\n  );\n}\n\nfunction isResponse(value: any): value is Response {\n  return (\n    value != null &&\n    typeof value.status === \"number\" &&\n    typeof value.statusText === \"string\" &&\n    typeof value.headers === \"object\" &&\n    typeof value.body !== \"undefined\"\n  );\n}\n\nfunction isRedirectResponse(result: any): result is Response {\n  if (!isResponse(result)) {\n    return false;\n  }\n\n  let status = result.status;\n  let location = result.headers.get(\"Location\");\n  return status >= 300 && status <= 399 && location != null;\n}\n\nfunction isQueryRouteResponse(obj: any): obj is QueryRouteResponse {\n  return (\n    obj &&\n    isResponse(obj.response) &&\n    (obj.type === ResultType.data || obj.type === ResultType.error)\n  );\n}\n\nfunction isValidMethod(method: string): method is FormMethod | V7_FormMethod {\n  return validRequestMethods.has(method.toLowerCase() as FormMethod);\n}\n\nfunction isMutationMethod(\n  method: string\n): method is MutationFormMethod | V7_MutationFormMethod {\n  return validMutationMethods.has(method.toLowerCase() as MutationFormMethod);\n}\n\nasync function resolveDeferredResults(\n  currentMatches: AgnosticDataRouteMatch[],\n  matchesToLoad: (AgnosticDataRouteMatch | null)[],\n  results: DataResult[],\n  signals: (AbortSignal | null)[],\n  isFetcher: boolean,\n  currentLoaderData?: RouteData\n) {\n  for (let index = 0; index < results.length; index++) {\n    let result = results[index];\n    let match = matchesToLoad[index];\n    // If we don't have a match, then we can have a deferred result to do\n    // anything with.  This is for revalidating fetchers where the route was\n    // removed during HMR\n    if (!match) {\n      continue;\n    }\n\n    let currentMatch = currentMatches.find(\n      (m) => m.route.id === match!.route.id\n    );\n    let isRevalidatingLoader =\n      currentMatch != null &&\n      !isNewRouteInstance(currentMatch, match) &&\n      (currentLoaderData && currentLoaderData[match.route.id]) !== undefined;\n\n    if (isDeferredResult(result) && (isFetcher || isRevalidatingLoader)) {\n      // Note: we do not have to touch activeDeferreds here since we race them\n      // against the signal in resolveDeferredData and they'll get aborted\n      // there if needed\n      let signal = signals[index];\n      invariant(\n        signal,\n        \"Expected an AbortSignal for revalidating fetcher deferred result\"\n      );\n      await resolveDeferredData(result, signal, isFetcher).then((result) => {\n        if (result) {\n          results[index] = result || results[index];\n        }\n      });\n    }\n  }\n}\n\nasync function resolveDeferredData(\n  result: DeferredResult,\n  signal: AbortSignal,\n  unwrap = false\n): Promise<SuccessResult | ErrorResult | undefined> {\n  let aborted = await result.deferredData.resolveData(signal);\n  if (aborted) {\n    return;\n  }\n\n  if (unwrap) {\n    try {\n      return {\n        type: ResultType.data,\n        data: result.deferredData.unwrappedData,\n      };\n    } catch (e) {\n      // Handle any TrackedPromise._error values encountered while unwrapping\n      return {\n        type: ResultType.error,\n        error: e,\n      };\n    }\n  }\n\n  return {\n    type: ResultType.data,\n    data: result.deferredData.data,\n  };\n}\n\nfunction hasNakedIndexQuery(search: string): boolean {\n  return new URLSearchParams(search).getAll(\"index\").some((v) => v === \"\");\n}\n\nfunction getTargetMatch(\n  matches: AgnosticDataRouteMatch[],\n  location: Location | string\n) {\n  let search =\n    typeof location === \"string\" ? parsePath(location).search : location.search;\n  if (\n    matches[matches.length - 1].route.index &&\n    hasNakedIndexQuery(search || \"\")\n  ) {\n    // Return the leaf index route when index is present\n    return matches[matches.length - 1];\n  }\n  // Otherwise grab the deepest \"path contributing\" match (ignoring index and\n  // pathless layout routes)\n  let pathMatches = getPathContributingMatches(matches);\n  return pathMatches[pathMatches.length - 1];\n}\n\nfunction getSubmissionFromNavigation(\n  navigation: Navigation\n): Submission | undefined {\n  let { formMethod, formAction, formEncType, text, formData, json } =\n    navigation;\n  if (!formMethod || !formAction || !formEncType) {\n    return;\n  }\n\n  if (text != null) {\n    return {\n      formMethod,\n      formAction,\n      formEncType,\n      formData: undefined,\n      json: undefined,\n      text,\n    };\n  } else if (formData != null) {\n    return {\n      formMethod,\n      formAction,\n      formEncType,\n      formData,\n      json: undefined,\n      text: undefined,\n    };\n  } else if (json !== undefined) {\n    return {\n      formMethod,\n      formAction,\n      formEncType,\n      formData: undefined,\n      json,\n      text: undefined,\n    };\n  }\n}\n\nfunction getLoadingNavigation(\n  location: Location,\n  submission?: Submission\n): NavigationStates[\"Loading\"] {\n  if (submission) {\n    let navigation: NavigationStates[\"Loading\"] = {\n      state: \"loading\",\n      location,\n      formMethod: submission.formMethod,\n      formAction: submission.formAction,\n      formEncType: submission.formEncType,\n      formData: submission.formData,\n      json: submission.json,\n      text: submission.text,\n    };\n    return navigation;\n  } else {\n    let navigation: NavigationStates[\"Loading\"] = {\n      state: \"loading\",\n      location,\n      formMethod: undefined,\n      formAction: undefined,\n      formEncType: undefined,\n      formData: undefined,\n      json: undefined,\n      text: undefined,\n    };\n    return navigation;\n  }\n}\n\nfunction getSubmittingNavigation(\n  location: Location,\n  submission: Submission\n): NavigationStates[\"Submitting\"] {\n  let navigation: NavigationStates[\"Submitting\"] = {\n    state: \"submitting\",\n    location,\n    formMethod: submission.formMethod,\n    formAction: submission.formAction,\n    formEncType: submission.formEncType,\n    formData: submission.formData,\n    json: submission.json,\n    text: submission.text,\n  };\n  return navigation;\n}\n\nfunction getLoadingFetcher(\n  submission?: Submission,\n  data?: Fetcher[\"data\"]\n): FetcherStates[\"Loading\"] {\n  if (submission) {\n    let fetcher: FetcherStates[\"Loading\"] = {\n      state: \"loading\",\n      formMethod: submission.formMethod,\n      formAction: submission.formAction,\n      formEncType: submission.formEncType,\n      formData: submission.formData,\n      json: submission.json,\n      text: submission.text,\n      data,\n    };\n    return fetcher;\n  } else {\n    let fetcher: FetcherStates[\"Loading\"] = {\n      state: \"loading\",\n      formMethod: undefined,\n      formAction: undefined,\n      formEncType: undefined,\n      formData: undefined,\n      json: undefined,\n      text: undefined,\n      data,\n    };\n    return fetcher;\n  }\n}\n\nfunction getSubmittingFetcher(\n  submission: Submission,\n  existingFetcher?: Fetcher\n): FetcherStates[\"Submitting\"] {\n  let fetcher: FetcherStates[\"Submitting\"] = {\n    state: \"submitting\",\n    formMethod: submission.formMethod,\n    formAction: submission.formAction,\n    formEncType: submission.formEncType,\n    formData: submission.formData,\n    json: submission.json,\n    text: submission.text,\n    data: existingFetcher ? existingFetcher.data : undefined,\n  };\n  return fetcher;\n}\n\nfunction getDoneFetcher(data: Fetcher[\"data\"]): FetcherStates[\"Idle\"] {\n  let fetcher: FetcherStates[\"Idle\"] = {\n    state: \"idle\",\n    formMethod: undefined,\n    formAction: undefined,\n    formEncType: undefined,\n    formData: undefined,\n    json: undefined,\n    text: undefined,\n    data,\n  };\n  return fetcher;\n}\n//#endregion\n", "module.exports = {};", "/**\n * @remix-run/server-runtime v2.0.1\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n/**\n * The mode to use when running the server.\n */\nlet ServerMode = /*#__PURE__*/function (ServerMode) {\n  ServerMode[\"Development\"] = \"development\";\n  ServerMode[\"Production\"] = \"production\";\n  ServerMode[\"Test\"] = \"test\";\n  return ServerMode;\n}({});\nfunction isServerMode(value) {\n  return value === ServerMode.Development || value === ServerMode.Production || value === ServerMode.Test;\n}\n\nexports.ServerMode = ServerMode;\nexports.isServerMode = isServerMode;\n", "/**\n * @remix-run/server-runtime v2.0.1\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar router = require('@remix-run/router');\nvar mode = require('./mode.js');\n\n/**\n * This thing probably warrants some explanation.\n *\n * The whole point here is to emulate componentDidCatch for server rendering and\n * data loading. It can get tricky. React can do this on component boundaries\n * but doesn't support it for server rendering or data loading. We know enough\n * with nested routes to be able to emulate the behavior (because we know them\n * statically before rendering.)\n *\n * Each route can export an `ErrorBoundary`.\n *\n * - When rendering throws an error, the nearest error boundary will render\n *   (normal react componentDidCatch). This will be the route's own boundary, but\n *   if none is provided, it will bubble up to the parents.\n * - When data loading throws an error, the nearest error boundary will render\n * - When performing an action, the nearest error boundary for the action's\n *   route tree will render (no redirect happens)\n *\n * During normal react rendering, we do nothing special, just normal\n * componentDidCatch.\n *\n * For server rendering, we mutate `renderBoundaryRouteId` to know the last\n * layout that has an error boundary that tried to render. This emulates which\n * layout would catch a thrown error. If the rendering fails, we catch the error\n * on the server, and go again a second time with the emulator holding on to the\n * information it needs to render the same error boundary as a dynamically\n * thrown render error.\n *\n * When data loading, server or client side, we use the emulator to likewise\n * hang on to the error and re-render at the appropriate layout (where a thrown\n * error would have been caught by cDC).\n *\n * When actions throw, it all works the same. There's an edge case to be aware\n * of though. Actions normally are required to redirect, but in the case of\n * errors, we render the action's route with the emulator holding on to the\n * error. If during this render a parent route/loader throws we ignore that new\n * error and render the action's original error as deeply as possible. In other\n * words, we simply ignore the new error and use the action's error in place\n * because it came first, and that just wouldn't be fair to let errors cut in\n * line.\n */\n\nfunction sanitizeError(error, serverMode) {\n  if (error instanceof Error && serverMode !== mode.ServerMode.Development) {\n    let sanitized = new Error(\"Unexpected Server Error\");\n    sanitized.stack = undefined;\n    return sanitized;\n  }\n  return error;\n}\nfunction sanitizeErrors(errors, serverMode) {\n  return Object.entries(errors).reduce((acc, [routeId, error]) => {\n    return Object.assign(acc, {\n      [routeId]: sanitizeError(error, serverMode)\n    });\n  }, {});\n}\n\n// must be type alias due to inference issues on interfaces\n// https://github.com/microsoft/TypeScript/issues/15300\nfunction serializeError(error, serverMode) {\n  let sanitized = sanitizeError(error, serverMode);\n  return {\n    message: sanitized.message,\n    stack: sanitized.stack\n  };\n}\nfunction serializeErrors(errors, serverMode) {\n  if (!errors) return null;\n  let entries = Object.entries(errors);\n  let serialized = {};\n  for (let [key, val] of entries) {\n    // Hey you!  If you change this, please change the corresponding logic in\n    // deserializeErrors in remix-react/errors.ts :)\n    if (router.isRouteErrorResponse(val)) {\n      serialized[key] = {\n        ...val,\n        __type: \"RouteErrorResponse\"\n      };\n    } else if (val instanceof Error) {\n      let sanitized = sanitizeError(val, serverMode);\n      serialized[key] = {\n        message: sanitized.message,\n        stack: sanitized.stack,\n        __type: \"Error\",\n        // If this is a subclass (i.e., ReferenceError), send up the type so we\n        // can re-create the same type during hydration.  This will only apply\n        // in dev mode since all production errors are sanitized to normal\n        // Error instances\n        ...(sanitized.name !== \"Error\" ? {\n          __subType: sanitized.name\n        } : {})\n      };\n    } else {\n      serialized[key] = val;\n    }\n  }\n  return serialized;\n}\n\nexports.sanitizeError = sanitizeError;\nexports.sanitizeErrors = sanitizeErrors;\nexports.serializeError = serializeError;\nexports.serializeErrors = serializeErrors;\n", "/**\n * @remix-run/server-runtime v2.0.1\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar router = require('@remix-run/router');\nvar errors = require('./errors.js');\n\n// must be a type since this is a subtype of response\n// interfaces must conform to the types they extend\n/**\n * This is a shortcut for creating `application/json` responses. Converts `data`\n * to JSON and sets the `Content-Type` header.\n *\n * @see https://remix.run/utils/json\n */\nconst json = (data, init = {}) => {\n  return router.json(data, init);\n};\n\n/**\n * This is a shortcut for creating Remix deferred responses\n *\n * @see https://remix.run/utils/defer\n */\nconst defer = (data, init = {}) => {\n  return router.defer(data, init);\n};\n/**\n * A redirect response. Sets the status code and the `Location` header.\n * Defaults to \"302 Found\".\n *\n * @see https://remix.run/utils/redirect\n */\nconst redirect = (url, init = 302) => {\n  return router.redirect(url, init);\n};\n\n/**\n * A redirect response that will force a document reload to the new location.\n * Sets the status code and the `Location` header.\n * Defaults to \"302 Found\".\n *\n * @see https://remix.run/utils/redirect\n */\nconst redirectDocument = (url, init = 302) => {\n  return router.redirectDocument(url, init);\n};\nfunction isDeferredData(value) {\n  let deferred = value;\n  return deferred && typeof deferred === \"object\" && typeof deferred.data === \"object\" && typeof deferred.subscribe === \"function\" && typeof deferred.cancel === \"function\" && typeof deferred.resolveData === \"function\";\n}\nfunction isResponse(value) {\n  return value != null && typeof value.status === \"number\" && typeof value.statusText === \"string\" && typeof value.headers === \"object\" && typeof value.body !== \"undefined\";\n}\nconst redirectStatusCodes = new Set([301, 302, 303, 307, 308]);\nfunction isRedirectStatusCode(statusCode) {\n  return redirectStatusCodes.has(statusCode);\n}\nfunction isRedirectResponse(response) {\n  return isRedirectStatusCode(response.status);\n}\nfunction isTrackedPromise(value) {\n  return value != null && typeof value.then === \"function\" && value._tracked === true;\n}\n\n// TODO: Figure out why ReadableStream types are borked sooooooo badly\n// in this file. Probably related to our TS configurations and configs\n// bleeding into each other.\nconst DEFERRED_VALUE_PLACEHOLDER_PREFIX = \"__deferred_promise:\";\nfunction createDeferredReadableStream(deferredData, signal, serverMode) {\n  let encoder = new TextEncoder();\n  let stream = new ReadableStream({\n    async start(controller) {\n      let criticalData = {};\n      let preresolvedKeys = [];\n      for (let [key, value] of Object.entries(deferredData.data)) {\n        if (isTrackedPromise(value)) {\n          criticalData[key] = `${DEFERRED_VALUE_PLACEHOLDER_PREFIX}${key}`;\n          if (typeof value._data !== \"undefined\" || typeof value._error !== \"undefined\") {\n            preresolvedKeys.push(key);\n          }\n        } else {\n          criticalData[key] = value;\n        }\n      }\n\n      // Send the critical data\n      controller.enqueue(encoder.encode(JSON.stringify(criticalData) + \"\\n\\n\"));\n      for (let preresolvedKey of preresolvedKeys) {\n        enqueueTrackedPromise(controller, encoder, preresolvedKey, deferredData.data[preresolvedKey], serverMode);\n      }\n      let unsubscribe = deferredData.subscribe((aborted, settledKey) => {\n        if (settledKey) {\n          enqueueTrackedPromise(controller, encoder, settledKey, deferredData.data[settledKey], serverMode);\n        }\n      });\n      await deferredData.resolveData(signal);\n      unsubscribe();\n      controller.close();\n    }\n  });\n  return stream;\n}\nfunction enqueueTrackedPromise(controller, encoder, settledKey, promise, serverMode) {\n  if (\"_error\" in promise) {\n    controller.enqueue(encoder.encode(\"error:\" + JSON.stringify({\n      [settledKey]: promise._error instanceof Error ? errors.serializeError(promise._error, serverMode) : promise._error\n    }) + \"\\n\\n\"));\n  } else {\n    controller.enqueue(encoder.encode(\"data:\" + JSON.stringify({\n      [settledKey]: promise._data ?? null\n    }) + \"\\n\\n\"));\n  }\n}\n\nexports.createDeferredReadableStream = createDeferredReadableStream;\nexports.defer = defer;\nexports.isDeferredData = isDeferredData;\nexports.isRedirectResponse = isRedirectResponse;\nexports.isRedirectStatusCode = isRedirectStatusCode;\nexports.isResponse = isResponse;\nexports.json = json;\nexports.redirect = redirect;\nexports.redirectDocument = redirectDocument;\n", "/// <reference lib=\"WebWorker\" />\r\n\r\nimport { Storage } from '@remix-pwa/cache';\r\nimport { cacheFirst, networkFirst } from '@remix-pwa/strategy';\r\nimport type { DefaultFetchHandler } from '@remix-pwa/sw';\r\nimport { RemixNavigationHandler, logger, matchRequest } from '@remix-pwa/sw';\r\nimport { registerQueue } from '@remix-pwa/sync';\r\nimport createStorageRepository from './database';\r\n\r\ndeclare let self: ServiceWorkerGlobalScope;\r\n\r\nconst PAGES = 'page-cache';\r\nconst DATA = 'data-cache';\r\nconst ASSETS = 'assets-cache';\r\n\r\nconst dataCache = Storage.open(DATA, {\r\n  ttl: 60 * 60 * 24 * 7 * 1_000, // 7 days\r\n});\r\nconst documentCache = Storage.open(PAGES, {\r\n  maxItems: 3\r\n});\r\nconst assetCache = Storage.open(ASSETS, {\r\n  maxItems: 5\r\n});\r\n\r\nlet handler = new RemixNavigationHandler({\r\n  dataCache: dataCache,\r\n  documentCache: documentCache,\r\n});\r\n\r\nconst dataHandler = networkFirst({\r\n  cache: dataCache,\r\n});\r\n\r\nconst assetsHandler = cacheFirst({\r\n  cache: assetCache,\r\n  cacheQueryOptions: {\r\n    ignoreSearch: true,\r\n    ignoreVary: true,\r\n  },\r\n});\r\n\r\nregisterQueue('offline-action');\r\n\r\n/**\r\n * The load context works same as in Remix. The return values of this function will be injected in the worker action/loader.\r\n * @param {FetchEvent} [event] The fetch event request.\r\n * @returns {object} the context object.\r\n */\r\nexport const getLoadContext = () => {\r\n  const stores = createStorageRepository();\r\n\r\n  return {\r\n    database: stores,\r\n  };\r\n};\r\n\r\n// The default fetch event handler will be invoke if the\r\n// route is not matched by any of the worker action/loader.\r\nexport const defaultFetchHandler: DefaultFetchHandler = ({ context, request }) => {\r\n  const type = matchRequest(request);\r\n\r\n  if (type === 'asset') {\r\n    return assetsHandler(context.event.request);\r\n  }\r\n\r\n  if (type === 'loader') {\r\n    return dataHandler(context.event.request);\r\n  }\r\n\r\n  return context.fetchFromServer();\r\n};\r\n\r\nself.addEventListener('install', (event: ExtendableEvent) => {\r\n  logger.log('installing service worker');\r\n  logger.warn('This is a playground service worker \uD83D\uDCE6. It is not intended for production use.');\r\n  event.waitUntil(self.skipWaiting());\r\n});\r\n\r\nself.addEventListener('activate', event => {\r\n  logger.log(self.clients)\r\n  event.waitUntil(self.clients.claim());\r\n});\r\n\r\nself.addEventListener('message', event => {\r\n  event.waitUntil(handler.handle(event));\r\n});\r\n\r\n", "import type { CreateReporter, Reporter } from './reporter';\n\nexport interface CacheMetadata {\n  createdTime: number;\n  ttl?: number | null;\n  swr?: number | null;\n  /** @deprecated use swr instead */\n  readonly swv?: number | null;\n}\n\nexport interface CacheEntry<Value = unknown> {\n  metadata: CacheMetadata;\n  value: Value;\n}\n\nexport type Eventually<Value> =\n  | Value\n  | null\n  | undefined\n  | Promise<Value | null | undefined>;\n\nexport interface Cache {\n  name?: string;\n  get: (key: string) => Eventually<CacheEntry<unknown>>;\n  set: (key: string, value: CacheEntry<unknown>) => unknown | Promise<unknown>;\n  delete: (key: string) => unknown | Promise<unknown>;\n}\n\nexport interface GetFreshValueContext {\n  readonly metadata: CacheMetadata;\n  readonly background: boolean;\n}\nexport const HANDLE = Symbol();\nexport type GetFreshValue<Value> = {\n  (context: GetFreshValueContext): Promise<Value> | Value;\n  [HANDLE]?: () => void;\n};\nexport const MIGRATED = Symbol();\nexport type MigratedValue<Value> = {\n  [MIGRATED]: boolean;\n  value: Value;\n};\n\nexport type ValueCheckResultOk<Value> =\n  | true\n  | undefined\n  | null\n  | void\n  | MigratedValue<Value>;\nexport type ValueCheckResultInvalid = false | string;\nexport type ValueCheckResult<Value> =\n  | ValueCheckResultOk<Value>\n  | ValueCheckResultInvalid;\nexport type CheckValue<Value> = (\n  value: unknown,\n  migrate: (value: Value, updateCache?: boolean) => MigratedValue<Value>,\n) => ValueCheckResult<Value> | Promise<ValueCheckResult<Value>>;\nexport interface Schema<Value, InputValue> {\n  _input: InputValue;\n  parseAsync(value: unknown): Promise<Value>;\n}\n\nexport interface CachifiedOptions<Value> {\n  /**\n   * Required\n   *\n   * The key this value is cached by\n   * Must be unique for each value\n   */\n  key: string;\n  /**\n   * Required\n   *\n   * Cache implementation to use\n   *\n   * Must conform with signature\n   *  - set(key: string, value: object): void | Promise<void>\n   *  - get(key: string): object | Promise<object>\n   *  - delete(key: string): void | Promise<void>\n   */\n  cache: Cache;\n  /**\n   * Required\n   *\n   * Function that is called when no valid value is in cache for given key\n   * Basically what we would do if we wouldn't use a cache\n   *\n   * Can be async and must return fresh value or throw\n   *\n   * receives context object as argument\n   *  - context.metadata.ttl?: number\n   *  - context.metadata.swr?: number\n   *  - context.metadata.createdTime: number\n   *  - context.background: boolean\n   */\n  getFreshValue: GetFreshValue<Value>;\n  /**\n   * Time To Live; often also referred to as max age\n   *\n   * Amount of milliseconds the value should stay in cache\n   * before we get a fresh one\n   *\n   * Setting any negative value will disable caching\n   * Can be infinite\n   *\n   * Default: `Infinity`\n   */\n  ttl?: number;\n  /**\n   * Amount of milliseconds that a value with exceeded ttl is still returned\n   * while a fresh value is refreshed in the background\n   *\n   * Should be positive, can be infinite\n   *\n   * Default: `0`\n   */\n  staleWhileRevalidate?: number;\n  /**\n   * Alias for staleWhileRevalidate\n   */\n  swr?: number;\n  /**\n   * Validator that checks every cached and fresh value to ensure type safety\n   *\n   * Can be a zod schema or a custom validator function\n   *\n   * Value considered ok when:\n   *  - zod schema.parseAsync succeeds\n   *  - validator returns\n   *    - true\n   *    - migrate(newValue)\n   *    - undefined\n   *    - null\n   *\n   * Value considered bad when:\n   *  - zod schema.parseAsync throws\n   *  - validator:\n   *    - returns false\n   *    - returns reason as string\n   *    - throws\n   *\n   * A validator function receives two arguments:\n   *  1. the value\n   *  2. a migrate callback, see https://github.com/Xiphe/cachified#migrating-values\n   *\n   * Default: `undefined` - no validation\n   */\n  checkValue?: CheckValue<Value> | Schema<Value, unknown>;\n  /**\n   * Set true to not even try reading the currently cached value\n   *\n   * Will write new value to cache even when cached value is\n   * still valid.\n   *\n   * Default: `false`\n   */\n  forceFresh?: boolean;\n  /**\n   * Weather of not to fall back to cache when getting a forced fresh value\n   * fails\n   *\n   * Can also be a positive number as the maximum age in milliseconds that a\n   * fallback value might have\n   *\n   * Default: `Infinity`\n   */\n  fallbackToCache?: boolean | number;\n  /**\n   * Amount of time in milliseconds before revalidation of a stale\n   * cache entry is started\n   *\n   * Must be positive and finite\n   *\n   * Default: `0`\n   */\n  staleRefreshTimeout?: number;\n  /**\n   * A reporter receives events during the runtime of\n   * cachified and can be used for debugging and monitoring\n   *\n   * Default: `undefined` - no reporting\n   */\n  reporter?: CreateReporter<Value> | null;\n}\n\n/* When using a schema validator, a strongly typed getFreshValue is not required\n   and sometimes even sub-optimal */\nexport type CachifiedOptionsWithSchema<Value, InternalValue> = Omit<\n  CachifiedOptions<Value>,\n  'checkValue' | 'getFreshValue'\n> & {\n  checkValue: Schema<Value, InternalValue>;\n  getFreshValue: GetFreshValue<InternalValue>;\n};\n\nexport interface Context<Value>\n  extends Omit<\n    Required<CachifiedOptions<Value>>,\n    'fallbackToCache' | 'reporter' | 'checkValue' | 'swr'\n  > {\n  checkValue: CheckValue<Value>;\n  report: Reporter<Value>;\n  fallbackToCache: number;\n  metadata: CacheMetadata;\n}\n\nexport function createContext<Value>({\n  fallbackToCache,\n  reporter,\n  checkValue,\n  ...options\n}: CachifiedOptions<Value>): Context<Value> {\n  const ttl = options.ttl ?? Infinity;\n  const staleWhileRevalidate = options.swr ?? options.staleWhileRevalidate ?? 0;\n  const checkValueCompat: CheckValue<Value> =\n    typeof checkValue === 'function'\n      ? checkValue\n      : typeof checkValue === 'object'\n      ? (value, migrate) =>\n          checkValue.parseAsync(value).then((v) => migrate(v, false))\n      : () => true;\n\n  const contextWithoutReport = {\n    checkValue: checkValueCompat,\n    ttl,\n    staleWhileRevalidate,\n    fallbackToCache:\n      fallbackToCache === false\n        ? 0\n        : fallbackToCache === true || fallbackToCache === undefined\n        ? Infinity\n        : fallbackToCache,\n    staleRefreshTimeout: 0,\n    forceFresh: false,\n    ...options,\n    metadata: createCacheMetaData({ ttl, swr: staleWhileRevalidate }),\n  };\n\n  const report =\n    reporter?.(contextWithoutReport) ||\n    (() => {\n      /* \u00AF\\_(\u30C4)_/\u00AF */\n    });\n\n  return {\n    ...contextWithoutReport,\n    report,\n  };\n}\n\nexport function staleWhileRevalidate(metadata: CacheMetadata): number | null {\n  return (\n    (typeof metadata.swr === 'undefined' ? metadata.swv : metadata.swr) || null\n  );\n}\n\nexport function totalTtl(metadata?: CacheMetadata): number {\n  if (!metadata) {\n    return 0;\n  }\n  if (metadata.ttl === null) {\n    return Infinity;\n  }\n  return (metadata.ttl || 0) + (staleWhileRevalidate(metadata) || 0);\n}\n\nexport function createCacheMetaData({\n  ttl = null,\n  swr = 0,\n  createdTime = Date.now(),\n}: Partial<Omit<CacheMetadata, 'swv'>> = {}) {\n  return {\n    ttl: ttl === Infinity ? null : ttl,\n    swr: swr === Infinity ? null : swr,\n    createdTime,\n  };\n}\n\nexport function createCacheEntry<Value>(\n  value: Value,\n  metadata?: Partial<Omit<CacheMetadata, 'swv'>>,\n): CacheEntry<Value> {\n  return {\n    value,\n    metadata: createCacheMetaData(metadata),\n  };\n}\n", "import { CacheMetadata, Context, staleWhileRevalidate } from './common';\n\nexport type GetFreshValueStartEvent = {\n  name: 'getFreshValueStart';\n};\nexport type GetFreshValueHookPendingEvent = {\n  name: 'getFreshValueHookPending';\n};\nexport type GetFreshValueSuccessEvent<Value> = {\n  name: 'getFreshValueSuccess';\n  value: Value;\n};\nexport type GetFreshValueErrorEvent = {\n  name: 'getFreshValueError';\n  error: unknown;\n};\nexport type GetFreshValueCacheFallbackEvent = {\n  name: 'getFreshValueCacheFallback';\n  value: unknown;\n};\n/** @deprecated this event will be removed in favour of `CheckFreshValueErrorObjEvent` */\nexport type CheckFreshValueErrorEvent<Value> = {\n  name: 'checkFreshValueError';\n  reason: string;\n};\nexport type CheckFreshValueErrorObjEvent = {\n  name: 'checkFreshValueErrorObj';\n  reason: unknown;\n};\nexport type WriteFreshValueSuccessEvent<Value> = {\n  name: 'writeFreshValueSuccess';\n  metadata: CacheMetadata;\n  /**\n   * Value might not actually be written to cache in case getting fresh\n   * value took longer then ttl */\n  written: boolean;\n  migrated: boolean;\n};\nexport type WriteFreshValueErrorEvent = {\n  name: 'writeFreshValueError';\n  error: unknown;\n};\n\nexport type GetCachedValueStartEvent = {\n  name: 'getCachedValueStart';\n};\nexport type GetCachedValueReadEvent = {\n  name: 'getCachedValueRead';\n  entry: unknown;\n};\nexport type GetCachedValueEmptyEvent = {\n  name: 'getCachedValueEmpty';\n};\nexport type GetCachedValueOutdatedEvent = {\n  name: 'getCachedValueOutdated';\n  value: unknown;\n  metadata: CacheMetadata;\n};\nexport type GetCachedValueSuccessEvent<Value> = {\n  name: 'getCachedValueSuccess';\n  value: Value;\n  migrated: boolean;\n};\n/** @deprecated this event will be removed in favour of `CheckCachedValueErrorObjEvent` */\nexport type CheckCachedValueErrorEvent = {\n  name: 'checkCachedValueError';\n  reason: string;\n};\nexport type CheckCachedValueErrorObjEvent = {\n  name: 'checkCachedValueErrorObj';\n  reason: unknown;\n};\nexport type GetCachedValueErrorEvent = {\n  name: 'getCachedValueError';\n  error: unknown;\n};\n\nexport type RefreshValueStartEvent = {\n  name: 'refreshValueStart';\n};\nexport type RefreshValueSuccessEvent<Value> = {\n  name: 'refreshValueSuccess';\n  value: Value;\n};\nexport type RefreshValueErrorEvent = {\n  name: 'refreshValueError';\n  error: unknown;\n};\nexport type DoneEvent<Value> = {\n  name: 'done';\n  value: Value;\n};\n\nexport type CacheEvent<Value> =\n  | GetFreshValueStartEvent\n  | GetFreshValueHookPendingEvent\n  | GetFreshValueSuccessEvent<Value>\n  | GetFreshValueErrorEvent\n  | GetFreshValueCacheFallbackEvent\n  | CheckFreshValueErrorEvent<Value>\n  | CheckFreshValueErrorObjEvent\n  | WriteFreshValueSuccessEvent<Value>\n  | WriteFreshValueErrorEvent\n  | GetCachedValueStartEvent\n  | GetCachedValueReadEvent\n  | GetCachedValueEmptyEvent\n  | GetCachedValueOutdatedEvent\n  | GetCachedValueSuccessEvent<Value>\n  | CheckCachedValueErrorEvent\n  | CheckCachedValueErrorObjEvent\n  | GetCachedValueErrorEvent\n  | RefreshValueStartEvent\n  | RefreshValueSuccessEvent<Value>\n  | RefreshValueErrorEvent\n  | DoneEvent<Value>;\n\nexport type Reporter<Value> = (event: CacheEvent<Value>) => void;\n\nexport type CreateReporter<Value> = (\n  context: Omit<Context<Value>, 'report'>,\n) => Reporter<Value>;\n\nconst defaultFormatDuration = (ms: number) => `${Math.round(ms)}ms`;\nfunction formatCacheTime(\n  metadata: CacheMetadata,\n  formatDuration: (duration: number) => string,\n) {\n  const swr = staleWhileRevalidate(metadata);\n  if (metadata.ttl == null || swr == null) {\n    return `forever${\n      metadata.ttl != null\n        ? ` (revalidation after ${formatDuration(metadata.ttl)})`\n        : ''\n    }`;\n  }\n\n  return `${formatDuration(metadata.ttl)} + ${formatDuration(swr)} stale`;\n}\n\ninterface ReporterOpts {\n  formatDuration?: (ms: number) => string;\n  logger?: Pick<typeof console, 'log' | 'warn' | 'error'>;\n  performance?: Pick<typeof Date, 'now'>;\n}\nexport function verboseReporter<Value>({\n  formatDuration = defaultFormatDuration,\n  logger = console,\n  performance = global.performance || Date,\n}: ReporterOpts = {}): CreateReporter<Value> {\n  return ({ key, fallbackToCache, forceFresh, metadata, cache }) => {\n    const cacheName =\n      cache.name ||\n      cache\n        .toString()\n        .toString()\n        .replace(/^\\[object (.*?)]$/, '$1');\n    let cached: unknown;\n    let freshValue: unknown;\n    let getFreshValueStartTs: number;\n    let refreshValueStartTS: number;\n\n    return (event) => {\n      switch (event.name) {\n        case 'getCachedValueRead':\n          cached = event.entry;\n          break;\n        case 'checkCachedValueError':\n          logger.warn(\n            `check failed for cached value of ${key}\\nReason: ${event.reason}.\\nDeleting the cache key and trying to get a fresh value.`,\n            cached,\n          );\n          break;\n        case 'getCachedValueError':\n          logger.error(\n            `error with cache at ${key}. Deleting the cache key and trying to get a fresh value.`,\n            event.error,\n          );\n          break;\n        case 'getFreshValueError':\n          logger.error(\n            `getting a fresh value for ${key} failed`,\n            { fallbackToCache, forceFresh },\n            event.error,\n          );\n          break;\n        case 'getFreshValueStart':\n          getFreshValueStartTs = performance.now();\n          break;\n        case 'writeFreshValueSuccess': {\n          const totalTime = performance.now() - getFreshValueStartTs;\n          if (event.written) {\n            logger.log(\n              `Updated the cache value for ${key}.`,\n              `Getting a fresh value for this took ${formatDuration(\n                totalTime,\n              )}.`,\n              `Caching for ${formatCacheTime(\n                metadata,\n                formatDuration,\n              )} in ${cacheName}.`,\n            );\n          } else {\n            logger.log(\n              `Not updating the cache value for ${key}.`,\n              `Getting a fresh value for this took ${formatDuration(\n                totalTime,\n              )}.`,\n              `Thereby exceeding caching time of ${formatCacheTime(\n                metadata,\n                formatDuration,\n              )}`,\n            );\n          }\n          break;\n        }\n        case 'writeFreshValueError':\n          logger.error(`error setting cache: ${key}`, event.error);\n          break;\n        case 'getFreshValueSuccess':\n          freshValue = event.value;\n          break;\n        case 'checkFreshValueError':\n          logger.error(\n            `check failed for fresh value of ${key}\\nReason: ${event.reason}.`,\n            freshValue,\n          );\n          break;\n        case 'refreshValueStart':\n          refreshValueStartTS = performance.now();\n          break;\n        case 'refreshValueSuccess':\n          logger.log(\n            `Background refresh for ${key} successful.`,\n            `Getting a fresh value for this took ${formatDuration(\n              performance.now() - refreshValueStartTS,\n            )}.`,\n            `Caching for ${formatCacheTime(\n              metadata,\n              formatDuration,\n            )} in ${cacheName}.`,\n          );\n          break;\n        case 'refreshValueError':\n          logger.log(`Background refresh for ${key} failed.`, event.error);\n          break;\n      }\n    };\n  };\n}\n\nexport function mergeReporters<Value = unknown>(\n  ...reporters: (CreateReporter<Value> | null | undefined)[]\n): CreateReporter<Value> {\n  return (context) => {\n    const reporter = reporters.map((r) => r?.(context));\n    return (event) => {\n      reporter.forEach((r) => r?.(event));\n    };\n  };\n}\n", "import { Cache, CacheEntry, totalTtl } from './common';\n\nexport interface LRUishCache extends Omit<Cache, 'set'> {\n  set(\n    key: string,\n    value: CacheEntry<unknown>,\n    options?: { ttl?: number; start?: number },\n  ): void;\n}\n\nexport function lruCacheAdapter(lruCache: LRUishCache): Cache {\n  return {\n    name: lruCache.name || 'LRU',\n    set(key, value) {\n      const ttl = totalTtl(value?.metadata);\n      return lruCache.set(key, value, {\n        ttl: ttl === Infinity ? undefined : ttl,\n        start: value?.metadata?.createdTime,\n      });\n    },\n    get(key) {\n      return lruCache.get(key);\n    },\n    delete(key) {\n      return lruCache.delete(key);\n    },\n  };\n}\n\ninterface Redis3Multi {\n  set(key: string, value: string): Redis3Multi;\n  expireat(key: string, timestamp: number): Redis3Multi;\n  exec(cb: (err: Error | null, replies: (number | 'OK')[]) => void): unknown;\n}\nexport interface Redis3LikeCache {\n  name?: string;\n  set(\n    key: string,\n    value: string,\n    cb: (err: Error | null, reply: 'OK') => void,\n  ): unknown;\n  get(\n    key: string,\n    cb?: (err: Error | null, reply: string | null) => void,\n  ): unknown;\n  del(key: string, cb?: (err: Error | null, reply: number) => void): unknown;\n  multi(): Redis3Multi;\n}\n\nexport function redis3CacheAdapter(redisCache: Redis3LikeCache): Cache {\n  return {\n    name: redisCache.name || 'Redis3',\n    set(key, value) {\n      return new Promise<void>((res, rej) => {\n        const ttl = totalTtl(value?.metadata);\n        const createdTime = value?.metadata?.createdTime;\n        const cb = (err: unknown) => {\n          if (err) {\n            return rej(err);\n          }\n          res();\n        };\n\n        if (ttl > 0 && ttl < Infinity && typeof createdTime === 'number') {\n          redisCache\n            .multi()\n            .set(key, JSON.stringify(value))\n            .expireat(key, (ttl + createdTime) / 1000)\n            .exec(cb);\n        } else {\n          redisCache.set(key, JSON.stringify(value), cb);\n        }\n      });\n    },\n    get(key) {\n      return new Promise<CacheEntry | null | undefined>((res, rej) => {\n        redisCache.get(key, (err, reply) => {\n          if (err) {\n            rej(err);\n          } else if (reply == null) {\n            res(null);\n          } else {\n            try {\n              res(JSON.parse(reply));\n            } catch (err) {\n              rej(err);\n            }\n          }\n        });\n      });\n    },\n    delete(key) {\n      return new Promise<void>((res, rej) => {\n        redisCache.del(key, (err) => {\n          if (err) {\n            rej(err);\n          }\n          res();\n        });\n      });\n    },\n  };\n}\n\nexport interface RedisLikeCache {\n  name?: string;\n  set(\n    key: string,\n    value: string,\n    options?: { EXAT: number },\n  ): Promise<string | null>;\n  get(key: string): Promise<string | null>;\n  del(key: string): Promise<unknown>;\n}\n\nexport function redisCacheAdapter(redisCache: RedisLikeCache): Cache {\n  return {\n    name: redisCache.name || 'Redis',\n    set(key, value) {\n      const ttl = totalTtl(value?.metadata);\n      const createdTime = value?.metadata?.createdTime;\n\n      return redisCache.set(\n        key,\n        JSON.stringify(value),\n        ttl > 0 && ttl < Infinity && typeof createdTime === 'number'\n          ? {\n              EXAT: Math.ceil((ttl + createdTime) / 1000),\n            }\n          : undefined,\n      );\n    },\n    async get(key) {\n      const value = await redisCache.get(key);\n      if (value == null) {\n        return null;\n      }\n      return JSON.parse(value);\n    },\n    delete(key) {\n      return redisCache.del(key);\n    },\n  };\n}\n", "import type { GetFreshValue, GetFreshValueContext } from './common';\nimport { HANDLE } from './common';\n\ntype OnValueCallback<Value> = (\n  context: GetFreshValueContext & {\n    value: Value;\n  },\n) => void;\n\nexport type AddFn<Value, Param> = (\n  param: Param,\n  onValue?: OnValueCallback<Value>,\n) => GetFreshValue<Value>;\n\nexport function createBatch<Value, Param>(\n  getFreshValues: (params: Param[]) => Value[] | Promise<Value[]>,\n  autoSubmit: false,\n): {\n  submit: () => Promise<void>;\n  add: AddFn<Value, Param>;\n};\nexport function createBatch<Value, Param>(\n  getFreshValues: (params: Param[]) => Value[] | Promise<Value[]>,\n): {\n  add: AddFn<Value, Param>;\n};\nexport function createBatch<Value, Param>(\n  getFreshValues: (params: Param[]) => Value[] | Promise<Value[]>,\n  autoSubmit: boolean = true,\n): {\n  submit?: () => Promise<void>;\n  add: AddFn<Value, Param>;\n} {\n  const requests: [\n    param: Param,\n    res: (value: Value) => void,\n    rej: (reason: unknown) => void,\n  ][] = [];\n\n  let count = 0;\n  let submitted = false;\n  const submission = new Deferred<void>();\n\n  const checkSubmission = () => {\n    if (submitted) {\n      throw new Error('Can not add to batch after submission');\n    }\n  };\n\n  const submit = async () => {\n    if (count !== 0) {\n      autoSubmit = true;\n      return submission.promise;\n    }\n    checkSubmission();\n    submitted = true;\n\n    if (requests.length === 0) {\n      submission.resolve();\n      return;\n    }\n\n    try {\n      const results = await Promise.resolve(\n        getFreshValues(requests.map(([param]) => param)),\n      );\n      results.forEach((value, index) => requests[index][1](value));\n      submission.resolve();\n    } catch (err) {\n      requests.forEach(([_, __, rej]) => rej(err));\n      submission.resolve();\n    }\n  };\n\n  const trySubmitting = () => {\n    count--;\n    if (autoSubmit === false) {\n      return;\n    }\n    submit();\n  };\n\n  return {\n    ...(autoSubmit === false ? { submit } : {}),\n    add(param, onValue) {\n      checkSubmission();\n      count++;\n      let handled = false;\n\n      return Object.assign(\n        (context: GetFreshValueContext) => {\n          return new Promise<Value>((res, rej) => {\n            requests.push([\n              param,\n              (value) => {\n                onValue?.({ ...context, value });\n                res(value);\n              },\n              rej,\n            ]);\n            if (!handled) {\n              handled = true;\n              trySubmitting();\n            }\n          });\n        },\n        {\n          [HANDLE]: () => {\n            if (!handled) {\n              handled = true;\n              trySubmitting();\n            }\n          },\n        },\n      );\n    },\n  };\n}\n\nexport class Deferred<Value> {\n  readonly promise: Promise<Value>;\n  // @ts-ignore\n  readonly resolve: (value: Value | Promise<Value>) => void;\n  // @ts-ignore\n  readonly reject: (reason: unknown) => void;\n  constructor() {\n    this.promise = new Promise((res, rej) => {\n      // @ts-ignore\n      this.resolve = res;\n      // @ts-ignore\n      this.reject = rej;\n    });\n  }\n}\n", "import type { CacheMetadata } from './common';\n\nexport function logKey(key?: string) {\n  return key ? `for ${key} ` : '';\n}\n\nexport function assertCacheEntry(\n  entry: unknown,\n  key?: string,\n): asserts entry is {\n  metadata: CacheMetadata;\n  value: unknown;\n} {\n  if (!isRecord(entry)) {\n    throw new Error(\n      `Cache entry ${logKey(\n        key,\n      )}is not a cache entry object, it's a ${typeof entry}`,\n    );\n  }\n  if (\n    !isRecord(entry.metadata) ||\n    typeof entry.metadata.createdTime !== 'number' ||\n    (entry.metadata.ttl != null && typeof entry.metadata.ttl !== 'number') ||\n    (entry.metadata.swr != null && typeof entry.metadata.swr !== 'number')\n  ) {\n    throw new Error(\n      `Cache entry ${logKey(key)}does not have valid metadata property`,\n    );\n  }\n\n  if (!('value' in entry)) {\n    throw new Error(\n      `Cache entry for ${logKey(key)}does not have a value property`,\n    );\n  }\n}\n\nfunction isRecord(entry: unknown): entry is Record<string, unknown> {\n  return typeof entry === 'object' && entry !== null && !Array.isArray(entry);\n}\n", "import { CacheMetadata, staleWhileRevalidate } from './common';\n\nexport function shouldRefresh(\n  metadata: CacheMetadata,\n): 'now' | 'stale' | false {\n  if (metadata.ttl !== null) {\n    const valid = metadata.createdTime + (metadata.ttl || 0);\n    const stale = valid + (staleWhileRevalidate(metadata) || 0);\n    const now = Date.now();\n    if (now <= valid) {\n      return false;\n    }\n    if (now <= stale) {\n      return 'stale';\n    }\n\n    return 'now';\n  }\n  return false;\n}\n", "import type { Context } from './common';\nimport { MIGRATED } from './common';\n\nexport async function checkValue<Value>(\n  context: Context<Value>,\n  value: unknown,\n): Promise<\n  | { success: true; value: Value; migrated: boolean }\n  | { success: false; reason: unknown }\n> {\n  try {\n    const checkResponse = await context.checkValue(\n      value,\n      (value, updateCache = true) => ({\n        [MIGRATED]: updateCache,\n        value,\n      }),\n    );\n\n    if (typeof checkResponse === 'string') {\n      return { success: false, reason: checkResponse };\n    }\n\n    if (checkResponse == null || checkResponse === true) {\n      return {\n        success: true,\n        value: value as Value,\n        migrated: false,\n      };\n    }\n\n    if (checkResponse && typeof checkResponse[MIGRATED] === 'boolean') {\n      return {\n        success: true,\n        migrated: checkResponse[MIGRATED],\n        value: checkResponse.value,\n      };\n    }\n\n    return { success: false, reason: 'unknown' };\n  } catch (err) {\n    return {\n      success: false,\n      reason: err,\n    };\n  }\n}\n", "import { Context, CacheEntry } from './common';\nimport { assertCacheEntry } from './assertCacheEntry';\nimport { HANDLE } from './common';\nimport { shouldRefresh } from './shouldRefresh';\nimport { cachified } from './cachified';\nimport { Reporter } from './reporter';\nimport { checkValue } from './checkValue';\n\nexport const CACHE_EMPTY = Symbol();\nexport async function getCacheEntry<Value>(\n  { key, cache }: Pick<Context<Value>, 'key' | 'cache'>,\n  report: Reporter<Value>,\n): Promise<CacheEntry<unknown> | typeof CACHE_EMPTY> {\n  report({ name: 'getCachedValueStart' });\n  const cached = await cache.get(key);\n  report({ name: 'getCachedValueRead', entry: cached });\n  if (cached) {\n    assertCacheEntry(cached, key);\n    return cached;\n  }\n  return CACHE_EMPTY;\n}\n\nexport async function getCachedValue<Value>(\n  context: Context<Value>,\n  report: Reporter<Value>,\n  hasPendingValue: () => boolean,\n): Promise<Value | typeof CACHE_EMPTY> {\n  const {\n    key,\n    cache,\n    staleWhileRevalidate,\n    staleRefreshTimeout,\n    metadata,\n    getFreshValue: { [HANDLE]: handle },\n  } = context;\n  try {\n    const cached = await getCacheEntry(context, report);\n\n    if (cached === CACHE_EMPTY) {\n      report({ name: 'getCachedValueEmpty' });\n      return CACHE_EMPTY;\n    }\n\n    const refresh = shouldRefresh(cached.metadata);\n    const staleRefresh =\n      refresh === 'stale' ||\n      (refresh === 'now' && staleWhileRevalidate === Infinity);\n\n    if (refresh === 'now') {\n      report({ name: 'getCachedValueOutdated', ...cached });\n    }\n\n    if (staleRefresh) {\n      // refresh cache in background so future requests are faster\n      setTimeout(() => {\n        report({ name: 'refreshValueStart' });\n        void cachified({\n          ...context,\n          reporter: () => () => {},\n          getFreshValue({ metadata }) {\n            return context.getFreshValue({ metadata, background: true });\n          },\n          forceFresh: true,\n          fallbackToCache: false,\n        })\n          .then((value) => {\n            report({ name: 'refreshValueSuccess', value });\n          })\n          .catch((error) => {\n            report({ name: 'refreshValueError', error });\n          });\n      }, staleRefreshTimeout);\n    }\n\n    if (!refresh || staleRefresh) {\n      const valueCheck = await checkValue(context, cached.value);\n      if (valueCheck.success) {\n        report({\n          name: 'getCachedValueSuccess',\n          value: valueCheck.value,\n          migrated: valueCheck.migrated,\n        });\n        if (!staleRefresh) {\n          // Notify batch that we handled this call using cached value\n          handle?.();\n        }\n\n        if (valueCheck.migrated) {\n          setTimeout(async () => {\n            try {\n              const cached = await context.cache.get(context.key);\n\n              // Unless cached value was changed in the meantime or is about to\n              // change\n              if (\n                cached &&\n                cached.metadata.createdTime === metadata.createdTime &&\n                !hasPendingValue()\n              ) {\n                // update with migrated value\n                await context.cache.set(context.key, {\n                  ...cached,\n                  value: valueCheck.value,\n                });\n              }\n            } catch (err) {\n              /* \u00AF\\_(\u30C4)_/\u00AF */\n            }\n          }, 0);\n        }\n\n        return valueCheck.value;\n      } else {\n        report({ name: 'checkCachedValueErrorObj', reason: valueCheck.reason });\n        report({\n          name: 'checkCachedValueError',\n          reason:\n            valueCheck.reason instanceof Error\n              ? valueCheck.reason.message\n              : String(valueCheck.reason),\n        });\n\n        await cache.delete(key);\n      }\n    }\n  } catch (error: unknown) {\n    report({ name: 'getCachedValueError', error });\n\n    await cache.delete(key);\n  }\n\n  return CACHE_EMPTY;\n}\n", "import { Context, CacheMetadata, createCacheEntry } from './common';\nimport { getCacheEntry, CACHE_EMPTY } from './getCachedValue';\nimport { shouldRefresh } from './shouldRefresh';\nimport { Reporter } from './reporter';\nimport { checkValue } from './checkValue';\n\nexport async function getFreshValue<Value>(\n  context: Context<Value>,\n  metadata: CacheMetadata,\n  report: Reporter<Value>,\n): Promise<Value> {\n  const { fallbackToCache, key, getFreshValue, forceFresh, cache } = context;\n\n  let value: unknown;\n  try {\n    report({ name: 'getFreshValueStart' });\n    const freshValue = await getFreshValue({\n      metadata: context.metadata,\n      background: false,\n    });\n    value = freshValue;\n    report({ name: 'getFreshValueSuccess', value: freshValue });\n  } catch (error) {\n    report({ name: 'getFreshValueError', error });\n\n    // in case a fresh value was forced (and errored) we might be able to\n    // still get one from cache\n    if (forceFresh && fallbackToCache > 0) {\n      const entry = await getCacheEntry(context, report);\n      if (\n        entry === CACHE_EMPTY ||\n        entry.metadata.createdTime + fallbackToCache < Date.now()\n      ) {\n        throw error;\n      }\n      value = entry.value;\n      report({ name: 'getFreshValueCacheFallback', value });\n    } else {\n      // we are either not allowed to check the cache or already checked it\n      // nothing we can do anymore\n      throw error;\n    }\n  }\n\n  const valueCheck = await checkValue(context, value);\n  if (!valueCheck.success) {\n    report({ name: 'checkFreshValueErrorObj', reason: valueCheck.reason });\n    report({\n      name: 'checkFreshValueError',\n      reason:\n        valueCheck.reason instanceof Error\n          ? valueCheck.reason.message\n          : String(valueCheck.reason),\n    });\n\n    throw new Error(`check failed for fresh value of ${key}`, {\n      cause: valueCheck.reason,\n    });\n  }\n\n  try {\n    const write = shouldRefresh(metadata) !== 'now';\n    if (write) {\n      await cache.set(key, createCacheEntry(value, metadata));\n    }\n    report({\n      name: 'writeFreshValueSuccess',\n      metadata,\n      migrated: valueCheck.migrated,\n      written: write,\n    });\n  } catch (error: unknown) {\n    report({ name: 'writeFreshValueError', error });\n  }\n\n  return valueCheck.value;\n}\n", "import {\n  CachifiedOptions,\n  CachifiedOptionsWithSchema,\n  Cache,\n  CacheEntry,\n  createContext,\n} from './common';\nimport { CACHE_EMPTY, getCachedValue } from './getCachedValue';\nimport { getFreshValue } from './getFreshValue';\nimport { shouldRefresh } from './shouldRefresh';\n\n// This is to prevent requesting multiple fresh values in parallel\n// while revalidating or getting first value\n// Keys are unique per cache but may be used by multiple caches\nconst pendingValuesByCache = new WeakMap<Cache, Map<string, any>>();\n\nexport async function cachified<Value, InternalValue>(\n  options: CachifiedOptionsWithSchema<Value, InternalValue>,\n): Promise<Value>;\nexport async function cachified<Value>(\n  options: CachifiedOptions<Value>,\n): Promise<Value>;\nexport async function cachified<Value>(\n  options: CachifiedOptions<Value>,\n): Promise<Value> {\n  const context = createContext(options);\n  const { key, cache, forceFresh, report, metadata } = context;\n\n  // Register this cache\n  if (!pendingValuesByCache.has(cache)) {\n    pendingValuesByCache.set(cache, new Map());\n  }\n  const pendingValues: Map<\n    string,\n    CacheEntry<Promise<Value>> & { resolve: (value: Value) => void }\n  > = pendingValuesByCache.get(cache)!;\n\n  const hasPendingValue = () => {\n    return pendingValues.has(key);\n  };\n  const cachedValue = !forceFresh\n    ? await getCachedValue(context, report, hasPendingValue)\n    : CACHE_EMPTY;\n  if (cachedValue !== CACHE_EMPTY) {\n    report({ name: 'done', value: cachedValue });\n    return cachedValue;\n  }\n\n  if (pendingValues.has(key)) {\n    const { value: pendingRefreshValue, metadata } = pendingValues.get(key)!;\n    if (!shouldRefresh(metadata)) {\n      report({ name: 'getFreshValueHookPending' });\n      const value = await pendingRefreshValue;\n      report({ name: 'done', value });\n      return value;\n    }\n  }\n\n  let resolveFromFuture: (value: Value) => void;\n  const freshValue = Promise.race([\n    // try to get a fresh value\n    getFreshValue(context, metadata, report),\n    // or when a future call is faster, we'll take it's value\n    // this happens when getting value of first call takes longer then ttl + second response\n    new Promise<Value>((r) => {\n      resolveFromFuture = r;\n    }),\n  ]).finally(() => {\n    pendingValues.delete(key);\n  });\n\n  // here we inform past calls that we got a response\n  if (pendingValues.has(key)) {\n    const { resolve } = pendingValues.get(key)!;\n    freshValue.then((value) => resolve(value));\n  }\n\n  pendingValues.set(key, {\n    metadata,\n    value: freshValue,\n    // here we receive a fresh value from a future call\n    resolve: resolveFromFuture!,\n  });\n\n  const value = await freshValue;\n  report({ name: 'done', value });\n  return value;\n}\n", "import { Cache, createCacheEntry, staleWhileRevalidate } from './common';\nimport { CACHE_EMPTY, getCacheEntry } from './getCachedValue';\nimport { shouldRefresh } from './shouldRefresh';\n\ninterface SoftPurgeOpts {\n  cache: Cache;\n  key: string;\n  /**\n   * Force the entry to outdate after ms\n   */\n  staleWhileRevalidate?: number;\n  /**\n   * Force the entry to outdate after ms\n   */\n  swr?: number;\n}\n\nexport async function softPurge({\n  cache,\n  key,\n  ...swrOverwrites\n}: SoftPurgeOpts) {\n  const swrOverwrite = swrOverwrites.swr ?? swrOverwrites.staleWhileRevalidate;\n  const entry = await getCacheEntry({ cache, key }, () => {});\n\n  if (entry === CACHE_EMPTY || shouldRefresh(entry.metadata)) {\n    return;\n  }\n\n  const ttl = entry.metadata.ttl || Infinity;\n  const swr = staleWhileRevalidate(entry.metadata) || 0;\n  const lt = Date.now() - entry.metadata.createdTime;\n\n  await cache.set(\n    key,\n    createCacheEntry(entry.value, {\n      ttl: 0,\n      swr: swrOverwrite === undefined ? ttl + swr : swrOverwrite + lt,\n      createdTime: entry.metadata.createdTime,\n    }),\n  );\n}\n", "const objectToString = Object.prototype.toString;\n\nexport function isUint8Array(value) {\n\treturn value && objectToString.call(value) === '[object Uint8Array]';\n}\n\nexport function assertUint8Array(value) {\n\tif (!isUint8Array(value)) {\n\t\tthrow new TypeError(`Expected \\`Uint8Array\\`, got \\`${typeof value}\\``);\n\t}\n}\n\nexport function toUint8Array(value) {\n\tif (value === null || typeof value !== 'object') {\n\t\tthrow new TypeError(`Unsupported value, got \\`${typeof value}\\`.`);\n\t}\n\n\tif (value instanceof ArrayBuffer) {\n\t\treturn new Uint8Array(value);\n\t}\n\n\tif (ArrayBuffer.isView(value)) {\n\t\t// It's unclear if this is safe and the saving is minuscle.\n\t\t// if (Object.getPrototypeOf(value) === Uint8Array.prototype) {\n\t\t// \treturn value;\n\t\t// }\n\n\t\treturn new Uint8Array(value.buffer, value.byteOffset, value.byteLength);\n\t}\n\n\tthrow new TypeError(`Unsupported value, got \\`${typeof value}\\`.`);\n}\n\nexport function concatUint8Arrays(arrays, totalLength) {\n\tif (arrays.length === 0) {\n\t\treturn new Uint8Array(0);\n\t}\n\n\ttotalLength ??= arrays.reduce((accumulator, currentValue) => accumulator + currentValue.length, 0);\n\n\tconst returnValue = new Uint8Array(totalLength);\n\n\tlet offset = 0;\n\tfor (const array of arrays) {\n\t\tassertUint8Array(array);\n\t\treturnValue.set(array, offset);\n\t\toffset += array.length;\n\t}\n\n\treturn returnValue;\n}\n\nexport function areUint8ArraysEqual(a, b) {\n\tassertUint8Array(a);\n\tassertUint8Array(b);\n\n\tif (a === b) {\n\t\treturn true;\n\t}\n\n\tif (a.length !== b.length) {\n\t\treturn false;\n\t}\n\n\t// eslint-disable-next-line unicorn/no-for-loop\n\tfor (let index = 0; index < a.length; index++) {\n\t\tif (a[index] !== b[index]) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nexport function compareUint8Arrays(a, b) {\n\tassertUint8Array(a);\n\tassertUint8Array(b);\n\n\tconst length = Math.min(a.length, b.length);\n\n\tfor (let index = 0; index < length; index++) {\n\t\tif (a[index] < b[index]) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (a[index] > b[index]) {\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\t// At this point, all the compared elements are equal.\n\t// The shorter array should come first if the arrays are of different lengths.\n\tif (a.length > b.length) {\n\t\treturn 1;\n\t}\n\n\tif (a.length < b.length) {\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nexport function uint8ArrayToString(array) {\n\tassertUint8Array(array);\n\treturn (new globalThis.TextDecoder()).decode(array);\n}\n\nfunction assertString(value) {\n\tif (typeof value !== 'string') {\n\t\tthrow new TypeError(`Expected \\`string\\`, got \\`${typeof value}\\``);\n\t}\n}\n\nexport function stringToUint8Array(string) {\n\tassertString(string);\n\treturn (new globalThis.TextEncoder()).encode(string);\n}\n\nfunction base64ToBase64Url(base64) {\n\treturn base64.replaceAll('+', '-').replaceAll('/', '_').replace(/=+$/, '');\n}\n\nfunction base64UrlToBase64(base64url) {\n\treturn base64url.replaceAll('-', '+').replaceAll('_', '/');\n}\n\nexport function uint8ArrayToBase64(array, {urlSafe = false} = {}) {\n\tassertUint8Array(array);\n\n\t// Required as `btoa` and `atob` don't properly support Unicode: https://developer.mozilla.org/en-US/docs/Glossary/Base64#the_unicode_problem\n\tconst base64 = globalThis.btoa(String.fromCodePoint(...array));\n\n\treturn urlSafe ? base64ToBase64Url(base64) : base64;\n}\n\nexport function base64ToUint8Array(base64String) {\n\tassertString(base64String);\n\treturn Uint8Array.from(globalThis.atob(base64UrlToBase64(base64String)), x => x.codePointAt(0));\n}\n\nexport function stringToBase64(string, {urlSafe = false} = {}) {\n\tassertString(string);\n\treturn uint8ArrayToBase64(stringToUint8Array(string), {urlSafe});\n}\n\nexport function base64ToString(base64String) {\n\tassertString(base64String);\n\treturn uint8ArrayToString(base64ToUint8Array(base64String));\n}\n\nconst byteToHexLookupTable = Array.from({length: 256}, (_, index) => index.toString(16).padStart(2, '0'));\n\nexport function uint8ArrayToHex(array) {\n\tassertUint8Array(array);\n\n\t// Concatenating a string is faster than using an array.\n\tlet hexString = '';\n\n\t// eslint-disable-next-line unicorn/no-for-loop -- Max performance is critical.\n\tfor (let index = 0; index < array.length; index++) {\n\t\thexString += byteToHexLookupTable[array[index]];\n\t}\n\n\treturn hexString;\n}\n\nconst hexToDecimalLookupTable = {\n\t0: 0,\n\t1: 1,\n\t2: 2,\n\t3: 3,\n\t4: 4,\n\t5: 5,\n\t6: 6,\n\t7: 7,\n\t8: 8,\n\t9: 9,\n\ta: 10,\n\tb: 11,\n\tc: 12,\n\td: 13,\n\te: 14,\n\tf: 15,\n\tA: 10,\n\tB: 11,\n\tC: 12,\n\tD: 13,\n\tE: 14,\n\tF: 15,\n};\n\nexport function hexToUint8Array(hexString) {\n\tassertString(hexString);\n\n\tif (hexString.length % 2 !== 0) {\n\t\tthrow new Error('Invalid Hex string length.');\n\t}\n\n\tconst resultLength = hexString.length / 2;\n\tconst bytes = new Uint8Array(resultLength);\n\n\tfor (let index = 0; index < resultLength; index++) {\n\t\tconst highNibble = hexToDecimalLookupTable[hexString[index * 2]];\n\t\tconst lowNibble = hexToDecimalLookupTable[hexString[(index * 2) + 1]];\n\n\t\tif (highNibble === undefined || lowNibble === undefined) {\n\t\t\tthrow new Error(`Invalid Hex character encountered at position ${index * 2}`);\n\t\t}\n\n\t\tbytes[index] = (highNibble << 4) | lowNibble; // eslint-disable-line no-bitwise\n\t}\n\n\treturn bytes;\n}\n", "/**\n * Merge multiple headers objects into one (uses set so headers are overridden)\n */\nexport function mergeHeaders(...headers) {\n    const merged = new Headers();\n    for (const header of headers) {\n        if (!header)\n            continue;\n        for (const [key, value] of new Headers(header).entries()) {\n            merged.set(key, value);\n        }\n    }\n    return merged;\n}\n/**\n * Combine multiple header objects into one (uses append so headers are not overridden)\n */\nexport function combineHeaders(...headers) {\n    const combined = new Headers();\n    for (const header of headers) {\n        if (!header)\n            continue;\n        for (const [key, value] of new Headers(header).entries()) {\n            combined.append(key, value);\n        }\n    }\n    return combined;\n}\n/**\n * Omit a key from an object\n */\nexport function omit(key, obj) {\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    const { [key]: omitted, ...rest } = obj;\n    return rest;\n}\n", "import { base64ToUint8Array, uint8ArrayToString } from 'uint8array-extras';\nimport { mergeHeaders, omit } from './utils.js';\nexport var Strategy;\n(function (Strategy) {\n    /**\n     * Cache first, then network.\n     */\n    Strategy[\"CacheFirst\"] = \"cache-first\";\n    /**\n     * Network first, then cache.\n     */\n    Strategy[\"NetworkFirst\"] = \"network-first\";\n    /**\n     * Cache only, no network.\n     *\n     * @note This is the only strategy that does not use the network. If you have\n     * a use case for this, don't forget to populate the cache yourself.\n     */\n    Strategy[\"CacheOnly\"] = \"cache-only\";\n    /**\n     * Network Only, no caching.\n     *\n     * @note This is the only strategy that does not use the cache. Technically,\n     * if you have a cache that is not persistent, don't use `RemixCache` at all. Just\n     * use `fetch` directly (Remix default behaviour).\n     */\n    Strategy[\"NetworkOnly\"] = \"network-only\";\n    /**\n     * Stale while revalidate.\n     *\n     * @note This strategy will return stale data while fetching fresh data in the background.\n     */\n    Strategy[\"StaleWhileRevalidate\"] = \"stale-while-revalidate\";\n})(Strategy || (Strategy = {}));\nexport class RemixCache {\n    /**\n     * Create a new `RemixCache` instance. Don't invoke this directly! Use `RemixCacheStorage.open()` instead.\n     * @constructor\n     * @param {object} options - Options for the RemixCache instance.\n     */\n    constructor(options) {\n        /**\n         * The time-to-live of the cache in ms.\n         * @readonly\n         * @default Infinity\n         */\n        this._ttl = Infinity;\n        /**\n         * The caching strategy to use. Intended to provide strategies with cachified.\n         * @readonly\n         * @default Strategy.NetworkFirst\n         */\n        this._strategy = Strategy.NetworkFirst;\n        this._maxItems = 100;\n        this.set = false;\n        this.name = options.name;\n        this._maxItems = options.maxItems || 100;\n        this._strategy = options.strategy || Strategy.NetworkFirst;\n        this._ttl = options.ttl || Infinity;\n        if (this._strategy === Strategy.NetworkOnly) {\n            // Don't use the cache at all\n            this._ttl = -1;\n        }\n        // If it is user initiated, set the cache\n        if (options.maxItems || options.ttl || options.strategy) {\n            this.set = true;\n        }\n        else {\n            this.set = false;\n        }\n    }\n    async _openCache() {\n        return await caches.open(`rp-${this.name}`);\n    }\n    async _getOrDeleteIfExpired(key, metadata) {\n        // @ts-ignore\n        if (metadata.expiresAt === 'Infinity') {\n            return false;\n        }\n        if (Number(metadata.expiresAt) <= Date.now()) {\n            return await this.delete(key);\n        }\n        return false;\n    }\n    async _lruCleanup() {\n        const isOverflowing = (await this.length()) >= this._maxItems;\n        if (isOverflowing) {\n            const cache = await this._openCache();\n            const keys = await cache.keys();\n            const values = (await Promise.all(keys.map(key => cache.match(key))));\n            const keyVal = keys.map((key, i) => ({ key, val: values[i] }));\n            const comparableArrayPromise = keyVal.map(async (val) => {\n                const { metadata } = await val.val.clone().json();\n                return {\n                    metadata,\n                    url: val.key.url,\n                };\n            });\n            const comparableArray = await Promise.all(comparableArrayPromise);\n            const sortedArr = comparableArray.sort((a, b) => {\n                return Number(a.metadata.accessedAt) - Number(b.metadata.accessedAt);\n            });\n            const toBeDeletdItems = sortedArr.slice(0, sortedArr.length - this._maxItems + 1);\n            for (const deleted of toBeDeletdItems) {\n                // This runs everytime a new entry is added so that means the array maximum size can never\n                // exceed `maxItems + 1` (the new entry + the maxItems), so we can safely slice the array\n                // to the maxItems length starting from the first index.\n                await this.delete(deleted.url);\n            }\n        }\n    }\n    async _getResponseValue(request, response) {\n        const { metadata, value } = await response.clone().json();\n        const deleted = await this._getOrDeleteIfExpired(request, metadata);\n        const headers = new Headers(response.clone().headers);\n        // Temporary. Need to come up with a method to restore `RemixCache` from the browser's\n        // cache storage ASAP. This is a (*hic*) temporary fix to ensure that the cache is always up to date\n        if (!this.set) {\n            this.set = true;\n            this._ttl = metadata.cacheTtl;\n            this._maxItems = metadata.cacheMaxItems;\n            this._strategy = metadata.cacheStrategy;\n        }\n        const newHeader = new Headers(headers);\n        newHeader.set('X-Remix-PWA-TTL', metadata.expiresAt.toString());\n        newHeader.set('X-Remix-PWA-AccessTime', Date.now().toString());\n        newHeader.set('Content-Type', headers.get('X-Remix-PWA-Original-Content-Type') || 'application/json');\n        const contentType = headers.get('X-Remix-PWA-Original-Content-Type') ?? '';\n        newHeader.delete('X-Remix-PWA-Original-Content-Type');\n        const responseOptions = {\n            status: response.status,\n            statusText: response.statusText,\n            headers: newHeader,\n            body: 'null',\n        };\n        if (contentType.includes('application/json')) {\n            // JSON response\n            responseOptions.body = JSON.stringify(value);\n        }\n        else if (contentType.includes('text')) {\n            // Text response\n            responseOptions.body = value;\n        }\n        else {\n            // Binary or other response types\n            responseOptions.body = base64ToUint8Array(value);\n        }\n        if (!deleted) {\n            const res = new Response(responseOptions.body, omit('body', responseOptions));\n            await this.put(request, res.clone(), undefined);\n            return res;\n        }\n        return undefined;\n    }\n    /**\n     * Delete an entry from the cache.\n     * Takes in the same parameters as `Cache.delete`.\n     * @param {RequestInfo | URL} request - The request to delete.\n     * @param {CacheQueryOptions} [options] - Options for the delete operation.\n     * @returns {Promise<boolean>} Returns `true` if an entry was deleted, otherwise `false`.\n     *\n     * @example\n     * ```js\n     * const cache = await initCache({ name: 'my-cache' });\n     *\n     * await cache.put('/hello-world', new Response('Hello World!'));\n     * await cache.delete('/hello-world');\n     * ```\n     *\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/Cache/delete\n     */\n    async delete(request, options) {\n        return this._openCache().then(cache => cache.delete(request, options));\n    }\n    /**\n     * Returns a Promise that resolves to the length of the Cache object.\n     *\n     * @returns {Promise<number>} The number of entries in the cache.\n     */\n    async length() {\n        const keys = await this.keys();\n        return keys.length;\n    }\n    /**\n     * Returns a `Promise` that resolves to an array of Cache keys.\n     *\n     * @returns {Promise<readonly Request[]>} An array of Cache keys.\n     */\n    async keys() {\n        const cache = await this._openCache();\n        return await cache.keys();\n    }\n    /**\n     * Return a `Promise` that resolves to an entry in the cache object. Accepts the\n     * same parameters as `Cache.match`.\n     *\n     * @param {RequestInfo | URL} request - The request to match.\n     * @param {CacheQueryOptions} [options] - Options for the match operation.\n     *\n     * @returns {Promise<Response | undefined>} A `Promise` that resolves to the response, or `undefined` if not found.\n     */\n    async match(request, options) {\n        const cache = await this._openCache();\n        if (request instanceof URL || typeof request === 'string') {\n            request = new Request(request);\n        }\n        const response = await cache.match(request.clone(), options);\n        if (!response) {\n            return undefined;\n        }\n        return await this._getResponseValue(request, response.clone());\n    }\n    /**\n     * Add an entry to the cache.\n     * Takes in the same parameters as `Cache.put`.\n     *\n     * @param {RequestInfo | URL} request - The request to add.\n     * @param {Response} response - The response to add.\n     * @param {number | undefined} ttl - The time-to-live of the cache entry in ms. Defaults to cache ttl.\n     * @returns {Promise<void>} A `Promise` that resolves when the entry is added to the cache.\n     *\n     * @example\n     * ```js\n     * const cache = await initCache({ name: 'my-cache' });\n     *\n     * await cache.put('/hello-world', new Response('Hello World!'));\n     * ```\n     *\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/Cache/put\n     */\n    async put(request, response, ttl = undefined) {\n        const cache = await this._openCache();\n        if (request instanceof URL || typeof request === 'string') {\n            request = new Request(request);\n        }\n        // If ttl is negative, don't cache\n        if (this._ttl <= 0 || (ttl && ttl <= 0))\n            return;\n        if (response === null || response.status === 204 || response.statusText.toLowerCase() === 'no content') {\n            // If the response/response body is null, delete the entry (if found)\n            // and don't cache.\n            await this.delete(request);\n            return;\n        }\n        const contentType = response.headers.get('Content-Type');\n        let data;\n        if (contentType && contentType.includes('application/json')) {\n            // If the response is JSON, parse it\n            data = await response.clone().json();\n        }\n        else if (contentType && contentType.includes('text')) {\n            // If the response is not JSON, treat it as text\n            data = await response.clone().text();\n        }\n        else {\n            const buffer = await response.clone().arrayBuffer();\n            data = uint8ArrayToString(new Uint8Array(buffer));\n        }\n        // Temporary. Actually slows this process down by an average of 2ms. Not good enough.\n        if (!this.set) {\n            this.set = true;\n            const keys = await cache.keys();\n            const firstVal = await cache.match(keys[0]);\n            if (firstVal) {\n                const { metadata } = await firstVal.clone().json();\n                this._ttl = metadata.cacheTtl;\n                this._maxItems = metadata.cacheMaxItems;\n                this._strategy = metadata.cacheStrategy;\n            }\n            else {\n                this._ttl = Infinity;\n                this._maxItems = 100;\n                this._strategy = Strategy.NetworkFirst;\n            }\n        }\n        const resHeaders = response.headers;\n        const expiresAt = resHeaders.get('X-Remix-PWA-TTL') || Date.now() + (ttl ?? this._ttl);\n        const accessedAt = resHeaders.get('X-Remix-PWA-AccessTime') || Date.now().toString();\n        const newHeaders = new Headers();\n        newHeaders.set('Content-Type', 'application/json');\n        newHeaders.set('X-Remix-PWA-AccessTime', accessedAt);\n        newHeaders.set('X-Remix-PWA-Original-Content-Type', contentType || 'text/plain');\n        newHeaders.set('X-Remix-PWA-TTL', expiresAt.toString());\n        const toBeCachedRes = new Response(JSON.stringify({\n            metadata: {\n                accessedAt,\n                // JSON can't store `Infinity`, so we store it as a string\n                expiresAt: expiresAt.toString(),\n                cacheTtl: this._ttl.toString(),\n                cacheMaxItems: this._maxItems,\n                cacheStrategy: this._strategy,\n            },\n            value: data,\n        }), {\n            status: response.status,\n            statusText: response.statusText,\n            headers: mergeHeaders(resHeaders, newHeaders),\n        });\n        Object.defineProperty(toBeCachedRes, 'url', { value: response.url });\n        Object.defineProperty(toBeCachedRes, 'type', { value: response.type });\n        Object.defineProperty(toBeCachedRes, 'ok', { value: response.ok });\n        Object.defineProperty(toBeCachedRes, 'redirected', { value: response.redirected });\n        // Cache the updated response and maintain the cache\n        try {\n            await this._lruCleanup();\n            return await cache.put(request, toBeCachedRes.clone());\n        }\n        catch (error) {\n            if (process.env.NODE_ENV === 'development')\n                console.error('Failed to put to cache:', error);\n        }\n    }\n    async add(request) {\n        return /* await - should this be awaited? */ fetch(request).then(res => {\n            if (!res.ok) {\n                throw new Error('Failed to fetch');\n            }\n            return this.put(request, res.clone());\n        });\n    }\n    get ttl() {\n        return this._ttl;\n    }\n    get strategy() {\n        return this._strategy;\n    }\n}\n", "import { RemixCache } from './cache.js';\n/**\n * Remix Cache Storage\n *\n * This is a wrapper around the Cache Storage API that allows you to create and manage\n * multiple caches. It also provides a way to check if a request is stored in any of the\n * caches.\n *\n * It is used hand-in-hand with `RemixCache`, a lightweight wrapper around the Cache API that provides\n * a simple interface to store and retrieve data from the cache as well as extra functionalities including\n * cache expiration and cache versioning.\n *\n * This is a static class! You don't need to (_can't_) instantiate it.\n *\n * @alias `Storage`\n *\n * @example\n * ```js\n * import { Storage } from '@remix-run/cache';\n *\n * // Initialize the storage\n * await Storage.init();\n * ```\n */\nexport class RemixCacheStorage {\n    // eslint-disable-next-line no-useless-constructor\n    constructor() { }\n    /**\n     * Initialize the Remix PWA Cache Storage. This will create a special cache for each\n     * existing cache in the browser or create a new map if none exist.\n     *\n     * Use in your service worker installation script. Make sure to call this before\n     * initializing any `RemixCache` instance.\n     *\n     * @example\n     * ```js\n     * import { RemixCacheStorage } from '@remix-run/cache';\n     *\n     * self.addEventListener('install', (event) => {\n     *  event.waitUntil(Promise.all[\n     *   RemixCacheStorage.init(),\n     *   // other stuff\n     *  ]);\n     * });\n     * ```\n     */\n    // static async init() {\n    //   if (typeof caches === 'undefined') {\n    //     throw new Error('Cache API is not available in this environment.');\n    //   }\n    //   if (this._instances.size > 0) {\n    //     return;\n    //   }\n    //   const cachesNames = await caches.keys();\n    //   for (const name of cachesNames) {\n    //     if (name.startsWith('rp-')) {\n    //       this._instances.set(name, new RemixCache({ name }));\n    //     }\n    //   }\n    // }\n    /**\n     * Create a custom cache that you can use across your application.\n     * Use this instead of initialising `RemixCache` directly.\n     */\n    static createCache(opts) {\n        const { name } = opts;\n        if (this._instances.has(name)) {\n            // throw new Error(`A cache with the name '${name}' already exists.`);\n            return this._instances.get(name);\n        }\n        const newCache = new RemixCache(opts);\n        this._instances.set(`${name}`, newCache);\n        caches.open(`rp-${name}`);\n        return newCache;\n    }\n    /**\n     * Check wether a cache with the given name exists.\n     *\n     * @param name\n     */\n    static has(name) {\n        return this._instances.has(name);\n    }\n    static async _get(name) {\n        const cache = this._instances.get(name);\n        if (!cache && (await caches.has(`rp-${name}`))) {\n            this._instances.set(name, new RemixCache({ name }));\n            await this._instances\n                .get(name)\n                ?.keys()\n                .then(keys => {\n                if (keys.length > 0) {\n                    caches.match(keys[0]);\n                }\n            });\n        }\n        return this._instances.get(name);\n    }\n    /**\n     * Get a cache by name. Returns `undefined` if no cache with the given name exists.\n     * Use `has` to check if a cache exists. Or `open` to create one automatically if non exists.\n     *\n     * @param name\n     * @returns {RemixCache | undefined}\n     *\n     * @example\n     * ```js\n     * import { Storage } from '@remix-run/cache';\n     *\n     * const cache = Storage.get('my-cache');\n     * ```\n     */\n    static async get(name) {\n        return await this._get(name);\n    }\n    /**\n     * Get a cache by name. If no cache with the given name exists, create one.\n     *\n     * @param name Name of the cache - **must be unique**\n     * @param opts Options to pass to the `RemixCache` constructor if the cache is getting created\n     * @returns {RemixCache}\n     *\n     * @example\n     * ```js\n     * import { Storage } from '@remix-run/cache';\n     *\n     * const cache = Storage.open('my-cache');\n     * ```\n     */\n    static open(name, opts) {\n        const cache = this._instances.get(name);\n        if (!cache) {\n            return this.createCache({ name, ...opts });\n        }\n        return cache;\n    }\n    /**\n     * Delete a cache by name.\n     *\n     * @param name\n     */\n    static delete(name) {\n        const cache = this._instances.get(name);\n        if (cache) {\n            caches.delete(`rp-${name}`);\n            this._instances.delete(name);\n        }\n    }\n    /**\n     * Delete all caches.\n     */\n    static clear() {\n        caches.keys().then(keys => keys.forEach(key => (key.startsWith('rp-') ? caches.delete(key) : null)));\n        this._instances = new Map();\n    }\n    /**\n     * Get all caches. **Don't use this except you know what you are doing!**\n     *\n     * Which, frankly speaking, you probably don't. So shoo away!\n     */\n    static get instances() {\n        return this._instances;\n    }\n    /**\n     * Get the number of caches.\n     *\n     * Return the length of the `RemixCacheStorage` store.\n     */\n    static get _length() {\n        return this._instances.size;\n    }\n    /**\n     * Check if a request is stored as the key of a response in all caches.\n     *\n     * Experimental. Use at your own risk!\n     *\n     * @param {RequestInfo | URL} request The request to check.\n     * @param {CacheQueryOptions} [options] Options to pass to the `Cache.match` method.\n     * @returns {Promise<Response | undefined>} A promise that resolves to the response if found, otherwise `undefined`.\n     */\n    static _match(request, options) {\n        return caches.match(request, options);\n    }\n}\nRemixCacheStorage._instances = new Map();\n/**\n * @alias `RemixCacheStorage`\n */\nexport const Storage = RemixCacheStorage;\n/**\n * Short-hand for `Storage.createCache()`.\n */\nexport const initCache = (options) => {\n    return Storage.createCache(options);\n};\n/**\n * @alias `initCache`\n */\nexport const createCache = initCache;\n", "/**\n * Returns a promise that resolves and the passed number of milliseconds.\n * This utility is an async/await-friendly version of `setTimeout`.\n *\n * @param {number} ms\n * @return {Promise}\n * @private\n */\nexport function timeout(ms) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n}\n/**\n * Checks if the passed request is an HTTP request.\n *\n * @param {Request | URL} request\n * @return {boolean}\n * @private\n */\nexport const isHttpRequest = (request) => {\n    if (request instanceof Request) {\n        return request.url.startsWith('http');\n    }\n    return request.toString().startsWith('http');\n};\n/**\n * Converts a response to JSON.\n */\nexport const toJSON = async (response) => {\n    if (response instanceof Response) {\n        return await response.clone().json();\n    }\n    return response;\n};\n", "import { Storage } from '@remix-pwa/cache';\nimport { isHttpRequest } from './utils.js';\nexport const cacheFirst = ({ cache: cacheName, cacheOptions, cacheQueryOptions, fetchDidFail = undefined, }) => {\n    return async (request) => {\n        if (!isHttpRequest(request)) {\n            return new Response('Not a HTTP request', { status: 403 });\n        }\n        let remixCache;\n        if (typeof cacheName === 'string') {\n            remixCache = Storage.open(cacheName, cacheOptions);\n        }\n        else {\n            remixCache = cacheName;\n        }\n        const response = await remixCache.match(request, cacheQueryOptions);\n        if (!response) {\n            try {\n                const networkResponse = await fetch(request);\n                remixCache.put(request, networkResponse.clone());\n                return networkResponse;\n            }\n            catch (err) {\n                if (fetchDidFail) {\n                    await Promise.all(fetchDidFail.map(cb => cb()));\n                }\n                throw err;\n            }\n        }\n        return response;\n    };\n};\n", "import { Storage } from '@remix-pwa/cache';\nimport { isHttpRequest } from './utils.js';\nexport const cacheOnly = ({ cache: cacheName, cacheOptions, cacheQueryOptions, }) => {\n    return async (request) => {\n        if (!isHttpRequest(request)) {\n            return new Response('Not a HTTP request', { status: 403 });\n        }\n        let remixCache;\n        if (typeof cacheName === 'string') {\n            remixCache = Storage.open(cacheName, cacheOptions);\n        }\n        else {\n            remixCache = cacheName;\n        }\n        const response = await remixCache.match(request, cacheQueryOptions);\n        if (!response) {\n            // Return this if it is a loader request\n            // const headers = { 'X-Remix-Catch': 'yes', 'X-Remix-Worker': 'yes' };\n            const req = request instanceof Request ? request : new Request(request.toString());\n            const isGet = req.method.toLowerCase() === 'get';\n            return new Response(JSON.stringify({\n                message: isGet ? 'Not Found' : \"No idea what you are trying to accomplish but this ain't it!\",\n            }), {\n                status: isGet ? 404 : 400,\n                statusText: isGet ? 'Not Found' : 'Bad Request',\n            });\n        }\n        return response.clone();\n    };\n};\n", "import { Storage } from '@remix-pwa/cache';\nimport { isHttpRequest } from './utils.js';\nexport const networkFirst = ({ cache: cacheName, cacheOptions, cacheQueryOptions, fetchDidFail = undefined, fetchDidSucceed = undefined, networkTimeoutSeconds = 10, }) => {\n    return async (request) => {\n        if (!isHttpRequest(request)) {\n            return new Response('Not a HTTP request', { status: 403 });\n        }\n        let remixCache;\n        if (typeof cacheName === 'string') {\n            remixCache = Storage.open(cacheName, cacheOptions);\n        }\n        else {\n            remixCache = cacheName;\n        }\n        try {\n            // Much tamer version of the timeout functionality\n            // const timeoutPromise = networkTimeoutSeconds !== Infinity ? timeout(networkTimeoutSeconds * 1000) : null;\n            const timeoutPromise = networkTimeoutSeconds !== Infinity\n                ? new Promise((_resolve, reject) => {\n                    setTimeout(() => {\n                        reject(new Error(`Network timed out after ${networkTimeoutSeconds} seconds`));\n                    }, networkTimeoutSeconds * 1000);\n                })\n                : null;\n            const response = timeoutPromise ? await Promise.race([fetch(request), timeoutPromise]) : await fetch(request);\n            if (response) {\n                if (fetchDidSucceed) {\n                    await Promise.all(fetchDidSucceed.map(cb => cb()));\n                }\n                await remixCache.put(request, response.clone());\n                return response.clone();\n            }\n        }\n        catch (error) {\n            if (fetchDidFail) {\n                await Promise.all(fetchDidFail.map(cb => cb()));\n            }\n            const cachedResponse = await remixCache.match(request, cacheQueryOptions);\n            if (cachedResponse) {\n                return cachedResponse.clone();\n            }\n            return new Response(JSON.stringify({ message: 'Network Error' }), {\n                status: 500,\n            });\n        }\n        throw new Error('Failed to fetch. Network timed out.');\n    };\n};\n", "import { Storage } from '@remix-pwa/cache';\nimport { isHttpRequest } from './utils.js';\nexport const staleWhileRevalidate = ({ cache: cacheName, cacheOptions, cacheQueryOptions, fetchDidFail = undefined, strict = false, swr, }) => {\n    return async (request) => {\n        if (!isHttpRequest(request)) {\n            return new Response('Not a HTTP request', { status: 403 });\n        }\n        let remixCache;\n        if (typeof cacheName === 'string') {\n            remixCache = Storage.open(cacheName, cacheOptions);\n        }\n        else {\n            remixCache = cacheName;\n        }\n        swr = swr ?? remixCache.ttl ?? 0;\n        return remixCache.match(request, cacheQueryOptions).then(async (response) => {\n            const res = response ? response.clone() : undefined;\n            if (res && !strict) {\n                const accessed = Number(res.headers.get('X-Remix-PWA-AccessTime')) ?? 0;\n                if (swr + accessed >= Date.now()) {\n                    return res;\n                }\n            }\n            const fetchPromise = fetch(request)\n                .then(async (networkResponse) => {\n                await remixCache.put(request, networkResponse.clone(), strict ? swr : undefined);\n                return networkResponse;\n            })\n                // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                .catch(async (_err) => {\n                if (fetchDidFail) {\n                    await Promise.all(fetchDidFail.map(cb => cb()));\n                }\n                return new Response(JSON.stringify({ error: 'Network request failed' }), {\n                    status: 500,\n                    statusText: 'Network request failed',\n                });\n            });\n            return response ? response.clone() : fetchPromise;\n        });\n    };\n};\nexport const swr = staleWhileRevalidate;\n", "const methodToColorMap = {\n    debug: `#7f8c8d`,\n    log: `#2ecc71`,\n    info: `#3498db`,\n    warn: `#f39c12`,\n    error: `#c0392b`,\n    groupCollapsed: `#3498db`,\n    groupEnd: null, // No colored prefix on groupEnd\n};\nexport const logger = (process.env.NODE_ENV === 'production'\n    ? (() => {\n        // eslint-disable-next-line @typescript-eslint/ban-types\n        const api = {};\n        const loggerMethods = Object.keys(methodToColorMap);\n        for (const key of loggerMethods) {\n            const method = key;\n            api[method] = () => { };\n        }\n        return api;\n    })()\n    : (() => {\n        // Todo: Add a way to disable logs by default, ig.\n        // This throws an error: `self is not defined`\n        // if (('__DISABLE_PWA_DEBUG_LOGS' in self) == false) {\n        //   self.__DISABLE_PWA_DEBUG_LOGS = false;\n        // }\n        // if (('__DISABLE_PWA_DEV_LOGS' in self) == false) {\n        //   self.__DISABLE_PWA_DEV_LOGS = false;\n        // }\n        // if (('__DISABLE_PWA_DEBUG_LOGS' in self) == false) {\n        //   self.__DISABLE_PWA_DEBUG_LOGS = false;\n        // }\n        // if (('__DISABLE_PWA_INFO_LOGS' in self) == false) {\n        //   self.__DISABLE_PWA_INFO_LOGS = false;\n        // }\n        // if (('__DISABLE_PWA_WARN_LOGS' in self) == false) {\n        //   self.__DISABLE_PWA_WARN_LOGS = false;\n        // }\n        let inGroup = false;\n        const print = function (method, args) {\n            const self = typeof globalThis.self !== 'undefined' ? globalThis.self : globalThis;\n            // Conditionals to handle various log levels.\n            if (self.__DISABLE_PWA_DEV_LOGS) {\n                return;\n            }\n            if (method === 'debug' && self.__DISABLE_PWA_DEBUG_LOGS) {\n                return;\n            }\n            if (method === 'info' && self.__DISABLE_PWA_INFO_LOGS) {\n                return;\n            }\n            if (method === 'warn' && self.__DISABLE_PWA_WARN_LOGS) {\n                return;\n            }\n            if (method === 'error' && self.__DISABLE_PWA_ERROR_LOGS) {\n                return;\n            }\n            if (method === 'groupCollapsed') {\n                // Safari doesn't print all console.groupCollapsed() arguments:\n                // https://bugs.webkit.org/show_bug.cgi?id=182754\n                if (/^((?!chrome|android).)*safari/i.test(navigator.userAgent)) {\n                    console[method](...args);\n                    return;\n                }\n            }\n            const styles = [\n                `background: ${methodToColorMap[method]}`,\n                `border-radius: 0.5em`,\n                `color: white`,\n                `font-weight: bold`,\n                `padding: 2px 0.5em`,\n            ];\n            const logPrefix = inGroup ? [] : ['%cremix-pwa', styles.join(';')];\n            console[method](...logPrefix, ...args);\n            if (method === 'groupCollapsed') {\n                inGroup = true;\n            }\n            if (method === 'groupEnd') {\n                inGroup = false;\n            }\n        };\n        // eslint-disable-next-line @typescript-eslint/ban-types\n        const api = {};\n        const loggerMethods = Object.keys(methodToColorMap);\n        for (const key of loggerMethods) {\n            const method = key;\n            api[method] = (...args) => {\n                print(method, args);\n            };\n        }\n        return api;\n    })());\n", "/**\n * Automatically check the method of a request against a list of methods.\n *\n * @param request The request to check.\n * @param methods The list of methods to check against.\n * @returns Whether the request method is in the list of methods.\n */\nexport function isMethod(request, methods) {\n    return methods.includes(request.method.toLowerCase());\n}\n/**\n * Default checker for asset requests. Determine wether a request is for assets or not.\n *\n * @param request The request to check.\n * @param assetUrls The list of asset urls to check against. Defaults to: `['/build/', '/icons']`\n * @returns Whether the request is for assets or not.\n */\nexport function isAssetRequest(request, assetUrls = ['/build/', '/icons']) {\n    return isMethod(request, ['get']) && assetUrls.some(publicPath => request.url.includes(publicPath));\n}\n/**\n * Default checker for loader requests. Determine wether a request is for loader or not.\n *\n * @param request The request to check.\n * @returns {string | false | null} Whether the request is for loader or not.\n */\nexport function isLoaderRequest(request) {\n    const url = new URL(request.url);\n    return isMethod(request, ['get']) && url.searchParams.get('_data');\n}\nexport const matchRequest = (request, assetUrls = ['/build/', '/icons']) => {\n    if (isAssetRequest(request, assetUrls)) {\n        return 'asset';\n    }\n    else if (isLoaderRequest(request)) {\n        return 'loader';\n    }\n    else {\n        return null;\n    }\n};\n", "export class MessageHandler {\n    /**\n     * The plugins array is used to run plugins before and after the message handler.\n     * They are passed in when the handler is initialised.\n     */\n    plugins;\n    /**\n     * The state object is used to pass data between plugins.\n     */\n    state;\n    constructor({ plugins, state } = {}) {\n        this.plugins = plugins || [];\n        this.state = state || {};\n    }\n    /**\n     * The method that handles the message event.\n     *\n     * Takes in the MessageEvent as a mandatory argument as well as an optional\n     * object that can be used to pass further information/data.\n     */\n    async handle(event, state = {}) {\n        await this._handleMessage(event, state);\n    }\n    /**\n     * Runs the plugins that are passed in when the handler is initialised.\n     */\n    async runPlugins(hook, env) {\n        for (const plugin of this.plugins) {\n            if (plugin[hook]) {\n                plugin[hook](env);\n            }\n        }\n    }\n}\n", "import { Storage } from '@remix-pwa/cache';\nimport { logger } from '../private/logger.js';\nimport { MessageHandler } from './message.js';\nexport class RemixNavigationHandler extends MessageHandler {\n    dataCacheName;\n    documentCacheName;\n    constructor({ dataCache, documentCache, plugins, state }) {\n        super({ plugins, state });\n        this.dataCacheName = dataCache;\n        this.documentCacheName = documentCache;\n        this._handleMessage = this._handleMessage.bind(this);\n    }\n    async _handleMessage(event) {\n        const { data } = event;\n        let dataCache, documentCache;\n        dataCache = this.dataCacheName;\n        documentCache = this.documentCacheName;\n        this.runPlugins('messageDidReceive', {\n            event,\n        });\n        const cachePromises = new Map();\n        if (data.type === 'REMIX_NAVIGATION') {\n            const { isMount, location, manifest, matches } = data;\n            const documentUrl = location.pathname + location.search + location.hash;\n            if (typeof dataCache === 'string') {\n                dataCache = Storage.open(dataCache);\n            }\n            if (typeof documentCache === 'string') {\n                documentCache = Storage.open(documentCache);\n            }\n            const existingDocument = await Storage._match(documentUrl);\n            if (!existingDocument || !isMount) {\n                const response = await fetch(documentUrl);\n                cachePromises.set(documentUrl, documentCache.put(documentUrl, response).catch(error => {\n                    if (process.env.NODE_ENV === 'development')\n                        logger.error(`Failed to cache document for ${documentUrl}:`, error);\n                }));\n            }\n            if (isMount) {\n                for (const match of matches) {\n                    if (manifest.routes[match.id].hasLoader) {\n                        const params = new URLSearchParams(location.search);\n                        params.set('_data', match.id);\n                        let search = params.toString();\n                        search = search ? `?${search}` : '';\n                        const url = location.pathname + search + location.hash;\n                        if (!cachePromises.has(url)) {\n                            if (process.env.NODE_ENV === 'development')\n                                logger.debug('Caching data for:', url);\n                            const response = await fetch(url);\n                            cachePromises.set(url, dataCache.put(url, response).catch(error => {\n                                if (process.env.NODE_ENV === 'development')\n                                    logger.error(`Failed to cache data for ${url}:`, error);\n                            }));\n                        }\n                    }\n                }\n            }\n        }\n        await Promise.all(cachePromises.values());\n    }\n}\n", "/*\n  Copyright 2018 Google LLC\n\n  Attribution: The bloc of this source code is derived from the\n  `workbox-background-sync` plugin, authored by Jeff Posnick and Google Workbox team.\n  We simply replicated the main logic of the plugin and built it natively with Remix PWA.\n\n  The original source code can be found at:\n  https://github.com/GoogleChrome/workbox/blob/v7/packages/workbox-background-sync/src/lib/StorableRequest.ts\n*/\nconst serializableProperties = [\n    'method',\n    'referrer',\n    'referrerPolicy',\n    'mode',\n    'credentials',\n    'cache',\n    'redirect',\n    'integrity',\n    'keepalive',\n];\n/**\n * A class to make it easier to serialize and de-serialize requests so they\n * can be stored in IndexedDB.\n *\n * Most developers will not need to access this class directly;\n * it is exposed for advanced use cases.\n */\nclass StorableRequest {\n    _requestData;\n    /**\n     * Converts a Request object to a plain object that can be structured\n     * cloned or JSON-stringified.\n     *\n     * @param {Request} request\n     * @return {Promise<StorableRequest>}\n     */\n    static async fromRequest(request) {\n        const requestData = {\n            url: request.url,\n            headers: {},\n        };\n        // Set the body if present.\n        if (request.method !== 'GET') {\n            // Use ArrayBuffer to support non-text request bodies.\n            // NOTE: we can't use Blobs becuse Safari doesn't support storing\n            // Blobs in IndexedDB in some cases:\n            // https://github.com/dfahlander/Dexie.js/issues/618#issuecomment-398348457\n            requestData.body = await request.clone().arrayBuffer();\n        }\n        // Convert the headers from an iterable to an object.\n        for (const [key, value] of request.headers.entries()) {\n            requestData.headers[key] = value;\n        }\n        // Add all other serializable request properties\n        for (const prop of serializableProperties) {\n            if (request[prop] !== undefined) {\n                requestData[prop] = request[prop];\n            }\n        }\n        return new StorableRequest(requestData);\n    }\n    /**\n     * Accepts an object of request data that can be used to construct a\n     * `Request` but can also be stored in IndexedDB.\n     *\n     * @param {Object} requestData An object of request data that includes the\n     *     `url` plus any relevant properties of\n     *     [requestInit]{@link https://fetch.spec.whatwg.org/#requestinit}.\n     */\n    constructor(requestData) {\n        // If the request's mode is `navigate`, convert it to `same-origin` since\n        // navigation requests can't be constructed via script.\n        if (requestData.mode === 'navigate') {\n            requestData.mode = 'same-origin';\n        }\n        this._requestData = requestData;\n    }\n    /**\n     * Returns a deep clone of the instances `_requestData` object.\n     *\n     * @return {Object}\n     */\n    toObject() {\n        const requestData = Object.assign({}, this._requestData);\n        requestData.headers = Object.assign({}, this._requestData.headers);\n        if (requestData.body) {\n            requestData.body = requestData.body.slice(0);\n        }\n        return requestData;\n    }\n    /**\n     * Converts this instance to a Request.\n     *\n     * @return {Request}\n     */\n    toRequest() {\n        return new Request(this._requestData.url, this._requestData);\n    }\n    /**\n     * Creates and returns a deep clone of the instance.\n     *\n     * @return {StorableRequest}\n     */\n    clone() {\n        return new StorableRequest(this.toObject());\n    }\n}\nexport { StorableRequest };\n", "const instanceOfAny = (object, constructors) => constructors.some((c) => object instanceof c);\n\nlet idbProxyableTypes;\nlet cursorAdvanceMethods;\n// This is a function to prevent it throwing up in node environments.\nfunction getIdbProxyableTypes() {\n    return (idbProxyableTypes ||\n        (idbProxyableTypes = [\n            IDBDatabase,\n            IDBObjectStore,\n            IDBIndex,\n            IDBCursor,\n            IDBTransaction,\n        ]));\n}\n// This is a function to prevent it throwing up in node environments.\nfunction getCursorAdvanceMethods() {\n    return (cursorAdvanceMethods ||\n        (cursorAdvanceMethods = [\n            IDBCursor.prototype.advance,\n            IDBCursor.prototype.continue,\n            IDBCursor.prototype.continuePrimaryKey,\n        ]));\n}\nconst cursorRequestMap = new WeakMap();\nconst transactionDoneMap = new WeakMap();\nconst transactionStoreNamesMap = new WeakMap();\nconst transformCache = new WeakMap();\nconst reverseTransformCache = new WeakMap();\nfunction promisifyRequest(request) {\n    const promise = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            request.removeEventListener('success', success);\n            request.removeEventListener('error', error);\n        };\n        const success = () => {\n            resolve(wrap(request.result));\n            unlisten();\n        };\n        const error = () => {\n            reject(request.error);\n            unlisten();\n        };\n        request.addEventListener('success', success);\n        request.addEventListener('error', error);\n    });\n    promise\n        .then((value) => {\n        // Since cursoring reuses the IDBRequest (*sigh*), we cache it for later retrieval\n        // (see wrapFunction).\n        if (value instanceof IDBCursor) {\n            cursorRequestMap.set(value, request);\n        }\n        // Catching to avoid \"Uncaught Promise exceptions\"\n    })\n        .catch(() => { });\n    // This mapping exists in reverseTransformCache but doesn't doesn't exist in transformCache. This\n    // is because we create many promises from a single IDBRequest.\n    reverseTransformCache.set(promise, request);\n    return promise;\n}\nfunction cacheDonePromiseForTransaction(tx) {\n    // Early bail if we've already created a done promise for this transaction.\n    if (transactionDoneMap.has(tx))\n        return;\n    const done = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            tx.removeEventListener('complete', complete);\n            tx.removeEventListener('error', error);\n            tx.removeEventListener('abort', error);\n        };\n        const complete = () => {\n            resolve();\n            unlisten();\n        };\n        const error = () => {\n            reject(tx.error || new DOMException('AbortError', 'AbortError'));\n            unlisten();\n        };\n        tx.addEventListener('complete', complete);\n        tx.addEventListener('error', error);\n        tx.addEventListener('abort', error);\n    });\n    // Cache it for later retrieval.\n    transactionDoneMap.set(tx, done);\n}\nlet idbProxyTraps = {\n    get(target, prop, receiver) {\n        if (target instanceof IDBTransaction) {\n            // Special handling for transaction.done.\n            if (prop === 'done')\n                return transactionDoneMap.get(target);\n            // Polyfill for objectStoreNames because of Edge.\n            if (prop === 'objectStoreNames') {\n                return target.objectStoreNames || transactionStoreNamesMap.get(target);\n            }\n            // Make tx.store return the only store in the transaction, or undefined if there are many.\n            if (prop === 'store') {\n                return receiver.objectStoreNames[1]\n                    ? undefined\n                    : receiver.objectStore(receiver.objectStoreNames[0]);\n            }\n        }\n        // Else transform whatever we get back.\n        return wrap(target[prop]);\n    },\n    set(target, prop, value) {\n        target[prop] = value;\n        return true;\n    },\n    has(target, prop) {\n        if (target instanceof IDBTransaction &&\n            (prop === 'done' || prop === 'store')) {\n            return true;\n        }\n        return prop in target;\n    },\n};\nfunction replaceTraps(callback) {\n    idbProxyTraps = callback(idbProxyTraps);\n}\nfunction wrapFunction(func) {\n    // Due to expected object equality (which is enforced by the caching in `wrap`), we\n    // only create one new func per func.\n    // Edge doesn't support objectStoreNames (booo), so we polyfill it here.\n    if (func === IDBDatabase.prototype.transaction &&\n        !('objectStoreNames' in IDBTransaction.prototype)) {\n        return function (storeNames, ...args) {\n            const tx = func.call(unwrap(this), storeNames, ...args);\n            transactionStoreNamesMap.set(tx, storeNames.sort ? storeNames.sort() : [storeNames]);\n            return wrap(tx);\n        };\n    }\n    // Cursor methods are special, as the behaviour is a little more different to standard IDB. In\n    // IDB, you advance the cursor and wait for a new 'success' on the IDBRequest that gave you the\n    // cursor. It's kinda like a promise that can resolve with many values. That doesn't make sense\n    // with real promises, so each advance methods returns a new promise for the cursor object, or\n    // undefined if the end of the cursor has been reached.\n    if (getCursorAdvanceMethods().includes(func)) {\n        return function (...args) {\n            // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n            // the original object.\n            func.apply(unwrap(this), args);\n            return wrap(cursorRequestMap.get(this));\n        };\n    }\n    return function (...args) {\n        // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n        // the original object.\n        return wrap(func.apply(unwrap(this), args));\n    };\n}\nfunction transformCachableValue(value) {\n    if (typeof value === 'function')\n        return wrapFunction(value);\n    // This doesn't return, it just creates a 'done' promise for the transaction,\n    // which is later returned for transaction.done (see idbObjectHandler).\n    if (value instanceof IDBTransaction)\n        cacheDonePromiseForTransaction(value);\n    if (instanceOfAny(value, getIdbProxyableTypes()))\n        return new Proxy(value, idbProxyTraps);\n    // Return the same value back if we're not going to transform it.\n    return value;\n}\nfunction wrap(value) {\n    // We sometimes generate multiple promises from a single IDBRequest (eg when cursoring), because\n    // IDB is weird and a single IDBRequest can yield many responses, so these can't be cached.\n    if (value instanceof IDBRequest)\n        return promisifyRequest(value);\n    // If we've already transformed this value before, reuse the transformed value.\n    // This is faster, but it also provides object equality.\n    if (transformCache.has(value))\n        return transformCache.get(value);\n    const newValue = transformCachableValue(value);\n    // Not all types are transformed.\n    // These may be primitive types, so they can't be WeakMap keys.\n    if (newValue !== value) {\n        transformCache.set(value, newValue);\n        reverseTransformCache.set(newValue, value);\n    }\n    return newValue;\n}\nconst unwrap = (value) => reverseTransformCache.get(value);\n\nexport { reverseTransformCache as a, instanceOfAny as i, replaceTraps as r, unwrap as u, wrap as w };\n", "import { w as wrap, r as replaceTraps } from './wrap-idb-value.js';\nexport { u as unwrap, w as wrap } from './wrap-idb-value.js';\n\n/**\n * Open a database.\n *\n * @param name Name of the database.\n * @param version Schema version.\n * @param callbacks Additional callbacks.\n */\nfunction openDB(name, version, { blocked, upgrade, blocking, terminated } = {}) {\n    const request = indexedDB.open(name, version);\n    const openPromise = wrap(request);\n    if (upgrade) {\n        request.addEventListener('upgradeneeded', (event) => {\n            upgrade(wrap(request.result), event.oldVersion, event.newVersion, wrap(request.transaction), event);\n        });\n    }\n    if (blocked) {\n        request.addEventListener('blocked', (event) => blocked(\n        // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405\n        event.oldVersion, event.newVersion, event));\n    }\n    openPromise\n        .then((db) => {\n        if (terminated)\n            db.addEventListener('close', () => terminated());\n        if (blocking) {\n            db.addEventListener('versionchange', (event) => blocking(event.oldVersion, event.newVersion, event));\n        }\n    })\n        .catch(() => { });\n    return openPromise;\n}\n/**\n * Delete a database.\n *\n * @param name Name of the database.\n */\nfunction deleteDB(name, { blocked } = {}) {\n    const request = indexedDB.deleteDatabase(name);\n    if (blocked) {\n        request.addEventListener('blocked', (event) => blocked(\n        // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405\n        event.oldVersion, event));\n    }\n    return wrap(request).then(() => undefined);\n}\n\nconst readMethods = ['get', 'getKey', 'getAll', 'getAllKeys', 'count'];\nconst writeMethods = ['put', 'add', 'delete', 'clear'];\nconst cachedMethods = new Map();\nfunction getMethod(target, prop) {\n    if (!(target instanceof IDBDatabase &&\n        !(prop in target) &&\n        typeof prop === 'string')) {\n        return;\n    }\n    if (cachedMethods.get(prop))\n        return cachedMethods.get(prop);\n    const targetFuncName = prop.replace(/FromIndex$/, '');\n    const useIndex = prop !== targetFuncName;\n    const isWrite = writeMethods.includes(targetFuncName);\n    if (\n    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.\n    !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) ||\n        !(isWrite || readMethods.includes(targetFuncName))) {\n        return;\n    }\n    const method = async function (storeName, ...args) {\n        // isWrite ? 'readwrite' : undefined gzipps better, but fails in Edge :(\n        const tx = this.transaction(storeName, isWrite ? 'readwrite' : 'readonly');\n        let target = tx.store;\n        if (useIndex)\n            target = target.index(args.shift());\n        // Must reject if op rejects.\n        // If it's a write operation, must reject if tx.done rejects.\n        // Must reject with op rejection first.\n        // Must resolve with op value.\n        // Must handle both promises (no unhandled rejections)\n        return (await Promise.all([\n            target[targetFuncName](...args),\n            isWrite && tx.done,\n        ]))[0];\n    };\n    cachedMethods.set(prop, method);\n    return method;\n}\nreplaceTraps((oldTraps) => ({\n    ...oldTraps,\n    get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),\n    has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop),\n}));\n\nexport { deleteDB, openDB };\n", "/*\n  Copyright 2018 Google LLC\n\n  Attribution: The bloc of this source code is derived from the\n  `workbox-background-sync` plugin, authored by Jeff Posnick and Google Workbox team.\n  We simply replicated the main logic of the plugin and built it natively with Remix PWA.\n\n  The original source code can be found at:\n  https://github.com/GoogleChrome/workbox/blob/v7/packages/workbox-background-sync/src/lib/QueueDb.ts\n*/\nimport { openDB } from 'idb';\nconst DB_VERSION = 3;\nconst DB_NAME = 'remix-pwa-sync';\nconst REQUEST_OBJECT_STORE_NAME = 'failed-requests';\nconst QUEUE_NAME_INDEX = 'queueName';\nexport class QueueDb {\n    _db = null;\n    /**\n     * Add QueueStoreEntry to underlying db.\n     *\n     * @param {UnidentifiedQueueStoreEntry} entry\n     */\n    async addEntry(entry) {\n        const db = await this.getDb();\n        const tx = db.transaction(REQUEST_OBJECT_STORE_NAME, 'readwrite', {\n            durability: 'relaxed',\n        });\n        await tx.store.add(entry);\n        await tx.done;\n    }\n    /**\n     * Returns the first entry id in the ObjectStore.\n     *\n     * @return {number | undefined}\n     */\n    async getFirstEntryId() {\n        const db = await this.getDb();\n        const cursor = await db.transaction(REQUEST_OBJECT_STORE_NAME).store.openCursor();\n        return cursor?.value.id;\n    }\n    /**\n     * Get all the entries filtered by index\n     *\n     * @param queueName\n     * @return {Promise<QueueStoreEntry[]>}\n     */\n    async getAllEntriesByQueueName(queueName) {\n        const db = await this.getDb();\n        const results = await db.getAllFromIndex(REQUEST_OBJECT_STORE_NAME, QUEUE_NAME_INDEX, IDBKeyRange.only(queueName));\n        return results || new Array();\n    }\n    /**\n     * Returns the number of entries filtered by index\n     *\n     * @param queueName\n     * @return {Promise<number>}\n     */\n    async getEntryCountByQueueName(queueName) {\n        const db = await this.getDb();\n        return db.countFromIndex(REQUEST_OBJECT_STORE_NAME, QUEUE_NAME_INDEX, IDBKeyRange.only(queueName));\n    }\n    /**\n     * Deletes a single entry by id.\n     *\n     * @param {number} id the id of the entry to be deleted\n     */\n    async deleteEntry(id) {\n        const db = await this.getDb();\n        await db.delete(REQUEST_OBJECT_STORE_NAME, id);\n    }\n    /**\n     *\n     * @param queueName\n     * @returns {Promise<QueueStoreEntry | undefined>}\n     */\n    async getFirstEntryByQueueName(queueName) {\n        return await this.getEndEntryFromIndex(IDBKeyRange.only(queueName), 'next');\n    }\n    /**\n     *\n     * @param queueName\n     * @returns {Promise<QueueStoreEntry | undefined>}\n     */\n    async getLastEntryByQueueName(queueName) {\n        return await this.getEndEntryFromIndex(IDBKeyRange.only(queueName), 'prev');\n    }\n    /**\n     * Returns either the first or the last entries, depending on direction.\n     * Filtered by index.\n     *\n     * @param {IDBCursorDirection} direction\n     * @param {IDBKeyRange} query\n     * @return {Promise<QueueStoreEntry | undefined>}\n     * @private\n     */\n    async getEndEntryFromIndex(query, direction) {\n        const db = await this.getDb();\n        const cursor = await db\n            .transaction(REQUEST_OBJECT_STORE_NAME)\n            .store.index(QUEUE_NAME_INDEX)\n            .openCursor(query, direction);\n        return cursor?.value;\n    }\n    /**\n     * Returns an open connection to the database.\n     *\n     * @private\n     */\n    async getDb() {\n        if (!this._db) {\n            this._db = await openDB(DB_NAME, DB_VERSION, {\n                upgrade: this._upgradeDb,\n            });\n        }\n        return this._db;\n    }\n    /**\n     * Upgrades QueueDB\n     *\n     * @param {IDBPDatabase<QueueDBSchema>} db\n     * @param {number} oldVersion\n     * @private\n     */\n    _upgradeDb(db, oldVersion) {\n        if (oldVersion > 0 && oldVersion < DB_VERSION) {\n            if (db.objectStoreNames.contains(REQUEST_OBJECT_STORE_NAME)) {\n                db.deleteObjectStore(REQUEST_OBJECT_STORE_NAME);\n            }\n        }\n        const objStore = db.createObjectStore(REQUEST_OBJECT_STORE_NAME, {\n            autoIncrement: true,\n            keyPath: 'id',\n        });\n        objStore.createIndex(QUEUE_NAME_INDEX, QUEUE_NAME_INDEX, { unique: false });\n    }\n}\n", "/*\n  Copyright 2018 Google LLC\n\n  Attribution: The bloc of this source code is derived from the\n  `workbox-background-sync` plugin, authored by Jeff Posnick and Google Workbox team.\n  We simply replicated the main logic of the plugin and built it natively with Remix PWA.\n\n  The original source code can be found at:\n  https://github.com/GoogleChrome/workbox/blob/v7/packages/workbox-background-sync/src/lib/QueueStore.ts\n*/\nimport { QueueDb } from './db.js';\n/**\n * A class to manage storing requests from a Queue in IndexedDB,\n * indexed by their queue name for easier access.\n *\n * Most developers will not need to access this class directly;\n * it is exposed for advanced use cases.\n */\nexport class QueueStore {\n    _queueName;\n    _queueDb;\n    /**\n     * Associates this instance with a Queue instance, so entries added can be\n     * identified by their queue name.\n     *\n     * @param {string} queueName\n     */\n    constructor(queueName) {\n        this._queueName = queueName;\n        this._queueDb = new QueueDb();\n    }\n    /**\n     * Append an entry last in the queue.\n     *\n     * @param {Object} entry\n     * @param {Object} entry.requestData\n     * @param {number} [entry.timestamp]\n     * @param {Object} [entry.metadata]\n     */\n    async pushEntry(entry) {\n        // Don't specify an ID since one is automatically generated.\n        delete entry.id;\n        entry.queueName = this._queueName;\n        await this._queueDb.addEntry(entry);\n    }\n    /**\n     * Prepend an entry first in the queue.\n     *\n     * @param {Object} entry\n     * @param {Object} entry.requestData\n     * @param {number} [entry.timestamp]\n     * @param {Object} [entry.metadata]\n     */\n    async unshiftEntry(entry) {\n        const firstId = await this._queueDb.getFirstEntryId();\n        if (firstId) {\n            // Pick an ID one less than the lowest ID in the object store.\n            entry.id = firstId - 1;\n        }\n        else {\n            // Otherwise let the auto-incrementor assign the ID.\n            delete entry.id;\n        }\n        entry.queueName = this._queueName;\n        await this._queueDb.addEntry(entry);\n    }\n    /**\n     * Removes and returns the last entry in the queue matching the `queueName`.\n     *\n     * @return {Promise<QueueStoreEntry|undefined>}\n     */\n    async popEntry() {\n        return this._removeEntry(await this._queueDb.getLastEntryByQueueName(this._queueName));\n    }\n    /**\n     * Removes and returns the first entry in the queue matching the `queueName`.\n     *\n     * @return {Promise<QueueStoreEntry|undefined>}\n     */\n    async shiftEntry() {\n        return this._removeEntry(await this._queueDb.getFirstEntryByQueueName(this._queueName));\n    }\n    /**\n     * Returns all entries in the store matching the `queueName`.\n     *\n     * @param {Object} options See {@link workbox-background-sync.Queue~getAll}\n     * @return {Promise<Array<Object>>}\n     */\n    async getAll() {\n        return await this._queueDb.getAllEntriesByQueueName(this._queueName);\n    }\n    /**\n     * Returns the number of entries in the store matching the `queueName`.\n     *\n     * @param {Object} options See {@link workbox-background-sync.Queue~size}\n     * @return {Promise<number>}\n     */\n    async size() {\n        return await this._queueDb.getEntryCountByQueueName(this._queueName);\n    }\n    /**\n     * Deletes the entry for the given ID.\n     *\n     * WARNING: this method does not ensure the deleted entry belongs to this\n     * queue (i.e. matches the `queueName`). But this limitation is acceptable\n     * as this class is not publicly exposed. An additional check would make\n     * this method slower than it needs to be.\n     *\n     * @param {number} id\n     */\n    async deleteEntry(id) {\n        await this._queueDb.deleteEntry(id);\n    }\n    /**\n     * Removes and returns the first or last entry in the queue (based on the\n     * `direction` argument) matching the `queueName`.\n     *\n     * @return {Promise<QueueStoreEntry|undefined>}\n     * @private\n     */\n    async _removeEntry(entry) {\n        if (entry) {\n            await this.deleteEntry(entry.id);\n        }\n        return entry;\n    }\n}\n", "/*\n  Copyright 2018 Google LLC\n\n  Attribution: The bloc of this source code is derived from the\n  `workbox-background-sync` plugin, authored by Jeff Posnick and Google Workbox team.\n  We simply replicated the main logic of the plugin and built it natively with Remix PWA.\n\n  The original source code can be found at:\n  https://github.com/GoogleChrome/workbox/blob/v7/packages/workbox-background-sync/src/Queue.ts\n*/\nimport { StorableRequest } from './request.js';\nimport { QueueStore } from './store.js';\nconst TAG_PREFIX = 'rp-sync';\nconst MAX_RETENTION_TIME = 60 * 24 * 7; // 7 days\nconst queueNames = new Set();\n/**\n * Converts a QueueStore entry into the format exposed by Queue. This entails\n * converting the request data into a real request and omitting the `id` and\n * `queueName` properties.\n *\n * @param {UnidentifiedQueueStoreEntry} queueStoreEntry\n * @return {Queue}\n * @private\n */\nconst convertEntry = (queueStoreEntry) => {\n    const queueEntry = {\n        request: new StorableRequest(queueStoreEntry.requestData).toRequest(),\n        timestamp: queueStoreEntry.timestamp,\n    };\n    if (queueStoreEntry.metadata) {\n        queueEntry.metadata = queueStoreEntry.metadata;\n    }\n    return queueEntry;\n};\n/**\n * A class to manage storing failed requests in IndexedDB and retrying them\n * later. All parts of the storing and replaying process are observable via\n * callbacks.\n *\n * @memberof workbox-background-sync\n */\nclass Queue {\n    _name;\n    _onSync;\n    _maxRetentionTime;\n    _queueStore;\n    _syncInProgress = false;\n    _requestsAddedDuringSync = false;\n    /**\n     * Creates an instance of Queue with the given options\n     *\n     * @param {string} name The unique name for this queue. This name must be\n     *     unique as it's used to register sync events and store requests\n     *     in IndexedDB specific to this instance. An error will be thrown if\n     *     a duplicate name is detected.\n     * @param {Object} [options]\n     * @param {Function} [options.onSync] A function that gets invoked whenever\n     *     the 'sync' event fires. The function is invoked with an object\n     *     containing the `queue` property (referencing this instance), and you\n     *     can use the callback to customize the replay behavior of the queue.\n     *     When not set the `replayRequests()` method is called.\n     *     Note: if the replay fails after a sync event, make sure you throw an\n     *     error, so the browser knows to retry the sync event later.\n     * @param {number} [options.maxRetentionTime=7 days] The amount of time (in\n     *     minutes) a request may be retried. After this amount of time has\n     *     passed, the request will be deleted from the queue.\n     */\n    constructor(name, { maxRetentionTime, onSync } = {}) {\n        this._name = name;\n        this._onSync = onSync || this.replayRequests;\n        this._maxRetentionTime = maxRetentionTime || MAX_RETENTION_TIME;\n        this._queueStore = new QueueStore(this._name);\n        this._addSyncListener();\n    }\n    /**\n     * @return {string}\n     */\n    get name() {\n        return this._name;\n    }\n    /**\n     * Stores the passed request in IndexedDB (with its timestamp and any\n     * metadata) at the end of the queue.\n     *\n     * @param {QueueEntry} entry\n     * @param {Request} entry.request The request to store in the queue.\n     * @param {Object} [entry.metadata] Any metadata you want associated with the\n     *     stored request. When requests are replayed you'll have access to this\n     *     metadata object in case you need to modify the request beforehand.\n     * @param {number} [entry.timestamp] The timestamp (Epoch time in\n     *     milliseconds) when the request was first added to the queue. This is\n     *     used along with `maxRetentionTime` to remove outdated requests. In\n     *     general you don't need to set this value, as it's automatically set\n     *     for you (defaulting to `Date.now()`), but you can update it if you\n     *     don't want particular requests to expire.\n     */\n    async pushRequest(entry) {\n        await this._addRequest(entry, 'push');\n    }\n    /**\n     * Stores the passed request in IndexedDB (with its timestamp and any\n     * metadata) at the beginning of the queue.\n     *\n     * @param {QueueEntry} entry\n     * @param {Request} entry.request The request to store in the queue.\n     * @param {Object} [entry.metadata] Any metadata you want associated with the\n     *     stored request. When requests are replayed you'll have access to this\n     *     metadata object in case you need to modify the request beforehand.\n     * @param {number} [entry.timestamp] The timestamp (Epoch time in\n     *     milliseconds) when the request was first added to the queue. This is\n     *     used along with `maxRetentionTime` to remove outdated requests. In\n     *     general you don't need to set this value, as it's automatically set\n     *     for you (defaulting to `Date.now()`), but you can update it if you\n     *     don't want particular requests to expire.\n     */\n    async unshiftRequest(entry) {\n        await this._addRequest(entry, 'unshift');\n    }\n    /**\n     * Removes and returns the last request in the queue (along with its\n     * timestamp and any metadata). The returned object takes the form:\n     * `{request, timestamp, metadata}`.\n     *\n     * @return {Promise<QueueEntry | undefined>}\n     */\n    async popRequest() {\n        return this._removeRequest('pop');\n    }\n    /**\n     * Removes and returns the first request in the queue (along with its\n     * timestamp and any metadata). The returned object takes the form:\n     * `{request, timestamp, metadata}`.\n     *\n     * @return {Promise<QueueEntry | undefined>}\n     */\n    async shiftRequest() {\n        return this._removeRequest('shift');\n    }\n    /**\n     * Returns all the entries that have not expired (per `maxRetentionTime`).\n     * Any expired entries are removed from the queue.\n     *\n     * @return {Promise<Array<QueueEntry>>}\n     */\n    async getAll() {\n        const allEntries = await this._queueStore.getAll();\n        const now = Date.now();\n        const unexpiredEntries = [];\n        for (const entry of allEntries) {\n            // Ignore requests older than maxRetentionTime. Call this function\n            // recursively until an unexpired request is found.\n            const maxRetentionTimeInMs = this._maxRetentionTime * 60 * 1000;\n            if (now - entry.timestamp > maxRetentionTimeInMs) {\n                await this._queueStore.deleteEntry(entry.id);\n            }\n            else {\n                unexpiredEntries.push(convertEntry(entry));\n            }\n        }\n        return unexpiredEntries;\n    }\n    /**\n     * Returns the number of entries present in the queue.\n     * Note that expired entries (per `maxRetentionTime`) are also included in this count.\n     *\n     * @return {Promise<number>}\n     */\n    async size() {\n        return await this._queueStore.size();\n    }\n    /**\n     * Adds the entry to the QueueStore and registers for a sync event.\n     *\n     * @param {Object} entry\n     * @param {Request} entry.request\n     * @param {Object} [entry.metadata]\n     * @param {number} [entry.timestamp=Date.now()]\n     * @param {string} operation ('push' or 'unshift')\n     * @private\n     */\n    async _addRequest({ metadata, request, timestamp = Date.now() }, operation) {\n        const storableRequest = await StorableRequest.fromRequest(request.clone());\n        const entry = {\n            requestData: storableRequest.toObject(),\n            timestamp,\n        };\n        // Only include metadata if it's present.\n        if (metadata) {\n            entry.metadata = metadata;\n        }\n        switch (operation) {\n            case 'push':\n                await this._queueStore.pushEntry(entry);\n                break;\n            case 'unshift':\n                await this._queueStore.unshiftEntry(entry);\n                break;\n        }\n        if (process.env.NODE_ENV !== 'production') {\n            // logger.log(\n            //   `Request for '${getFriendlyURL(request.url)}' has ` + `been added to background sync queue '${this._name}'.`\n            // );\n        }\n        // Don't register for a sync if we're in the middle of a sync. Instead,\n        // we wait until the sync is complete and call register if\n        // `this._requestsAddedDuringSync` is true.\n        if (this._syncInProgress) {\n            this._requestsAddedDuringSync = true;\n        }\n        else {\n            await this.registerSync();\n        }\n    }\n    /**\n     * Removes and returns the first or last (depending on `operation`) entry\n     * from the QueueStore that's not older than the `maxRetentionTime`.\n     *\n     * @param {string} operation ('pop' or 'shift')\n     * @return {Object|undefined}\n     * @private\n     */\n    async _removeRequest(operation) {\n        const now = Date.now();\n        let entry;\n        switch (operation) {\n            case 'pop':\n                entry = await this._queueStore.popEntry();\n                break;\n            case 'shift':\n                entry = await this._queueStore.shiftEntry();\n                break;\n        }\n        if (entry) {\n            // Ignore requests older than maxRetentionTime. Call this function\n            // recursively until an unexpired request is found.\n            const maxRetentionTimeInMs = this._maxRetentionTime * 60 * 1000;\n            if (now - entry.timestamp > maxRetentionTimeInMs) {\n                return this._removeRequest(operation);\n            }\n            return convertEntry(entry);\n        }\n        else {\n            return undefined;\n        }\n    }\n    /**\n     * Loops through each request in the queue and attempts to re-fetch it.\n     * If any request fails to re-fetch, it's put back in the same position in\n     * the queue (which registers a retry for the next sync event).\n     */\n    async replayRequests() {\n        let entry;\n        while ((entry = await this.shiftRequest())) {\n            try {\n                await fetch(entry.request.clone());\n                if (process.env.NODE_ENV !== 'production') {\n                    // logger.log(\n                    //   `Request for '${getFriendlyURL(entry.request.url)}' ` + `has been replayed in queue '${this._name}'`\n                    // );\n                }\n            }\n            catch (error) {\n                await this.unshiftRequest(entry);\n                if (process.env.NODE_ENV !== 'production') {\n                    // logger.log(\n                    //   `Request for '${getFriendlyURL(entry.request.url)}' ` +\n                    //     `failed to replay, putting it back in queue '${this._name}'`\n                    // );\n                }\n                // throw new Error('queue-replay-failed', { name: this._name });\n            }\n        }\n        if (process.env.NODE_ENV !== 'production') {\n            // logger.log(`All requests in queue '${this.name}' have successfully ` + `replayed; the queue is now empty!`);\n        }\n    }\n    /**\n     * Registers a sync event with a tag unique to this instance.\n     */\n    async registerSync() {\n        // See https://github.com/GoogleChrome/workbox/issues/2393\n        if ('sync' in self.registration) {\n            try {\n                await self.registration.sync.register(`${TAG_PREFIX}:${this._name}`);\n            }\n            catch (err) {\n                // This means the registration failed for some reason, possibly due to\n                // the user disabling it.\n                // if (process.env.NODE_ENV !== 'production') {\n                //   logger.warn(`Unable to register sync event for '${this._name}'.`, err);\n                // }\n            }\n        }\n    }\n    /**\n     * In sync-supporting browsers, this adds a listener for the sync event.\n     * In non-sync-supporting browsers, or if _forceSyncFallback is true, this\n     * will retry the queue on service worker startup.\n     *\n     * @private\n     */\n    _addSyncListener() {\n        // See https://github.com/GoogleChrome/workbox/issues/2393\n        if ('sync' in self.registration) {\n            self.addEventListener('sync', (event) => {\n                if (event.tag === `${TAG_PREFIX}:${this._name}`) {\n                    // if (process.env.NODE_ENV !== 'production') {\n                    //   logger.log(`Background sync for tag '${event.tag}' ` + `has been received`);\n                    // }\n                    const syncComplete = async () => {\n                        this._syncInProgress = true;\n                        let syncError;\n                        try {\n                            await this._onSync({ queue: this });\n                        }\n                        catch (error) {\n                            if (error instanceof Error) {\n                                syncError = error;\n                                // Rethrow the error. Note: the logic in the finally clause\n                                // will run before this gets rethrown.\n                                throw syncError;\n                            }\n                        }\n                        finally {\n                            // New items may have been added to the queue during the sync,\n                            // so we need to register for a new sync if that's happened...\n                            // Unless there was an error during the sync, in which\n                            // case the browser will automatically retry later, as long\n                            // as `event.lastChance` is not true.\n                            if (this._requestsAddedDuringSync && !(syncError && !event.lastChance)) {\n                                await this.registerSync();\n                            }\n                            this._syncInProgress = false;\n                            this._requestsAddedDuringSync = false;\n                        }\n                    };\n                    event.waitUntil(syncComplete());\n                }\n            });\n        }\n        else {\n            // if (process.env.NODE_ENV !== 'production') {\n            //   logger.log(`Background sync replaying without background sync event`);\n            // }\n            // If the browser doesn't support background sync, or the developer has\n            // opted-in to not using it, retry every time the service worker starts up\n            // as a fallback.\n            // eslint-disable-next-line no-void\n            void this._onSync({ queue: this });\n        }\n    }\n    /**\n     * Returns the set of queue names. This is primarily used to reset the list\n     * of queue names in tests.\n     *\n     * @return {Set<string>}\n     *\n     * @private\n     */\n    static get _queueNames() {\n        return queueNames;\n    }\n}\nexport { Queue };\n", "import { Queue } from './queue.js';\nclass SyncQueue {\n    static queues = new Map();\n    static createQueue(name) {\n        if (this.queues.has(name)) {\n            throw new Error(`Queue \"${name}\" already exists`);\n        }\n        const _q = new Queue(name);\n        this.queues.set(name, _q);\n        return _q;\n    }\n    static getQueue(name) {\n        return this.queues.get(name);\n    }\n    static removeQueue(name) {\n        this.queues.delete(name);\n    }\n    static async getQueueNames() {\n        return Array.from(this.queues.keys());\n    }\n    static async getQueueSizes() {\n        const sizes = new Map();\n        for (const [name, queue] of this.queues) {\n            sizes.set(name, await queue.size());\n        }\n        return sizes;\n    }\n    /* WIP */ async getQueueByTag(tag) {\n        for (const [name, queue] of new Map()) {\n            if (name === tag) {\n                return queue;\n            }\n        }\n        return undefined;\n    }\n}\n/**\n * This function is similar to `fetchFromServer` in that it would fetch a request\n * from it's respective server action, but instead of just throwing an error if it fails,\n * it would queue the request to be retried later on.\n *\n * @param {QueueToServerOptions} options\n */\nexport const queueToServer = ({ name, request }) => {\n    let queue;\n    // Todo: Remove this. Enforce `registerQueue` to be called first in your entry worker file.\n    try {\n        queue = SyncQueue.createQueue(name);\n    }\n    catch (e) {\n        queue = SyncQueue.getQueue(name);\n    }\n    queue.pushRequest({ request: request });\n};\n/**\n * Create a `Queue` to handle syncing for a particular tag. This is useful for grouping\n * requests together to be retried later on.\n *\n * Make sure to place this function in your entry worker file (e.g. `entry.worker.ts`).\n * @param {string} name\n */\nexport const registerQueue = (name) => {\n    SyncQueue.createQueue(name);\n};\n/**\n * Alias for `registerQueue`.\n * @param {string} name\n * @returns {void}\n * @see registerQueue\n */\nexport const registerSync = registerQueue;\n/**\n * Create multiple `Queue`s to handle syncing for tags. This is a useful short-hand\n * for `registerQueue` with multiple tags.\n *\n * Make sure to place this function in your entry worker file (e.g. `entry.worker.ts`).\n *\n * @param {string[]} names\n */\nexport const registerAllQueues = (names) => {\n    for (const name of names) {\n        SyncQueue.createQueue(name);\n    }\n};\n/**\n * Alias for `registerAllQueues`.\n * @param {string[]} names\n * @returns {void}\n * @see registerAllQueues\n */\nexport const registerAllSyncs = registerAllQueues;\n", "declare var global;\nexport const _global: any =\n    typeof globalThis !== 'undefined' ? globalThis :\n    typeof self !== 'undefined' ? self :\n    typeof window !== 'undefined' ? window :\n    global;\n", "﻿import { _global } from \"../globals/global\";\nexport const keys = Object.keys;\nexport const isArray = Array.isArray;\nif (typeof Promise !== 'undefined' && !_global.Promise){\n    // In jsdom, this it can be the case that Promise is not put on the global object.\n    // If so, we need to patch the global object for the rest of the code to work as expected.\n    // Other dexie code expects Promise to be on the global object (like normal browser environments)\n    _global.Promise = Promise;\n}\nexport { _global }\n\nexport function extend<T extends object,X extends object>(obj: T, extension: X): T & X  {\n    if (typeof extension !== 'object') return obj as T & X;\n    keys(extension).forEach(function (key) {\n        obj[key] = extension[key];\n    });\n    return obj as T & X;\n}\n\nexport const getProto = Object.getPrototypeOf;\nexport const _hasOwn = {}.hasOwnProperty;\nexport function hasOwn(obj, prop) {\n    return _hasOwn.call(obj, prop);\n}\n\nexport function props (proto, extension) {\n    if (typeof extension === 'function') extension = extension(getProto(proto));\n    (typeof Reflect === \"undefined\" ? keys : Reflect.ownKeys)(extension).forEach(key => {\n        setProp(proto, key, extension[key]);\n    });\n}\n\nexport const defineProperty = Object.defineProperty;\n\nexport function setProp(obj, prop, functionOrGetSet, options?) {\n    defineProperty(obj, prop, extend(functionOrGetSet && hasOwn(functionOrGetSet, \"get\") && typeof functionOrGetSet.get === 'function' ?\n        {get: functionOrGetSet.get, set: functionOrGetSet.set, configurable: true} :\n        {value: functionOrGetSet, configurable: true, writable: true}, options));\n}\n\nexport function derive(Child) {\n    return {\n        from: function (Parent) {\n            Child.prototype = Object.create(Parent.prototype);\n            setProp(Child.prototype, \"constructor\", Child);\n            return {\n                extend: props.bind(null, Child.prototype)\n            };\n        }\n    };\n}\n\nexport const getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n\nexport function getPropertyDescriptor(obj, prop) {\n    const pd = getOwnPropertyDescriptor(obj, prop);\n    let proto;\n    return pd || (proto = getProto(obj)) && getPropertyDescriptor (proto, prop);\n}\n\nconst _slice = [].slice;\nexport function slice(args, start?, end?) {\n    return _slice.call(args, start, end);\n}\n\nexport function override(origFunc, overridedFactory) {\n    return overridedFactory(origFunc);\n}\n\nexport function assert (b) {\n    if (!b) throw new Error(\"Assertion Failed\");\n}\n\nexport function asap(fn) {\n    // @ts-ignore\n    if (_global.setImmediate) setImmediate(fn); else setTimeout(fn, 0);\n}\n\nexport function getUniqueArray(a) {\n    return a.filter((value, index, self) => self.indexOf(value) === index);\n}\n\n/** Generate an object (hash map) based on given array.\n * @param extractor Function taking an array item and its index and returning an array of 2 items ([key, value]) to\n *        instert on the resulting object for each item in the array. If this function returns a falsy value, the\n *        current item wont affect the resulting object.\n */\nexport function arrayToObject<T,R> (array: T[], extractor: (x:T, idx: number)=>[string, R]): {[name: string]: R} {\n    return array.reduce((result, item, i) => {\n        var nameAndValue = extractor(item, i);\n        if (nameAndValue) result[nameAndValue[0]] = nameAndValue[1];\n        return result;\n    }, {});\n}\n\nexport function trycatcher(fn, reject) {\n    return function () {\n        try {\n            fn.apply(this, arguments);\n        } catch (e) {\n            reject(e);\n        }\n    };\n}\n\nexport function tryCatch(fn: (...args: any[])=>void, onerror, args?) : void {\n    try {\n        fn.apply(null, args);\n    } catch (ex) {\n        onerror && onerror(ex);\n    }\n}\n\nexport function getByKeyPath(obj, keyPath) {\n    // http://www.w3.org/TR/IndexedDB/#steps-for-extracting-a-key-from-a-value-using-a-key-path\n    if (hasOwn(obj, keyPath)) return obj[keyPath]; // This line is moved from last to first for optimization purpose.\n    if (!keyPath) return obj;\n    if (typeof keyPath !== 'string') {\n        var rv = [];\n        for (var i = 0, l = keyPath.length; i < l; ++i) {\n            var val = getByKeyPath(obj, keyPath[i]);\n            rv.push(val);\n        }\n        return rv;\n    }\n    var period = keyPath.indexOf('.');\n    if (period !== -1) {\n        var innerObj = obj[keyPath.substr(0, period)];\n        return innerObj === undefined ? undefined : getByKeyPath(innerObj, keyPath.substr(period + 1));\n    }\n    return undefined;\n}\n\nexport function setByKeyPath(obj, keyPath, value) {\n    if (!obj || keyPath === undefined) return;\n    if ('isFrozen' in Object && Object.isFrozen(obj)) return;\n    if (typeof keyPath !== 'string' && 'length' in keyPath) {\n        assert(typeof value !== 'string' && 'length' in value);\n        for (var i = 0, l = keyPath.length; i < l; ++i) {\n            setByKeyPath(obj, keyPath[i], value[i]);\n        }\n    } else {\n        var period = keyPath.indexOf('.');\n        if (period !== -1) {\n            var currentKeyPath = keyPath.substr(0, period);\n            var remainingKeyPath = keyPath.substr(period + 1);\n            if (remainingKeyPath === \"\")\n                if (value === undefined) {\n                    if (isArray(obj) && !isNaN(parseInt(currentKeyPath))) obj.splice(currentKeyPath, 1);\n                    else delete obj[currentKeyPath];\n                } else obj[currentKeyPath] = value;\n            else {\n                var innerObj = obj[currentKeyPath];\n                if (!innerObj || !hasOwn(obj, currentKeyPath)) innerObj = (obj[currentKeyPath] = {});\n                setByKeyPath(innerObj, remainingKeyPath, value);\n            }\n        } else {\n            if (value === undefined) {\n                if (isArray(obj) && !isNaN(parseInt(keyPath))) obj.splice(keyPath, 1);\n                else delete obj[keyPath];\n            } else obj[keyPath] = value;\n        }\n    }\n}\n\nexport function delByKeyPath(obj, keyPath) {\n    if (typeof keyPath === 'string')\n        setByKeyPath(obj, keyPath, undefined);\n    else if ('length' in keyPath)\n        [].map.call(keyPath, function(kp) {\n            setByKeyPath(obj, kp, undefined);\n        });\n}\n\nexport function shallowClone(obj) {\n    var rv = {};\n    for (var m in obj) {\n        if (hasOwn(obj, m)) rv[m] = obj[m];\n    }\n    return rv;\n}\n\nconst concat = [].concat;\nexport function flatten<T> (a: (T | T[])[]) : T[] {\n    return concat.apply([], a);\n}\n\n//https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm\nconst intrinsicTypeNames =\n    \"Boolean,String,Date,RegExp,Blob,File,FileList,FileSystemFileHandle,ArrayBuffer,DataView,Uint8ClampedArray,ImageBitmap,ImageData,Map,Set,CryptoKey\"\n    .split(',').concat(\n        flatten([8,16,32,64].map(num=>[\"Int\",\"Uint\",\"Float\"].map(t=>t+num+\"Array\")))\n    ).filter(t=>_global[t]);\nconst intrinsicTypes = intrinsicTypeNames.map(t=>_global[t]);\nexport const intrinsicTypeNameSet = arrayToObject(intrinsicTypeNames, x=>[x,true]);\n\nlet circularRefs: null | WeakMap<any,any> = null;\nexport function deepClone<T>(any: T): T {\n    circularRefs = typeof WeakMap !== 'undefined' && new WeakMap();\n    const rv = innerDeepClone(any);\n    circularRefs = null;\n    return rv;\n}\n\nfunction innerDeepClone<T>(any: T): T {\n    if (!any || typeof any !== 'object') return any;\n    let rv = circularRefs && circularRefs.get(any); // Resolve circular references\n    if (rv) return rv;\n    if (isArray(any)) {\n        rv = [];\n        circularRefs && circularRefs.set(any, rv);\n        for (var i = 0, l = any.length; i < l; ++i) {\n            rv.push(innerDeepClone(any[i]));\n        }\n    } else if (intrinsicTypes.indexOf(any.constructor) >= 0) {\n        rv = any;\n    } else {\n        const proto = getProto(any);\n        rv = proto === Object.prototype ? {} : Object.create(proto);\n        circularRefs && circularRefs.set(any, rv);\n        for (var prop in any) {\n            if (hasOwn(any, prop)) {\n                rv[prop] = innerDeepClone(any[prop]);\n            }\n        }\n    }\n    return rv;\n}\n\nconst {toString} = {};\nexport function toStringTag(o: Object) {\n    return toString.call(o).slice(8, -1);\n}\n\n// If first argument is iterable or array-like, return it as an array\nexport const iteratorSymbol = typeof Symbol !== 'undefined' ?\n    Symbol.iterator :\n    '@@iterator';\nexport const getIteratorOf = typeof iteratorSymbol === \"symbol\" ? function(x) {\n    var i;\n    return x != null && (i = x[iteratorSymbol]) && i.apply(x);\n} : function () { return null; };\nexport const asyncIteratorSymbol = typeof Symbol !== 'undefined'\n    ? Symbol.asyncIterator || Symbol.for(\"Symbol.asyncIterator\")\n    : '@asyncIterator';\n\nexport const NO_CHAR_ARRAY = {};\n// Takes one or several arguments and returns an array based on the following criteras:\n// * If several arguments provided, return arguments converted to an array in a way that\n//   still allows javascript engine to optimize the code.\n// * If single argument is an array, return a clone of it.\n// * If this-pointer equals NO_CHAR_ARRAY, don't accept strings as valid iterables as a special\n//   case to the two bullets below.\n// * If single argument is an iterable, convert it to an array and return the resulting array.\n// * If single argument is array-like (has length of type number), convert it to an array.\nexport function getArrayOf (arrayLike) {\n    var i, a, x, it;\n    if (arguments.length === 1) {\n        if (isArray(arrayLike)) return arrayLike.slice();\n        if (this === NO_CHAR_ARRAY && typeof arrayLike === 'string') return [arrayLike];\n        if ((it = getIteratorOf(arrayLike))) {\n            a = [];\n            while ((x = it.next()), !x.done) a.push(x.value);\n            return a;\n        }\n        if (arrayLike == null) return [arrayLike];\n        i = arrayLike.length;\n        if (typeof i === 'number') {\n            a = new Array(i);\n            while (i--) a[i] = arrayLike[i];\n            return a;\n        }\n        return [arrayLike];\n    }\n    i = arguments.length;\n    a = new Array(i);\n    while (i--) a[i] = arguments[i];\n    return a;\n}\nexport const isAsyncFunction = typeof Symbol !== 'undefined'\n    ? (fn: Function) => fn[Symbol.toStringTag] === 'AsyncFunction'\n    : ()=>false;\n", "// By default, debug will be true only if platform is a web platform and its page is served from localhost.\n// When debug = true, error's stacks will contain asyncronic long stacks.\nexport var debug = typeof location !== 'undefined' &&\n        // By default, use debug mode if served from localhost.\n        /^(http|https):\\/\\/(localhost|127\\.0\\.0\\.1)/.test(location.href);\n\nexport function setDebug(value, filter) {\n    debug = value;\n    libraryFilter = filter;\n}\n\nexport var libraryFilter = () => true;\n\nexport const NEEDS_THROW_FOR_STACK = !new Error(\"\").stack;\n\nexport function getErrorWithStack() {\n    \"use strict\";\n    if (NEEDS_THROW_FOR_STACK) try {\n        // Doing something naughty in strict mode here to trigger a specific error\n        // that can be explicitely ignored in debugger's exception settings.\n        // If we'd just throw new Error() here, IE's debugger's exception settings\n        // will just consider it as \"exception thrown by javascript code\" which is\n        // something you wouldn't want it to ignore.\n        getErrorWithStack.arguments;\n        throw new Error(); // Fallback if above line don't throw.\n    } catch(e) {\n        return e;\n    }\n    return new Error();\n}\n\nexport function prettyStack(exception, numIgnoredFrames) {\n    var stack = exception.stack;\n    if (!stack) return \"\";\n    numIgnoredFrames = (numIgnoredFrames || 0);\n    if (stack.indexOf(exception.name) === 0)\n        numIgnoredFrames += (exception.name + exception.message).split('\\n').length;\n    return stack.split('\\n')\n        .slice(numIgnoredFrames)\n        .filter(libraryFilter)\n        .map(frame => \"\\n\" + frame)\n        .join('');\n}\n\n// TODO: Replace this in favor of a decorator instead.\nexport function deprecated<T> (what: string, fn: (...args)=>T) {\n    return function () {\n        console.warn(`${what} is deprecated. See https://dexie.org/docs/Deprecations. ${prettyStack(getErrorWithStack(), 1)}`);\n        return fn.apply(this, arguments);\n    } as (...args)=>T\n}\n", "import { derive, setProp } from '../functions/utils';\nimport { getErrorWithStack, prettyStack } from '../helpers/debug';\n\nvar dexieErrorNames = [\n    'Modify',\n    'Bulk',\n    'OpenFailed',\n    'VersionChange',\n    'Schema',\n    'Upgrade',\n    'InvalidTable',\n    'MissingAPI',\n    'NoSuchDatabase',\n    'InvalidArgument',\n    'SubTransaction',\n    'Unsupported',\n    'Internal',\n    'DatabaseClosed',\n    'PrematureCommit',\n    'ForeignAwait'\n];\n\nvar idbDomErrorNames = [\n    'Unknown',\n    'Constraint',\n    'Data',\n    'TransactionInactive',\n    'ReadOnly',\n    'Version',\n    'NotFound',\n    'InvalidState',\n    'InvalidAccess',\n    'Abort',\n    'Timeout',\n    'QuotaExceeded',\n    'Syntax',\n    'DataClone'\n];\n\nvar errorList = dexieErrorNames.concat(idbDomErrorNames);\n\nvar defaultTexts = {\n    VersionChanged: \"Database version changed by other database connection\",\n    DatabaseClosed: \"Database has been closed\",\n    Abort: \"Transaction aborted\",\n    TransactionInactive: \"Transaction has already completed or failed\",\n    MissingAPI: \"IndexedDB API missing. Please visit https://tinyurl.com/y2uuvskb\"\n};\n\n//\n// DexieError - base class of all out exceptions.\n//\nexport function DexieError (name, msg) {\n    // Reason we don't use ES6 classes is because:\n    // 1. It bloats transpiled code and increases size of minified code.\n    // 2. It doesn't give us much in this case.\n    // 3. It would require sub classes to call super(), which\n    //    is not needed when deriving from Error.\n    this._e = getErrorWithStack();\n    this.name = name;\n    this.message = msg;\n}\n\nderive(DexieError).from(Error).extend({\n    stack: {\n        get: function() {\n            return this._stack ||\n                (this._stack = this.name + \": \" + this.message + prettyStack(this._e, 2));\n        }\n    },\n    toString: function(){ return this.name + \": \" + this.message; }\n});\n\nfunction getMultiErrorMessage (msg, failures) {\n    return msg + \". Errors: \" + Object.keys(failures)\n        .map(key=>failures[key].toString())\n        .filter((v,i,s)=>s.indexOf(v) === i) // Only unique error strings\n        .join('\\n');\n}\n\n//\n// ModifyError - thrown in Collection.modify()\n// Specific constructor because it contains members failures and failedKeys.\n//\nexport function ModifyError (msg, failures, successCount, failedKeys) {\n    this._e = getErrorWithStack();\n    this.failures = failures;\n    this.failedKeys = failedKeys;\n    this.successCount = successCount;\n    this.message = getMultiErrorMessage(msg, failures);\n}\nderive(ModifyError).from(DexieError);\n\nexport function BulkError (msg, failures) {\n    this._e = getErrorWithStack();\n    this.name = \"BulkError\";\n    this.failures = Object.keys(failures).map(pos => failures[pos]);\n    this.failuresByPos = failures;\n    this.message = getMultiErrorMessage(msg, failures);\n}\nderive(BulkError).from(DexieError);\n\n//\n//\n// Dynamically generate error names and exception classes based\n// on the names in errorList.\n//\n//\n\n// Map of {ErrorName -> ErrorName + \"Error\"}\nexport var errnames = errorList.reduce((obj,name)=>(obj[name]=name+\"Error\",obj),{});\n\n// Need an alias for DexieError because we're gonna create subclasses with the same name.\nconst BaseException = DexieError;\n// Map of {ErrorName -> exception constructor}\nexport var exceptions = errorList.reduce((obj,name)=>{\n    // Let the name be \"DexieError\" because this name may\n    // be shown in call stack and when debugging. DexieError is\n    // the most true name because it derives from DexieError,\n    // and we cannot change Function.name programatically without\n    // dynamically create a Function object, which would be considered\n    // 'eval-evil'.\n    var fullName = name + \"Error\";\n    function DexieError (msgOrInner, inner){\n        this._e = getErrorWithStack();\n        this.name = fullName;\n        if (!msgOrInner) {\n            this.message = defaultTexts[name] || fullName;\n            this.inner = null;\n        } else if (typeof msgOrInner === 'string') {\n            this.message = `${msgOrInner}${!inner ? '' : '\\n ' + inner}`;\n            this.inner = inner || null;\n        } else if (typeof msgOrInner === 'object') {\n            this.message = `${msgOrInner.name} ${msgOrInner.message}`;\n            this.inner = msgOrInner;\n        }\n    }\n    derive(DexieError).from(BaseException);\n    obj[name]=DexieError;\n    return obj;\n},{});\n\n// Use ECMASCRIPT standard exceptions where applicable:\nexceptions.Syntax = SyntaxError;\nexceptions.Type = TypeError;\nexceptions.Range = RangeError;\n\nexport var exceptionMap = idbDomErrorNames.reduce((obj, name)=>{\n    obj[name + \"Error\"] = exceptions[name];\n    return obj;\n}, {});\n\nexport function mapError (domError, message) {\n    if (!domError || domError instanceof DexieError || domError instanceof TypeError || domError instanceof SyntaxError || !domError.name || !exceptionMap[domError.name])\n        return domError;\n    var rv = new exceptionMap[domError.name](message || domError.message, domError);\n    if (\"stack\" in domError) {\n        // Derive stack from inner exception if it has a stack\n        setProp(rv, \"stack\", {get: function(){\n            return this.inner.stack;\n        }});\n    }\n    return rv;\n}\n\nexport var fullNameExceptions = errorList.reduce((obj, name)=>{\n    if ([\"Syntax\",\"Type\",\"Range\"].indexOf(name) === -1)\n        obj[name + \"Error\"] = exceptions[name];\n    return obj;\n}, {});\n\nfullNameExceptions.ModifyError = ModifyError;\nfullNameExceptions.DexieError = DexieError;\nfullNameExceptions.BulkError = BulkError;\n", "import {extend} from './utils';\n\nexport function nop() { }\nexport function mirror(val) { return val; }\nexport function pureFunctionChain(f1, f2) {\n    // Enables chained events that takes ONE argument and returns it to the next function in chain.\n    // This pattern is used in the hook(\"reading\") event.\n    if (f1 == null || f1 === mirror) return f2;\n    return function (val) {\n        return f2(f1(val));\n    };\n}\n\nexport function callBoth(on1, on2) {\n    return function () {\n        on1.apply(this, arguments);\n        on2.apply(this, arguments);\n    };\n}\n\nexport function hookCreatingChain(f1, f2) {\n    // Enables chained events that takes several arguments and may modify first argument by making a modification and then returning the same instance.\n    // This pattern is used in the hook(\"creating\") event.\n    if (f1 === nop) return f2;\n    return function () {\n        var res = f1.apply(this, arguments);\n        if (res !== undefined) arguments[0] = res;\n        var onsuccess = this.onsuccess, // In case event listener has set this.onsuccess\n            onerror = this.onerror;     // In case event listener has set this.onerror\n        this.onsuccess = null;\n        this.onerror = null;\n        var res2 = f2.apply(this, arguments);\n        if (onsuccess) this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;\n        if (onerror) this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;\n        return res2 !== undefined ? res2 : res;\n    };\n}\n\nexport function hookDeletingChain(f1, f2) {\n    if (f1 === nop) return f2;\n    return function () {\n        f1.apply(this, arguments);\n        var onsuccess = this.onsuccess, // In case event listener has set this.onsuccess\n            onerror = this.onerror;     // In case event listener has set this.onerror\n        this.onsuccess = this.onerror = null;\n        f2.apply(this, arguments);\n        if (onsuccess) this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;\n        if (onerror) this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;\n    };\n}\n\nexport function hookUpdatingChain(f1, f2) {\n    if (f1 === nop) return f2;\n    return function (modifications) {\n        var res = f1.apply(this, arguments);\n        extend(modifications, res); // If f1 returns new modifications, extend caller's modifications with the result before calling next in chain.\n        var onsuccess = this.onsuccess, // In case event listener has set this.onsuccess\n            onerror = this.onerror;     // In case event listener has set this.onerror\n        this.onsuccess = null;\n        this.onerror = null;\n        var res2 = f2.apply(this, arguments);\n        if (onsuccess) this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;\n        if (onerror) this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;\n        return res === undefined ?\n            (res2 === undefined ? undefined : res2) :\n            (extend(res, res2));\n    };\n}\n\nexport function reverseStoppableEventChain(f1, f2) {\n    if (f1 === nop) return f2;\n    return function () {\n        if (f2.apply(this, arguments) === false) return false;\n        return f1.apply(this, arguments);\n    };\n}\n\nexport function nonStoppableEventChain(f1, f2) {\n    if (f1 === nop) return f2;\n    return function () {\n        f1.apply(this, arguments);\n        f2.apply(this, arguments);\n    };\n}\n\nexport function promisableChain(f1, f2) {\n    if (f1 === nop) return f2;\n    return function () {\n        var res = f1.apply(this, arguments);\n        if (res && typeof res.then === 'function') {\n            var thiz = this,\n                i = arguments.length,\n                args = new Array(i);\n            while (i--) args[i] = arguments[i];\n            return res.then(function () {\n                return f2.apply(thiz, args);\n            });\n        }\n        return f2.apply(this, arguments);\n    };\n}\n", "/*\n * Copyright (c) 2014-2017 David Fahlander\n * Apache License Version 2.0, January 2004, http://www.apache.org/licenses/LICENSE-2.0\n */\nimport { _global } from '../globals/global';\nimport {tryCatch, props, setProp, _global,\n    getPropertyDescriptor, getArrayOf, extend, getProto} from '../functions/utils';\nimport {nop, callBoth, mirror} from '../functions/chaining-functions';\nimport {debug, prettyStack, getErrorWithStack} from './debug';\nimport {exceptions} from '../errors';\n\n//\n// Promise and Zone (PSD) for Dexie library\n//\n// I started out writing this Promise class by copying promise-light (https://github.com/taylorhakes/promise-light) by\n// https://github.com/taylorhakes - an A+ and ECMASCRIPT 6 compliant Promise implementation.\n//\n// In previous versions this was fixed by not calling setTimeout when knowing that the resolve() or reject() came from another\n// tick. In Dexie v1.4.0, I've rewritten the Promise class entirely. Just some fragments of promise-light is left. I use\n// another strategy now that simplifies everything a lot: to always execute callbacks in a new micro-task, but have an own micro-task\n// engine that is indexedDB compliant across all browsers.\n// Promise class has also been optimized a lot with inspiration from bluebird - to avoid closures as much as possible.\n// Also with inspiration from bluebird, asyncronic stacks in debug mode.\n//\n// Specific non-standard features of this Promise class:\n// * Custom zone support (a.k.a. PSD) with ability to keep zones also when using native promises as well as\n//   native async / await.\n// * Promise.follow() method built upon the custom zone engine, that allows user to track all promises created from current stack frame\n//   and below + all promises that those promises creates or awaits.\n// * Detect any unhandled promise in a PSD-scope (PSD.onunhandled). \n//\n// David Fahlander, https://github.com/dfahlander\n//\n\n// Just a pointer that only this module knows about.\n// Used in Promise constructor to emulate a private constructor.\nvar INTERNAL = {};\n\n// Async stacks (long stacks) must not grow infinitely.\nconst\n    LONG_STACKS_CLIP_LIMIT = 100,\n    // When calling error.stack or promise.stack, limit the number of asyncronic stacks to print out. \n    MAX_LONG_STACKS = 20,\n    ZONE_ECHO_LIMIT = 100,\n    [resolvedNativePromise, nativePromiseProto, resolvedGlobalPromise] = typeof Promise === 'undefined' ?\n        [] :\n        (()=>{\n            let globalP = Promise.resolve();\n            if (typeof crypto === 'undefined' || !crypto.subtle)\n                return [globalP, getProto(globalP), globalP];\n            // Generate a native promise (as window.Promise may have been patched)\n            const nativeP = crypto.subtle.digest(\"SHA-512\", new Uint8Array([0]));\n            return [\n                nativeP,\n                getProto(nativeP),\n                globalP\n            ];\n        })(),\n    nativePromiseThen = nativePromiseProto && nativePromiseProto.then;\n\nexport const NativePromise = resolvedNativePromise && resolvedNativePromise.constructor;\nconst patchGlobalPromise = !!resolvedGlobalPromise;\n\nvar stack_being_generated = false;\n\n/* The default function used only for the very first promise in a promise chain.\n   As soon as then promise is resolved or rejected, all next tasks will be executed in micro ticks\n   emulated in this module. For indexedDB compatibility, this means that every method needs to \n   execute at least one promise before doing an indexedDB operation. Dexie will always call \n   db.ready().then() for every operation to make sure the indexedDB event is started in an\n   indexedDB-compatible emulated micro task loop.\n*/\nvar schedulePhysicalTick = resolvedGlobalPromise ?\n    () => {resolvedGlobalPromise.then(physicalTick);}\n    :\n    _global.setImmediate ? \n        // setImmediate supported. Those modern platforms also supports Function.bind().\n        setImmediate.bind(null, physicalTick) :\n        _global.MutationObserver ?\n            // MutationObserver supported\n            () => {\n                var hiddenDiv = document.createElement(\"div\");\n                (new MutationObserver(() => {\n                    physicalTick();\n                    hiddenDiv = null;\n                })).observe(hiddenDiv, { attributes: true });\n                hiddenDiv.setAttribute('i', '1');\n            } :\n            // No support for setImmediate or MutationObserver. No worry, setTimeout is only called\n            // once time. Every tick that follows will be our emulated micro tick.\n            // Could have uses setTimeout.bind(null, 0, physicalTick) if it wasnt for that FF13 and below has a bug \n            ()=>{setTimeout(physicalTick,0);};\n\n// Configurable through Promise.scheduler.\n// Don't export because it would be unsafe to let unknown\n// code call it unless they do try..catch within their callback.\n// This function can be retrieved through getter of Promise.scheduler though,\n// but users must not do Promise.scheduler = myFuncThatThrowsException\nvar asap = function (callback, args) {\n    microtickQueue.push([callback, args]);\n    if (needsNewPhysicalTick) {\n        schedulePhysicalTick();\n        needsNewPhysicalTick = false;\n    }\n};\n\nvar isOutsideMicroTick = true, // True when NOT in a virtual microTick.\n    needsNewPhysicalTick = true, // True when a push to microtickQueue must also schedulePhysicalTick()\n    unhandledErrors = [], // Rejected promises that has occured. Used for triggering 'unhandledrejection'.\n    rejectingErrors = [], // Tracks if errors are being re-rejected during onRejected callback.\n    currentFulfiller = null,\n    rejectionMapper = mirror; // Remove in next major when removing error mapping of DOMErrors and DOMExceptions\n    \nexport var globalPSD = {\n    id: 'global',\n    global: true,\n    ref: 0,\n    unhandleds: [],\n    onunhandled: globalError,\n    pgp: false,\n    env: {},\n    finalize: function () {\n        this.unhandleds.forEach(uh => {\n            try {\n                globalError(uh[0], uh[1]);\n            } catch (e) {}\n        });\n    }\n};\n\nexport var PSD = globalPSD;\n\nexport var microtickQueue = []; // Callbacks to call in this or next physical tick.\nexport var numScheduledCalls = 0; // Number of listener-calls left to do in this physical tick.\nexport var tickFinalizers = []; // Finalizers to call when there are no more async calls scheduled within current physical tick.\n\nexport default function DexiePromise(fn) {\n    if (typeof this !== 'object') throw new TypeError('Promises must be constructed via new');    \n    this._listeners = [];\n    this.onuncatched = nop; // Deprecate in next major. Not needed. Better to use global error handler.\n    \n    // A library may set `promise._lib = true;` after promise is created to make resolve() or reject()\n    // execute the microtask engine implicitely within the call to resolve() or reject().\n    // To remain A+ compliant, a library must only set `_lib=true` if it can guarantee that the stack\n    // only contains library code when calling resolve() or reject().\n    // RULE OF THUMB: ONLY set _lib = true for promises explicitely resolving/rejecting directly from\n    // global scope (event handler, timer etc)!\n    this._lib = false;\n    // Current async scope\n    var psd = (this._PSD = PSD);\n\n    if (debug) {\n        this._stackHolder = getErrorWithStack();\n        this._prev = null;\n        this._numPrev = 0; // Number of previous promises (for long stacks)\n    }\n    \n    if (typeof fn !== 'function') {\n        if (fn !== INTERNAL) throw new TypeError('Not a function');\n        // Private constructor (INTERNAL, state, value).\n        // Used internally by Promise.resolve() and Promise.reject().\n        this._state = arguments[1];\n        this._value = arguments[2];\n        if (this._state === false)\n            handleRejection(this, this._value); // Map error, set stack and addPossiblyUnhandledError().\n        return;\n    }\n    \n    this._state = null; // null (=pending), false (=rejected) or true (=resolved)\n    this._value = null; // error or result\n    ++psd.ref; // Refcounting current scope\n    executePromiseTask(this, fn);\n}\n\n// Prepare a property descriptor to put onto Promise.prototype.then\nconst thenProp = {\n    get: function() {\n        var psd = PSD, microTaskId = totalEchoes;\n\n        function then (onFulfilled, onRejected) {\n            var possibleAwait = !psd.global && (psd !== PSD || microTaskId !== totalEchoes);\n            const cleanup = possibleAwait && !decrementExpectedAwaits();\n            var rv = new DexiePromise((resolve, reject) => {\n                propagateToListener(this, new Listener(\n                    nativeAwaitCompatibleWrap(onFulfilled, psd, possibleAwait, cleanup),\n                    nativeAwaitCompatibleWrap(onRejected, psd, possibleAwait, cleanup),\n                    resolve,\n                    reject,\n                    psd));\n            });\n            debug && linkToPreviousPromise(rv, this);\n            return rv;\n        }\n\n        then.prototype = INTERNAL; // For idempotense, see setter below.\n\n        return then;\n    },\n    // Be idempotent and allow another framework (such as zone.js or another instance of a Dexie.Promise module) to replace Promise.prototype.then\n    // and when that framework wants to restore the original property, we must identify that and restore the original property descriptor.\n    set: function (value) {\n        setProp (this, 'then', value && value.prototype === INTERNAL ?\n            thenProp : // Restore to original property descriptor.\n            {\n                get: function(){\n                    return value; // Getter returning provided value (behaves like value is just changed)\n                },\n                set: thenProp.set // Keep a setter that is prepared to restore original.\n            }\n        );\n    }\n};\n\nprops(DexiePromise.prototype, {\n    then: thenProp, // Defined above.\n    _then: function (onFulfilled, onRejected) {\n        // A little tinier version of then() that don't have to create a resulting promise.\n        propagateToListener(this, new Listener(null, null, onFulfilled, onRejected, PSD));        \n    },\n\n    catch: function (onRejected) {\n        if (arguments.length === 1) return this.then(null, onRejected);\n        // First argument is the Error type to catch\n        var type = arguments[0],\n            handler = arguments[1];\n        return typeof type === 'function' ? this.then(null, err =>\n            // Catching errors by its constructor type (similar to java / c++ / c#)\n            // Sample: promise.catch(TypeError, function (e) { ... });\n            err instanceof type ? handler(err) : PromiseReject(err))\n        : this.then(null, err =>\n            // Catching errors by the error.name property. Makes sense for indexedDB where error type\n            // is always DOMError but where e.name tells the actual error type.\n            // Sample: promise.catch('ConstraintError', function (e) { ... });\n            err && err.name === type ? handler(err) : PromiseReject(err));\n    },\n\n    finally: function (onFinally) {\n        return this.then(value => {\n            onFinally();\n            return value;\n        }, err => {\n            onFinally();\n            return PromiseReject(err);\n        });\n    },\n    \n    stack: {\n        get: function() {\n            if (this._stack) return this._stack;\n            try {\n                stack_being_generated = true;\n                var stacks = getStack (this, [], MAX_LONG_STACKS);\n                var stack = stacks.join(\"\\nFrom previous: \");\n                if (this._state !== null) this._stack = stack; // Stack may be updated on reject.\n                return stack;\n            } finally {\n                stack_being_generated = false;\n            }\n        }\n    },\n\n    timeout: function (ms, msg) {\n        return ms < Infinity ?\n            new DexiePromise((resolve, reject) => {\n                var handle = setTimeout(() => reject(new exceptions.Timeout(msg)), ms);\n                this.then(resolve, reject).finally(clearTimeout.bind(null, handle));\n            }) : this;\n    }\n});\n\nif (typeof Symbol !== 'undefined' && Symbol.toStringTag)\n    setProp(DexiePromise.prototype, Symbol.toStringTag, 'Dexie.Promise');\n\n// Now that Promise.prototype is defined, we have all it takes to set globalPSD.env.\n// Environment globals snapshotted on leaving global zone\nglobalPSD.env = snapShot();\n\nfunction Listener(onFulfilled, onRejected, resolve, reject, zone) {\n    this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;\n    this.onRejected = typeof onRejected === 'function' ? onRejected : null;\n    this.resolve = resolve;\n    this.reject = reject;\n    this.psd = zone;\n}\n\n// Promise Static Properties\nprops (DexiePromise, {\n    all: function () {\n        var values = getArrayOf.apply(null, arguments) // Supports iterables, implicit arguments and array-like.\n            .map(onPossibleParallellAsync); // Handle parallell async/awaits \n        return new DexiePromise(function (resolve, reject) {\n            if (values.length === 0) resolve([]);\n            var remaining = values.length;\n            values.forEach((a,i) => DexiePromise.resolve(a).then(x => {\n                values[i] = x;\n                if (!--remaining) resolve(values);\n            }, reject));\n        });\n    },\n    \n    resolve: value => {\n        if (value instanceof DexiePromise) return value;\n        if (value && typeof value.then === 'function') return new DexiePromise((resolve, reject)=>{\n            value.then(resolve, reject);\n        });\n        var rv = new DexiePromise(INTERNAL, true, value);\n        linkToPreviousPromise(rv, currentFulfiller);\n        return rv;\n    },\n    \n    reject: PromiseReject,\n    \n    race: function () {\n        var values = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);\n        return new DexiePromise((resolve, reject) => {\n            values.map(value => DexiePromise.resolve(value).then(resolve, reject));\n        });\n    },\n\n    PSD: {\n        get: ()=>PSD,\n        set: value => PSD = value\n    },\n\n    totalEchoes: {get: ()=>totalEchoes},\n\n    //task: {get: ()=>task},\n    \n    newPSD: newScope,\n    \n    usePSD: usePSD,\n    \n    scheduler: {\n        get: () => asap,\n        set: value => {asap = value}\n    },\n    \n    rejectionMapper: {\n        get: () => rejectionMapper,\n        set: value => {rejectionMapper = value;} // Map reject failures\n    },\n            \n    follow: (fn, zoneProps) => {\n        return new DexiePromise((resolve, reject) => {\n            return newScope((resolve, reject) => {\n                var psd = PSD;\n                psd.unhandleds = []; // For unhandled standard- or 3rd party Promises. Checked at psd.finalize()\n                psd.onunhandled = reject; // Triggered directly on unhandled promises of this library.\n                psd.finalize = callBoth(function () {\n                    // Unhandled standard or 3rd part promises are put in PSD.unhandleds and\n                    // examined upon scope completion while unhandled rejections in this Promise\n                    // will trigger directly through psd.onunhandled\n                    run_at_end_of_this_or_next_physical_tick(()=>{\n                        this.unhandleds.length === 0 ? resolve() : reject(this.unhandleds[0]);\n                    });\n                }, psd.finalize);\n                fn();\n            }, zoneProps, resolve, reject);\n        });\n    }\n});\n\nif (NativePromise) {\n    if (NativePromise.allSettled) setProp (DexiePromise, \"allSettled\", function() {\n        const possiblePromises = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);\n        return new DexiePromise(resolve => {\n            if (possiblePromises.length === 0) resolve([]);\n            let remaining = possiblePromises.length;\n            const results = new Array(remaining);\n            possiblePromises.forEach((p, i) => DexiePromise.resolve(p).then(\n                value => results[i] = {status: \"fulfilled\", value},\n                reason => results[i] = {status: \"rejected\", reason})\n                .then(()=>--remaining || resolve(results)));\n        });\n    });\n    if (NativePromise.any && typeof AggregateError !== 'undefined') setProp(DexiePromise, \"any\", function() {\n        const possiblePromises = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);\n        return new DexiePromise((resolve, reject) => {\n            if (possiblePromises.length === 0) reject(new AggregateError([]));\n            let remaining = possiblePromises.length;\n            const failures = new Array(remaining);\n            possiblePromises.forEach((p, i) => DexiePromise.resolve(p).then(\n                value => resolve(value),\n                failure => {\n                    failures[i] = failure;\n                    if (!--remaining) reject(new AggregateError(failures));\n                }));\n        });\n    });\n}\n\n/**\n* Take a potentially misbehaving resolver function and make sure\n* onFulfilled and onRejected are only called once.\n*\n* Makes no guarantees about asynchrony.\n*/\nfunction executePromiseTask (promise, fn) {\n    // Promise Resolution Procedure:\n    // https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure\n    try {\n        fn(value => {\n            if (promise._state !== null) return; // Already settled\n            if (value === promise) throw new TypeError('A promise cannot be resolved with itself.');\n            var shouldExecuteTick = promise._lib && beginMicroTickScope();\n            if (value && typeof value.then === 'function') {\n                executePromiseTask(promise, (resolve, reject) => {\n                    value instanceof DexiePromise ?\n                        value._then(resolve, reject) :\n                        value.then(resolve, reject);\n                });\n            } else {\n                promise._state = true;\n                promise._value = value;\n                propagateAllListeners(promise);\n            }\n            if (shouldExecuteTick) endMicroTickScope();\n        }, handleRejection.bind(null, promise)); // If Function.bind is not supported. Exception is handled in catch below\n    } catch (ex) {\n        handleRejection(promise, ex);\n    }\n}\n\nfunction handleRejection (promise, reason) {\n    rejectingErrors.push(reason);\n    if (promise._state !== null) return;\n    var shouldExecuteTick = promise._lib && beginMicroTickScope();\n    reason = rejectionMapper(reason);\n    promise._state = false;\n    promise._value = reason;\n    debug && reason !== null && typeof reason === 'object' && !reason._promise && tryCatch(()=>{\n        var origProp = getPropertyDescriptor(reason, \"stack\");        \n        reason._promise = promise;    \n        setProp(reason, \"stack\", {\n            get: () =>\n                stack_being_generated ?\n                    origProp && (origProp.get ?\n                                origProp.get.apply(reason) :\n                                origProp.value) :\n                    promise.stack\n        });\n    });\n    // Add the failure to a list of possibly uncaught errors\n    addPossiblyUnhandledError(promise);\n    propagateAllListeners(promise);\n    if (shouldExecuteTick) endMicroTickScope();\n}\n\nfunction propagateAllListeners (promise) {\n    //debug && linkToPreviousPromise(promise);\n    var listeners = promise._listeners;\n    promise._listeners = [];\n    for (var i = 0, len = listeners.length; i < len; ++i) {\n        propagateToListener(promise, listeners[i]);\n    }\n    var psd = promise._PSD;\n    --psd.ref || psd.finalize(); // if psd.ref reaches zero, call psd.finalize();\n    if (numScheduledCalls === 0) {\n        // If numScheduledCalls is 0, it means that our stack is not in a callback of a scheduled call,\n        // and that no deferreds where listening to this rejection or success.\n        // Since there is a risk that our stack can contain application code that may\n        // do stuff after this code is finished that may generate new calls, we cannot\n        // call finalizers here.\n        ++numScheduledCalls;\n        asap(()=>{\n            if (--numScheduledCalls === 0) finalizePhysicalTick(); // Will detect unhandled errors\n        }, []);\n    }\n}\n\nfunction propagateToListener(promise, listener) {\n    if (promise._state === null) {\n        promise._listeners.push(listener);\n        return;\n    }\n\n    var cb = promise._state ? listener.onFulfilled : listener.onRejected;\n    if (cb === null) {\n        // This Listener doesnt have a listener for the event being triggered (onFulfilled or onReject) so lets forward the event to any eventual listeners on the Promise instance returned by then() or catch()\n        return (promise._state ? listener.resolve : listener.reject) (promise._value);\n    }\n    ++listener.psd.ref;\n    ++numScheduledCalls;\n    asap (callListener, [cb, promise, listener]);\n}\n\nfunction callListener (cb, promise, listener) {\n    try {\n        // Set static variable currentFulfiller to the promise that is being fullfilled,\n        // so that we connect the chain of promises (for long stacks support)\n        currentFulfiller = promise;\n        \n        // Call callback and resolve our listener with it's return value.\n        var ret, value = promise._value;\n            \n        if (promise._state) {\n            // cb is onResolved\n            ret = cb (value);\n        } else {\n            // cb is onRejected\n            if (rejectingErrors.length) rejectingErrors = [];\n            ret = cb(value);\n            if (rejectingErrors.indexOf(value) === -1)\n                markErrorAsHandled(promise); // Callback didnt do Promise.reject(err) nor reject(err) onto another promise.\n        }\n        listener.resolve(ret);\n    } catch (e) {\n        // Exception thrown in callback. Reject our listener.\n        listener.reject(e);\n    } finally {\n        // Restore env and currentFulfiller.\n        currentFulfiller = null;\n        if (--numScheduledCalls === 0) finalizePhysicalTick();\n        --listener.psd.ref || listener.psd.finalize();\n    }\n}\n\nfunction getStack (promise, stacks, limit) {\n    if (stacks.length === limit) return stacks;\n    var stack = \"\";\n    if (promise._state === false) {\n        var failure = promise._value,\n            errorName,\n            message;\n        \n        if (failure != null) {\n            errorName = failure.name || \"Error\";\n            message = failure.message || failure;\n            stack = prettyStack(failure, 0);\n        } else {\n            errorName = failure; // If error is undefined or null, show that.\n            message = \"\";\n        }\n        stacks.push(errorName + (message ? \": \" + message : \"\") + stack);\n    }\n    if (debug) {\n        stack = prettyStack(promise._stackHolder, 2);\n        if (stack && stacks.indexOf(stack) === -1) stacks.push(stack);\n        if (promise._prev) getStack(promise._prev, stacks, limit);\n    }\n    return stacks;\n}\n\nfunction linkToPreviousPromise(promise, prev) {\n    // Support long stacks by linking to previous completed promise.\n    var numPrev = prev ? prev._numPrev + 1 : 0;\n    if (numPrev < LONG_STACKS_CLIP_LIMIT) { // Prohibit infinite Promise loops to get an infinite long memory consuming \"tail\".\n        promise._prev = prev;\n        promise._numPrev = numPrev;\n    }\n}\n\n/* The callback to schedule with setImmediate() or setTimeout().\n   It runs a virtual microtick and executes any callback registered in microtickQueue.\n */\nfunction physicalTick() {\n    beginMicroTickScope() && endMicroTickScope();\n}\n\nexport function beginMicroTickScope() {\n    var wasRootExec = isOutsideMicroTick;\n    isOutsideMicroTick = false;\n    needsNewPhysicalTick = false;\n    return wasRootExec;\n}\n\n/* Executes micro-ticks without doing try..catch.\n   This can be possible because we only use this internally and\n   the registered functions are exception-safe (they do try..catch\n   internally before calling any external method). If registering\n   functions in the microtickQueue that are not exception-safe, this\n   would destroy the framework and make it instable. So we don't export\n   our asap method.\n*/\nexport function endMicroTickScope() {\n    var callbacks, i, l;\n    do {\n        while (microtickQueue.length > 0) {\n            callbacks = microtickQueue;\n            microtickQueue = [];\n            l = callbacks.length;\n            for (i = 0; i < l; ++i) {\n                var item = callbacks[i];\n                item[0].apply(null, item[1]);\n            }\n        }\n    } while (microtickQueue.length > 0);\n    isOutsideMicroTick = true;\n    needsNewPhysicalTick = true;\n}\n\nfunction finalizePhysicalTick() {\n    var unhandledErrs = unhandledErrors;\n    unhandledErrors = [];\n    unhandledErrs.forEach(p => {\n        p._PSD.onunhandled.call(null, p._value, p);\n    });\n    var finalizers = tickFinalizers.slice(0); // Clone first because finalizer may remove itself from list.\n    var i = finalizers.length;\n    while (i) finalizers[--i]();    \n}\n\nfunction run_at_end_of_this_or_next_physical_tick (fn) {\n    function finalizer() {\n        fn();\n        tickFinalizers.splice(tickFinalizers.indexOf(finalizer), 1);\n    }\n    tickFinalizers.push(finalizer);\n    ++numScheduledCalls;\n    asap(()=>{\n        if (--numScheduledCalls === 0) finalizePhysicalTick();\n    }, []);\n}\n\nfunction addPossiblyUnhandledError(promise) {\n    // Only add to unhandledErrors if not already there. The first one to add to this list\n    // will be upon the first rejection so that the root cause (first promise in the\n    // rejection chain) is the one listed.\n    if (!unhandledErrors.some(p => p._value === promise._value))\n        unhandledErrors.push(promise);\n}\n\nfunction markErrorAsHandled(promise) {\n    // Called when a reject handled is actually being called.\n    // Search in unhandledErrors for any promise whos _value is this promise_value (list\n    // contains only rejected promises, and only one item per error)\n    var i = unhandledErrors.length;\n    while (i) if (unhandledErrors[--i]._value === promise._value) {\n        // Found a promise that failed with this same error object pointer,\n        // Remove that since there is a listener that actually takes care of it.\n        unhandledErrors.splice(i, 1);\n        return;\n    }\n}\n\nfunction PromiseReject (reason) {\n    return new DexiePromise(INTERNAL, false, reason);\n}\n\nexport function wrap (fn, errorCatcher) {\n    var psd = PSD;\n    return function() {\n        var wasRootExec = beginMicroTickScope(),\n            outerScope = PSD;\n\n        try {\n            switchToZone(psd, true);\n            return fn.apply(this, arguments);\n        } catch (e) {\n            errorCatcher && errorCatcher(e);\n        } finally {\n            switchToZone(outerScope, false);\n            if (wasRootExec) endMicroTickScope();\n        }\n    };\n}\n\n\n//\n// variables used for native await support\n//\nconst task = { awaits: 0, echoes: 0, id: 0}; // The ongoing macro-task when using zone-echoing.\nvar taskCounter = 0; // ID counter for macro tasks.\nvar zoneStack = []; // Stack of left zones to restore asynchronically.\nvar zoneEchoes = 0; // zoneEchoes is a must in order to persist zones between native await expressions.\nvar totalEchoes = 0; // ID counter for micro-tasks. Used to detect possible native await in our Promise.prototype.then.\n\n\nvar zone_id_counter = 0;\nexport function newScope (fn, props, a1, a2) {\n    var parent = PSD,\n        psd = Object.create(parent);\n    psd.parent = parent;\n    psd.ref = 0;\n    psd.global = false;\n    psd.id = ++zone_id_counter;\n    // Prepare for promise patching (done in usePSD):\n    var globalEnv = globalPSD.env;\n    psd.env = patchGlobalPromise ? {\n        Promise: DexiePromise, // Changing window.Promise could be omitted for Chrome and Edge, where IDB+Promise plays well!\n        PromiseProp: {value: DexiePromise, configurable: true, writable: true},\n        all: DexiePromise.all,\n        race: DexiePromise.race,\n        allSettled: DexiePromise.allSettled,\n        any: DexiePromise.any,\n        resolve: DexiePromise.resolve,\n        reject: DexiePromise.reject,\n        nthen: getPatchedPromiseThen (globalEnv.nthen, psd), // native then\n        gthen: getPatchedPromiseThen (globalEnv.gthen, psd) // global then\n    } : {};\n    if (props) extend(psd, props);\n    \n    // unhandleds and onunhandled should not be specifically set here.\n    // Leave them on parent prototype.\n    // unhandleds.push(err) will push to parent's prototype\n    // onunhandled() will call parents onunhandled (with this scope's this-pointer though!)\n    ++parent.ref;\n    psd.finalize = function () {\n        --this.parent.ref || this.parent.finalize();\n    }\n    var rv = usePSD (psd, fn, a1, a2);\n    if (psd.ref === 0) psd.finalize();\n    return rv;\n}\n\n// Function to call if scopeFunc returns NativePromise\n// Also for each NativePromise in the arguments to Promise.all()\nexport function incrementExpectedAwaits() {\n    if (!task.id) task.id = ++taskCounter;\n    ++task.awaits;\n    task.echoes += ZONE_ECHO_LIMIT;\n    return task.id;\n}\n\n// Function to call when 'then' calls back on a native promise where onAwaitExpected() had been called.\n// Also call this when a native await calls then method on a promise. In that case, don't supply\n// sourceTaskId because we already know it refers to current task.\nexport function decrementExpectedAwaits() {\n    if (!task.awaits) return false;\n    if (--task.awaits === 0) task.id = 0;\n    task.echoes = task.awaits * ZONE_ECHO_LIMIT; // Will reset echoes to 0 if awaits is 0.\n    return true;\n}\n\nif ((''+nativePromiseThen).indexOf('[native code]') === -1) {\n    // If the native promise' prototype is patched, we cannot rely on zone echoing.\n    // Disable that here:\n    incrementExpectedAwaits = decrementExpectedAwaits = nop;\n}\n\n// Call from Promise.all() and Promise.race()\nexport function onPossibleParallellAsync (possiblePromise) {\n    if (task.echoes && possiblePromise && possiblePromise.constructor === NativePromise) {\n        incrementExpectedAwaits(); \n        return possiblePromise.then(x => {\n            decrementExpectedAwaits();\n            return x;\n        }, e => {\n            decrementExpectedAwaits();\n            return rejection(e);\n        });\n    }\n    return possiblePromise;\n}\n\nfunction zoneEnterEcho(targetZone) {\n    ++totalEchoes;\n    //console.log(\"Total echoes \", totalEchoes);\n    if (!task.echoes || --task.echoes === 0) {\n        task.echoes = task.id = 0; // Cancel zone echoing.\n    }\n\n    zoneStack.push(PSD);\n    switchToZone(targetZone, true);\n}\n\nfunction zoneLeaveEcho() {\n    var zone = zoneStack[zoneStack.length-1];\n    zoneStack.pop();\n    switchToZone(zone, false);\n}\n\nfunction switchToZone (targetZone, bEnteringZone) {\n    var currentZone = PSD;\n    if (bEnteringZone ? task.echoes && (!zoneEchoes++ || targetZone !== PSD) : zoneEchoes && (!--zoneEchoes || targetZone !== PSD)) {\n        // Enter or leave zone asynchronically as well, so that tasks initiated during current tick\n        // will be surrounded by the zone when they are invoked.\n        enqueueNativeMicroTask(bEnteringZone ? zoneEnterEcho.bind(null, targetZone) : zoneLeaveEcho);\n    }\n    if (targetZone === PSD) return;\n\n    PSD = targetZone; // The actual zone switch occurs at this line.\n\n    // Snapshot on every leave from global zone.\n    if (currentZone === globalPSD) globalPSD.env = snapShot();\n\n    if (patchGlobalPromise) {\n        // Let's patch the global and native Promises (may be same or may be different)\n        var GlobalPromise = globalPSD.env.Promise;\n        // Swich environments (may be PSD-zone or the global zone. Both apply.)\n        var targetEnv = targetZone.env;\n\n        // Change Promise.prototype.then for native and global Promise (they MAY differ on polyfilled environments, but both can be accessed)\n        // Must be done on each zone change because the patched method contains targetZone in its closure.\n        nativePromiseProto.then = targetEnv.nthen;\n        GlobalPromise.prototype.then = targetEnv.gthen;\n\n        if (currentZone.global || targetZone.global) {\n            // Leaving or entering global zone. It's time to patch / restore global Promise.\n\n            // Set this Promise to window.Promise so that transiled async functions will work on Firefox, Safari and IE, as well as with Zonejs and angular.\n            Object.defineProperty(_global, 'Promise', targetEnv.PromiseProp);\n\n            // Support Promise.all() etc to work indexedDB-safe also when people are including es6-promise as a module (they might\n            // not be accessing global.Promise but a local reference to it)\n            GlobalPromise.all = targetEnv.all;\n            GlobalPromise.race = targetEnv.race;\n            GlobalPromise.resolve = targetEnv.resolve;\n            GlobalPromise.reject = targetEnv.reject;\n            if (targetEnv.allSettled) GlobalPromise.allSettled = targetEnv.allSettled;\n            if (targetEnv.any) GlobalPromise.any = targetEnv.any;\n        }\n    }\n}\n\nfunction snapShot () {\n    var GlobalPromise = _global.Promise;\n    return patchGlobalPromise ? {\n        Promise: GlobalPromise,\n        PromiseProp: Object.getOwnPropertyDescriptor(_global, \"Promise\"),\n        all: GlobalPromise.all,\n        race: GlobalPromise.race,\n        allSettled: GlobalPromise.allSettled,\n        any: GlobalPromise.any,\n        resolve: GlobalPromise.resolve,\n        reject: GlobalPromise.reject,\n        nthen: nativePromiseProto.then,\n        gthen: GlobalPromise.prototype.then\n    } : {};\n}\n\nexport function usePSD (psd, fn, a1, a2, a3) {\n    var outerScope = PSD;\n    try {\n        switchToZone(psd, true);\n        return fn(a1, a2, a3);\n    } finally {\n        switchToZone(outerScope, false);\n    }\n}\n\nfunction enqueueNativeMicroTask (job) {\n    //\n    // Precondition: nativePromiseThen !== undefined\n    //\n    nativePromiseThen.call(resolvedNativePromise, job);\n}\n\nfunction nativeAwaitCompatibleWrap(fn, zone, possibleAwait, cleanup) {\n    return typeof fn !== 'function' ? fn : function () {\n        var outerZone = PSD;\n        if (possibleAwait) incrementExpectedAwaits();\n        switchToZone(zone, true);\n        try {\n            return fn.apply(this, arguments);\n        } finally {\n            switchToZone(outerZone, false);\n            if (cleanup) enqueueNativeMicroTask(decrementExpectedAwaits);\n        }\n    };\n}\n\nfunction getPatchedPromiseThen (origThen, zone) {\n    return function (onResolved, onRejected) {\n        return origThen.call(this,\n            nativeAwaitCompatibleWrap(onResolved, zone),\n            nativeAwaitCompatibleWrap(onRejected, zone));\n    };\n}\n\nconst UNHANDLEDREJECTION = \"unhandledrejection\";\n\nfunction globalError(err, promise) {\n    var rv;\n    try {\n        rv = promise.onuncatched(err);\n    } catch (e) {}\n    if (rv !== false) try {\n        var event, eventData = {promise: promise, reason: err};\n        if (_global.document && document.createEvent) {\n            event = document.createEvent('Event');\n            event.initEvent(UNHANDLEDREJECTION, true, true);\n            extend(event, eventData);\n        } else if (_global.CustomEvent) {\n            event = new CustomEvent(UNHANDLEDREJECTION, {detail: eventData});\n            extend(event, eventData);\n        }\n        if (event && _global.dispatchEvent) {\n            dispatchEvent(event);\n            if (!_global.PromiseRejectionEvent && _global.onunhandledrejection)\n                // No native support for PromiseRejectionEvent but user has set window.onunhandledrejection. Manually call it.\n                try {_global.onunhandledrejection(event);} catch (_) {}\n        }\n        if (debug && event && !event.defaultPrevented) {\n            console.warn(`Unhandled rejection: ${err.stack || err}`);\n        }\n    } catch (e) {}\n}\n\nexport var rejection = DexiePromise.reject;\n\nexport {DexiePromise};\n", "import { PSD, rejection, newScope } from \"../helpers/promise\";\nimport { DexieOptions } from \"../public/types/dexie-constructor\";\nimport { errnames, exceptions } from \"../errors\";\nimport { nop } from \"./chaining-functions\";\nimport { Transaction } from \"../classes/transaction\";\nimport { Dexie } from '../classes/dexie';\n\n/* Generate a temporary transaction when db operations are done outside a transaction scope.\n*/\nexport function tempTransaction (\n  db: Dexie,\n  mode: IDBTransactionMode,\n  storeNames: string[],\n  fn: (resolve, reject, trans: Transaction) => any)\n  // Last argument is \"writeLocked\". But this doesnt apply to oneshot direct db operations, so we ignore it.\n{\n  if (!db.idbdb || (!db._state.openComplete && (!PSD.letThrough && !db._vip))) {\n    if (db._state.openComplete) {\n      // db.idbdb is falsy but openComplete is true. Must have been an exception durin open.\n      // Don't wait for openComplete as it would lead to infinite loop.\n      return rejection(new exceptions.DatabaseClosed(db._state.dbOpenError));\n    }\n    if (!db._state.isBeingOpened) {\n      if (!db._options.autoOpen)\n        return rejection(new exceptions.DatabaseClosed());\n      db.open().catch(nop); // Open in background. If if fails, it will be catched by the final promise anyway.\n    }\n    return db._state.dbReadyPromise.then(() => tempTransaction(db, mode, storeNames, fn));\n  } else {\n    var trans = db._createTransaction(mode, storeNames, db._dbSchema);\n    try {\n      trans.create();\n      db._state.PR1398_maxLoop = 3;\n    } catch (ex) {\n      if (ex.name === errnames.InvalidState && db.isOpen() && --db._state.PR1398_maxLoop > 0) {\n        console.warn('Dexie: Need to reopen db');\n        db._close();\n        return db.open().then(()=>tempTransaction(db, mode, storeNames, fn));\n      }\n      return rejection(ex);\n    }\n    return trans._promise(mode, (resolve, reject) => {\n      return newScope(() => { // OPTIMIZATION POSSIBLE? newScope() not needed because it's already done in _promise.\n        PSD.trans = trans;\n        return fn(resolve, reject, trans);\n      });\n    }).then(result => {\n      // Instead of resolving value directly, wait with resolving it until transaction has completed.\n      // Otherwise the data would not be in the DB if requesting it in the then() operation.\n      // Specifically, to ensure that the following expression will work:\n      //\n      //   db.friends.put({name: \"Arne\"}).then(function () {\n      //       db.friends.where(\"name\").equals(\"Arne\").count(function(count) {\n      //           assert (count === 1);\n      //       });\n      //   });\n      //\n      return trans._completion.then(() => result);\n    });/*.catch(err => { // Don't do this as of now. If would affect bulk- and modify methods in a way that could be more intuitive. But wait! Maybe change in next major.\n          trans._reject(err);\n          return rejection(err);\n      });*/\n  }\n}\n", "import { Dexie } from \"../classes/dexie\";\n\nexport const DEXIE_VERSION = '{version}'; // Replaced by build-script.\nexport const maxString = String.fromCharCode(65535);\nexport const minKey = -Infinity; // minKey can be constant. maxKey must be a prop of Dexie (_maxKey)\nexport const INVALID_KEY_ARGUMENT =\n  \"Invalid key provided. Keys must be of type string, number, Date or Array<string | number | Date>.\";\nexport const STRING_EXPECTED = \"String expected.\";\nexport const connections: Dexie[] = [];\nexport const isIEOrEdge =\n  typeof navigator !== 'undefined' && /(MSIE|Trident|Edge)/.test(navigator.userAgent);\nexport const hasIEDeleteObjectStoreBug = isIEOrEdge;\nexport const hangsOnDeleteLargeKeyRange = isIEOrEdge;\nexport const dexieStackFrameFilter = frame => !/(dexie\\.js|dexie\\.min\\.js)/.test(frame);\nexport const DBNAMES_DB = '__dbnames';\nexport const READONLY = 'readonly';\nexport const READWRITE = 'readwrite';\n", "export function combine(filter1, filter2) {\n  return filter1 ?\n      filter2 ?\n          function () { return filter1.apply(this, arguments) && filter2.apply(this, arguments); } :\n          filter1 :\n      filter2;\n}\n", "import { DBCoreKeyRange, DBCoreRangeType } from '../public/types/dbcore';\n\nexport const AnyRange: DBCoreKeyRange = {\n  type: DBCoreRangeType.Any,\n  lower: -Infinity,\n  lowerOpen: false,\n  upper: [[]],\n  upperOpen: false\n}\n\nexport const NeverRange: DBCoreKeyRange = {\n  type: DBCoreRangeType.Never,\n  lower: -Infinity,\n  lowerOpen: true,\n  upper: -Infinity,\n  upperOpen: true\n}\n", "import { deepClone, delByKeyPath, getByKeyPath } from './utils';\n\n// This workaround is needed since obj could be a custom-class instance with an\n// uninitialized keyPath. See the following comment for more context:\n// https://github.com/dfahlander/Dexie.js/issues/1280#issuecomment-823557881\nexport function workaroundForUndefinedPrimKey(keyPath: string | ArrayLike<string>) {\n  // Workaround only needed for plain non-dotted keyPaths\n  return typeof keyPath === \"string\" && !/\\./.test(keyPath) \n  ? (obj: object) => {\n    if (obj[keyPath] === undefined && (keyPath in obj)) {\n      // property exists but is undefined. This will not be liked by Indexeddb.\n      // Need to remove the property before adding it but we need to clone it before\n      // doing that to not be intrusive.\n      obj = deepClone(obj);\n      delete obj[keyPath];\n    }\n    return obj;\n  }\n  : (obj: object) => obj;\n}", "import { BulkError, exceptions } from '../../errors';\nimport { Table as ITable } from '../../public/types/table';\nimport { TableSchema } from '../../public/types/table-schema';\nimport { TableHooks } from '../../public/types/table-hooks';\nimport { DexiePromise as Promise, PSD, newScope, wrap, rejection, beginMicroTickScope, endMicroTickScope } from '../../helpers/promise';\nimport { Transaction } from '../transaction';\nimport { Dexie } from '../dexie';\nimport { tempTransaction } from '../../functions/temp-transaction';\nimport { Collection } from '../collection';\nimport { isArray, keys, getByKeyPath, hasOwn, setByKeyPath, deepClone, tryCatch, arrayToObject, extend } from '../../functions/utils';\nimport { maxString } from '../../globals/constants';\nimport { combine } from '../../functions/combine';\nimport { PromiseExtended } from \"../../public/types/promise-extended\";\nimport { IndexableType } from '../../public/types/indexable-type';\nimport { debug } from '../../helpers/debug';\nimport { DBCoreTable } from '../../public/types/dbcore';\nimport { AnyRange } from '../../dbcore/keyrange';\nimport { workaroundForUndefinedPrimKey } from '../../functions/workaround-undefined-primkey';\n\n/** class Table\n * \n * https://dexie.org/docs/Table/Table\n */\nexport class Table implements ITable<any, IndexableType> {\n  db: Dexie;\n  _tx?: Transaction;\n  name: string;\n  schema: TableSchema;\n  hook: TableHooks;\n  core: DBCoreTable;\n\n  _trans(\n    mode: IDBTransactionMode,\n    fn: (idbtrans: IDBTransaction, dxTrans: Transaction) => PromiseLike<any> | void,\n    writeLocked?: boolean | string) : PromiseExtended<any>\n  {\n    const trans: Transaction = this._tx || PSD.trans;\n    const tableName = this.name;\n    \n    function checkTableInTransaction(resolve, reject, trans: Transaction) {\n      if (!trans.schema[tableName])\n        throw new exceptions.NotFound(\"Table \" + tableName + \" not part of transaction\");\n      return fn(trans.idbtrans, trans);\n    }\n    // Surround all in a microtick scope.\n    // Reason: Browsers (modern Safari + older others)\n    // still as of 2018-10-10 has problems keeping a transaction\n    // alive between micro ticks. Safari because if transaction\n    // is created but not used in same microtick, it will go\n    // away. That specific issue could be solved in DBCore\n    // by opening the transaction just before using it instead.\n    // But older Firefoxes and IE11 (with Promise polyfills)\n    // will still have probs.\n    // The beginMicrotickScope()/endMicrotickScope() works\n    // in cooperation with Dexie.Promise to orchestrate\n    // the micro-ticks in endMicrotickScope() rather than\n    // in native engine.\n    const wasRootExec = beginMicroTickScope();\n    try {\n      return trans && trans.db === this.db ?\n        trans === PSD.trans ?\n          trans._promise(mode, checkTableInTransaction, writeLocked) :\n          newScope(() => trans._promise(mode, checkTableInTransaction, writeLocked), { trans: trans, transless: PSD.transless || PSD }) :\n        tempTransaction(this.db, mode, [this.name], checkTableInTransaction);\n    } finally {\n      if (wasRootExec) endMicroTickScope();\n    }\n  }\n\n  /** Table.get()\n   * \n   * https://dexie.org/docs/Table/Table.get()\n   * \n   **/\n  get(keyOrCrit, cb?) {\n    if (keyOrCrit && keyOrCrit.constructor === Object)\n      return this.where(keyOrCrit as { [key: string]: IndexableType }).first(cb);\n\n    return this._trans('readonly', (trans) => {\n      return this.core.get({trans, key: keyOrCrit})\n        .then(res => this.hook.reading.fire(res));\n    }).then(cb);\n  }\n\n  /** Table.where()\n   * \n   * https://dexie.org/docs/Table/Table.where()\n   * \n   **/\n  where(indexOrCrit: string | string[] | { [key: string]: IndexableType }) {\n    if (typeof indexOrCrit === 'string')\n      return new this.db.WhereClause(this, indexOrCrit);\n    if (isArray(indexOrCrit))\n      return new this.db.WhereClause(this, `[${indexOrCrit.join('+')}]`);\n    // indexOrCrit is an object map of {[keyPath]:value} \n    const keyPaths = keys(indexOrCrit);\n    if (keyPaths.length === 1)\n      // Only one critera. This was the easy case:\n      return this\n        .where(keyPaths[0])\n        .equals(indexOrCrit[keyPaths[0]]);\n\n    // Multiple criterias.\n    // Let's try finding a compound index that matches all keyPaths in\n    // arbritary order:\n    const compoundIndex = this.schema.indexes.concat(this.schema.primKey).filter(ix =>\n      ix.compound &&\n      keyPaths.every(keyPath => ix.keyPath.indexOf(keyPath) >= 0) &&\n      (ix.keyPath as string[]).every(keyPath => keyPaths.indexOf(keyPath) >= 0))[0];\n\n    if (compoundIndex && this.db._maxKey !== maxString)\n      // Cool! We found such compound index\n      // and this browser supports compound indexes (maxKey !== maxString)!\n      return this\n        .where(compoundIndex.name)\n        .equals((compoundIndex.keyPath as string[]).map(kp => indexOrCrit[kp]));\n\n    if (!compoundIndex && debug) console.warn(\n      `The query ${JSON.stringify(indexOrCrit)} on ${this.name} would benefit of a ` +\n      `compound index [${keyPaths.join('+')}]`);\n\n    // Ok, now let's fallback to finding at least one matching index\n    // and filter the rest.\n    const { idxByName } = this.schema;\n    const idb = this.db._deps.indexedDB;\n\n    function equals (a, b) {\n      try {\n        return idb.cmp(a,b) === 0; // Works with all indexable types including binary keys.\n      } catch (e) {\n        return false;\n      }\n    }\n\n    const [idx, filterFunction] = keyPaths.reduce(([prevIndex, prevFilterFn], keyPath) => {\n      const index = idxByName[keyPath];\n      const value = indexOrCrit[keyPath];\n      return [\n        prevIndex || index, // idx::=Pick index of first matching keypath\n        prevIndex || !index ? // filter::=null if not needed, otherwise combine function filter\n          combine(\n            prevFilterFn,\n            index && index.multi ?\n              x => {\n                const prop = getByKeyPath(x, keyPath);\n                return isArray(prop) && prop.some(item => equals(value, item));\n              } : x => equals(value, getByKeyPath(x, keyPath)))\n          : prevFilterFn\n      ];\n    }, [null, null]);\n\n    return idx ?\n      this.where(idx.name).equals(indexOrCrit[idx.keyPath])\n        .filter(filterFunction) :\n      compoundIndex ?\n        this.filter(filterFunction) : // Has compound but browser bad. Allow filter.\n        this.where(keyPaths).equals(''); // No index at all. Fail lazily with \"[a+b+c] is not indexed\"\n  }\n\n  /** Table.filter()\n   * \n   * https://dexie.org/docs/Table/Table.filter()\n   * \n   **/\n  filter(filterFunction: (obj: any) => boolean) {\n    return this.toCollection().and(filterFunction);\n  }\n\n  /** Table.count()\n   * \n   * https://dexie.org/docs/Table/Table.count()\n   * \n   **/\n  count(thenShortcut?: any) {\n    return this.toCollection().count(thenShortcut);\n  }\n\n  /** Table.offset()\n   * \n   * https://dexie.org/docs/Table/Table.offset()\n   * \n   **/\n  offset(offset: number) {\n    return this.toCollection().offset(offset);\n  }\n\n  /** Table.limit()\n   * \n   * https://dexie.org/docs/Table/Table.limit()\n   * \n   **/\n  limit(numRows: number) {\n    return this.toCollection().limit(numRows);\n  }\n\n  /** Table.each()\n   * \n   * https://dexie.org/docs/Table/Table.each()\n   * \n   **/\n  each(callback: (obj: any, cursor: { key: IndexableType, primaryKey: IndexableType }) => any) {\n    return this.toCollection().each(callback);\n  }\n\n  /** Table.toArray()\n   * \n   * https://dexie.org/docs/Table/Table.toArray()\n   * \n   **/\n  toArray(thenShortcut?: any) {\n    return this.toCollection().toArray(thenShortcut);\n  }\n\n  /** Table.toCollection()\n   * \n   * https://dexie.org/docs/Table/Table.toCollection()\n   * \n   **/\n  toCollection() {\n    return new this.db.Collection(new this.db.WhereClause(this));\n  }\n\n  /** Table.orderBy()\n   * \n   * https://dexie.org/docs/Table/Table.orderBy()\n   * \n   **/\n  orderBy(index: string | string[]) {\n    return new this.db.Collection(\n      new this.db.WhereClause(this, isArray(index) ?\n        `[${index.join('+')}]` :\n        index));\n  }\n\n  /** Table.reverse()\n   * \n   * https://dexie.org/docs/Table/Table.reverse()\n   * \n   **/\n  reverse(): Collection {\n    return this.toCollection().reverse();\n  }\n\n  /** Table.mapToClass()\n   * \n   * https://dexie.org/docs/Table/Table.mapToClass()\n   * \n   **/\n  mapToClass(constructor: Function) {\n    this.schema.mappedClass = constructor;\n    // Now, subscribe to the when(\"reading\") event to make all objects that come out from this table inherit from given class\n    // no matter which method to use for reading (Table.get() or Table.where(...)... )\n    const readHook = obj => {\n      if (!obj) return obj; // No valid object. (Value is null). Return as is.\n      // Create a new object that derives from constructor:\n      const res = Object.create(constructor.prototype);\n      // Clone members:\n      for (var m in obj) if (hasOwn(obj, m)) try { res[m] = obj[m]; } catch (_) { }\n      return res;\n    };\n\n    if (this.schema.readHook) {\n      this.hook.reading.unsubscribe(this.schema.readHook);\n    }\n    this.schema.readHook = readHook;\n    this.hook(\"reading\", readHook);\n    return constructor;\n  }\n\n  /** @deprecated */\n  defineClass() {\n    function Class (content){\n      extend(this, content);\n    };\n    return this.mapToClass(Class);\n  }\n\n  /** Table.add()\n   * \n   * https://dexie.org/docs/Table/Table.add()\n   * \n   **/\n  add(obj, key?: IndexableType): PromiseExtended<IndexableType> {\n    const {auto, keyPath} = this.schema.primKey;\n    let objToAdd = obj;\n    if (keyPath && auto) {\n      objToAdd = workaroundForUndefinedPrimKey(keyPath)(obj);\n    }\n    return this._trans('readwrite', trans => {\n      return this.core.mutate({trans, type: 'add', keys: key != null ? [key] : null, values: [objToAdd]});\n    }).then(res => res.numFailures ? Promise.reject(res.failures[0]) : res.lastResult)\n    .then(lastResult => {\n      if (keyPath) {\n        // This part should be here for backward compatibility.\n        // If ever feeling too bad about this, please wait to a new major before removing it,\n        // and document the change thoroughly.\n        try{setByKeyPath(obj, keyPath, lastResult);}catch(_){};\n      }\n      return lastResult;\n    });\n  }\n\n  /** Table.update()\n   * \n   * https://dexie.org/docs/Table/Table.update()\n   * \n   **/\n  update(keyOrObject, modifications: { [keyPath: string]: any; } | ((obj: any, ctx:{value: any, primKey: IndexableType}) => void | boolean)): PromiseExtended<number> {\n    if (typeof keyOrObject === 'object' && !isArray(keyOrObject)) {\n      const key = getByKeyPath(keyOrObject, this.schema.primKey.keyPath);\n      if (key === undefined) return rejection(new exceptions.InvalidArgument(\n        \"Given object does not contain its primary key\"));\n      // object to modify. Also modify given object with the modifications:\n      // This part should be here for backward compatibility.\n      // If ever feeling too bad about mutating given object, please wait to a new major before removing it,\n      // and document the change thoroughly.\n      try {\n        if (typeof modifications !== \"function\") {\n          keys(modifications).forEach(keyPath => {\n            setByKeyPath(keyOrObject, keyPath, modifications[keyPath]);\n          });\n        } else {\n          // Now since we support function argument, we should have a similar behavior here as well\n          // (as long as we do this mutability stuff on the given object)\n          modifications(keyOrObject, {value: keyOrObject, primKey: key});\n        }\n      } catch {\n        // Maybe given object was frozen.\n        // This part is not essential. Just move on as nothing happened...\n      }\n      return this.where(\":id\").equals(key).modify(modifications);\n    } else {\n      // key to modify\n      return this.where(\":id\").equals(keyOrObject).modify(modifications);\n    }\n  }\n\n  /** Table.put()\n   * \n   * https://dexie.org/docs/Table/Table.put()\n   * \n   **/\n  put(obj, key?: IndexableType): PromiseExtended<IndexableType> {\n    const {auto, keyPath} = this.schema.primKey;\n    let objToAdd = obj;\n    if (keyPath && auto) {\n      objToAdd = workaroundForUndefinedPrimKey(keyPath)(obj);\n    }\n    return this._trans(\n      'readwrite',\n      trans => this.core.mutate({trans, type: 'put', values: [objToAdd], keys: key != null ? [key] : null}))\n    .then(res => res.numFailures ? Promise.reject(res.failures[0]) : res.lastResult)\n    .then(lastResult => {\n      if (keyPath) {\n        // This part should be here for backward compatibility.\n        // If ever feeling too bad about this, please wait to a new major before removing it,\n        // and document the change thoroughly.\n        try{setByKeyPath(obj, keyPath, lastResult);}catch(_){};\n      }\n      return lastResult;\n    });\n  }\n\n  /** Table.delete()\n   * \n   * https://dexie.org/docs/Table/Table.delete()\n   * \n   **/\n  delete(key: IndexableType): PromiseExtended<void> {\n    return this._trans('readwrite',\n      trans => this.core.mutate({trans, type: 'delete', keys: [key]}))\n    .then(res => res.numFailures ? Promise.reject(res.failures[0]) : undefined);\n  }\n\n  /** Table.clear()\n   * \n   * https://dexie.org/docs/Table/Table.clear()\n   * \n   **/\n  clear() {\n    return this._trans('readwrite',\n      trans => this.core.mutate({trans, type: 'deleteRange', range: AnyRange}))\n        .then(res => res.numFailures ? Promise.reject(res.failures[0]) : undefined);\n  }\n\n  /** Table.bulkGet()\n   * \n   * https://dexie.org/docs/Table/Table.bulkGet()\n   * \n   * @param keys \n   */\n  bulkGet(keys: IndexableType[]) {\n    return this._trans('readonly', trans => {\n      return this.core.getMany({\n        keys,\n        trans\n      }).then(result => result.map(res => this.hook.reading.fire(res)));\n    });\n  }\n\n  /** Table.bulkAdd()\n   * \n   * https://dexie.org/docs/Table/Table.bulkAdd()\n   * \n   **/\n  bulkAdd(\n    objects: any[],\n    keysOrOptions?: ReadonlyArray<IndexableType> | { allKeys?: boolean },\n    options?: { allKeys?: boolean }\n  ) {    \n    const keys = Array.isArray(keysOrOptions) ? keysOrOptions : undefined;\n    options = options || (keys ? undefined : keysOrOptions as { allKeys?: boolean });\n    const wantResults = options ? options.allKeys : undefined;\n\n    return this._trans('readwrite', trans => {\n      const {auto, keyPath} = this.schema.primKey;\n      if (keyPath && keys)\n        throw new exceptions.InvalidArgument(\"bulkAdd(): keys argument invalid on tables with inbound keys\");\n      if (keys && keys.length !== objects.length)\n        throw new exceptions.InvalidArgument(\"Arguments objects and keys must have the same length\");\n\n      const numObjects = objects.length; // Pick length here to allow garbage collection of objects later\n      let objectsToAdd = keyPath && auto ?\n        objects.map(workaroundForUndefinedPrimKey(keyPath)) :\n        objects;\n      return this.core.mutate(\n        {trans, type: 'add', keys: keys as IndexableType[], values: objectsToAdd, wantResults}\n      )\n        .then(({numFailures, results,lastResult, failures}) => {\n          const result = wantResults ? results : lastResult;\n          if (numFailures === 0) return result;\n          throw new BulkError(\n            `${this.name}.bulkAdd(): ${numFailures} of ${numObjects} operations failed`, failures);\n        });\n    });\n  }\n\n  /** Table.bulkPut()\n   * \n   * https://dexie.org/docs/Table/Table.bulkPut()\n   * \n   **/\n  bulkPut(\n    objects: any[],\n    keysOrOptions?: ReadonlyArray<IndexableType> | { allKeys?: boolean },\n    options?: { allKeys?: boolean }\n  ) {   \n    const keys = Array.isArray(keysOrOptions) ? keysOrOptions : undefined;\n    options = options || (keys ? undefined : keysOrOptions as { allKeys?: boolean });\n    const wantResults = options ? options.allKeys : undefined;\n\n    return this._trans('readwrite', trans => {\n      const {auto, keyPath} = this.schema.primKey;\n      if (keyPath && keys)\n        throw new exceptions.InvalidArgument(\"bulkPut(): keys argument invalid on tables with inbound keys\");\n      if (keys && keys.length !== objects.length)\n        throw new exceptions.InvalidArgument(\"Arguments objects and keys must have the same length\");\n\n      const numObjects = objects.length; // Pick length here to allow garbage collection of objects later\n      let objectsToPut = keyPath && auto ?\n        objects.map(workaroundForUndefinedPrimKey(keyPath)) :\n        objects;\n\n      return this.core.mutate(\n        {trans, type: 'put', keys: keys as IndexableType[], values: objectsToPut, wantResults}\n      )\n        .then(({numFailures, results, lastResult, failures}) => {\n          const result = wantResults ? results : lastResult;\n          if (numFailures === 0) return result;\n          throw new BulkError(\n            `${this.name}.bulkPut(): ${numFailures} of ${numObjects} operations failed`, failures);\n        });\n    });\n  }\n\n  /** Table.bulkDelete()\n   * \n   * https://dexie.org/docs/Table/Table.bulkDelete()\n   * \n   **/\n  bulkDelete(keys: ReadonlyArray<IndexableType>): PromiseExtended<void> {\n    const numKeys = keys.length;\n    return this._trans('readwrite', trans => {\n      return this.core.mutate({trans, type: 'delete', keys: keys as IndexableType[]});\n    }).then(({numFailures, lastResult, failures}) => {\n      if (numFailures === 0) return lastResult;\n      throw new BulkError(\n        `${this.name}.bulkDelete(): ${numFailures} of ${numKeys} operations failed`, failures);\n    });\n  }\n}\n", "import {keys, isArray, asap} from '../functions/utils';\nimport {nop, mirror, reverseStoppableEventChain} from '../functions/chaining-functions';\nimport {exceptions} from '../errors';\n\nexport default function Events(ctx) {\n    var evs = {};\n    var rv = function (eventName, subscriber) {\n        if (subscriber) {\n            // Subscribe. If additional arguments than just the subscriber was provided, forward them as well.\n            var i = arguments.length, args = new Array(i - 1);\n            while (--i) args[i - 1] = arguments[i];\n            evs[eventName].subscribe.apply(null, args);\n            return ctx;\n        } else if (typeof (eventName) === 'string') {\n            // Return interface allowing to fire or unsubscribe from event\n            return evs[eventName];\n        }\n    };\n    rv.addEventType = add;\n    \n    for (var i = 1, l = arguments.length; i < l; ++i) {\n        add(arguments[i]);\n    }\n    \n    return rv;\n\n    function add(eventName, chainFunction, defaultFunction) {\n        if (typeof eventName === 'object') return addConfiguredEvents(eventName);\n        if (!chainFunction) chainFunction = reverseStoppableEventChain;\n        if (!defaultFunction) defaultFunction = nop;\n\n        var context = {\n            subscribers: [],\n            fire: defaultFunction,\n            subscribe: function (cb) {\n                if (context.subscribers.indexOf(cb) === -1) {\n                    context.subscribers.push(cb);\n                    context.fire = chainFunction(context.fire, cb);\n                }\n            },\n            unsubscribe: function (cb) {\n                context.subscribers = context.subscribers.filter(function (fn) { return fn !== cb; });\n                context.fire = context.subscribers.reduce(chainFunction, defaultFunction);\n            }\n        };\n        evs[eventName] = rv[eventName] = context;\n        return context;\n    }\n\n    function addConfiguredEvents(cfg) {\n        // events(this, {reading: [functionChain, nop]});\n        keys(cfg).forEach(function (eventName) {\n            var args = cfg[eventName];\n            if (isArray(args)) {\n                add(eventName, cfg[eventName][0], cfg[eventName][1]);\n            } else if (args === 'asap') {\n                // Rather than approaching event subscription using a functional approach, we here do it in a for-loop where subscriber is executed in its own stack\n                // enabling that any exception that occur wont disturb the initiator and also not nescessary be catched and forgotten.\n                var context = add(eventName, mirror, function fire() {\n                    // Optimazation-safe cloning of arguments into args.\n                    var i = arguments.length, args = new Array(i);\n                    while (i--) args[i] = arguments[i];\n                    // All each subscriber:\n                    context.subscribers.forEach(function (fn) {\n                        asap(function fireEvent() {\n                            fn.apply(null, args);\n                        });\n                    });\n                });\n            } else throw new exceptions.InvalidArgument(\"Invalid event config\");\n        });\n    }\n}\n", "import { arrayToObject, derive } from './utils';\n\n\nexport function makeClassConstructor<TConstructor> (prototype: Object, constructor: Function) {\n  /*const propertyDescriptorMap = arrayToObject(\n    Object.getOwnPropertyNames(prototype),\n    propKey => [propKey, Object.getOwnPropertyDescriptor(prototype, propKey)]);\n\n  // Both derive and clone the prototype.\n  //   derive: So that x instanceof T returns true when T is the class template.\n  //   clone: Optimizes method access a bit (but actually not nescessary)\n  const derivedPrototypeClone = Object.create(prototype, propertyDescriptorMap);\n  derivedPrototypeClone.constructor = constructor;\n  constructor.prototype = derivedPrototypeClone;\n  return constructor as any as TConstructor;*/\n\n  // Keep the above code in case we want to clone AND derive the parent prototype.\n  // Reason would be optimization of property access.\n  // The code below will only create a prototypal inheritance from given constructor function\n  // to given prototype.\n  derive(constructor).from({prototype});\n  return constructor as any as TConstructor;  \n}\n", "import { Dexie } from '../dexie';\nimport { TableSchema } from '../../public/types/table-schema';\nimport { Transaction } from '../transaction/transaction';\nimport { hookCreatingChain, pureFunctionChain, nop, mirror, hookUpdatingChain, hookDeletingChain } from '../../functions/chaining-functions';\nimport { TableHooks } from '../../public/types/table-hooks';\nimport { Table } from './table';\nimport Events from '../../helpers/Events';\nimport { makeClassConstructor } from '../../functions/make-class-constructor';\n\nexport interface TableConstructor {\n  new (name: string, tableSchema: TableSchema, optionalTrans?: Transaction) : Table;\n  prototype: Table;\n}\n\n/** Generates a Table constructor bound to given Dexie instance.\n * \n * The purpose of having dynamically created constructors, is to allow\n * addons to extend classes for a certain Dexie instance without affecting\n * other db instances.\n */\nexport function createTableConstructor (db: Dexie) {\n  return makeClassConstructor<TableConstructor>(\n    Table.prototype,\n\n    function Table (this: Table, name: string, tableSchema: TableSchema, trans?: Transaction) {\n      this.db = db;\n      this._tx = trans;\n      this.name = name;\n      this.schema = tableSchema;\n      this.hook = db._allTables[name] ? db._allTables[name].hook : Events(null, {\n        \"creating\": [hookCreatingChain, nop],\n        \"reading\": [pureFunctionChain, mirror],\n        \"updating\": [hookUpdatingChain, nop],\n        \"deleting\": [hookDeletingChain, nop]\n      }) as TableHooks;\n    }\n\n  );\n}\n", "import { combine } from \"../../functions/combine\";\nimport { exceptions } from \"../../errors\";\nimport { hasOwn } from \"../../functions/utils\";\nimport { wrap } from \"../../helpers/promise\";\nimport { Collection } from './';\nimport { DBCoreCursor, DBCoreTable, DBCoreTransaction, DBCoreTableSchema, DBCoreRangeType } from '../../public/types/dbcore';\nimport { nop } from '../../functions/chaining-functions';\n\ntype CollectionContext = Collection[\"_ctx\"];\n\nexport function isPlainKeyRange (ctx: CollectionContext, ignoreLimitFilter?: boolean) {\n  return !(ctx.filter || ctx.algorithm || ctx.or) &&\n      (ignoreLimitFilter ? ctx.justLimit : !ctx.replayFilter);\n}    \n\nexport function addFilter(ctx: CollectionContext, fn: Function) {\n  ctx.filter = combine(ctx.filter, fn);\n}\n\nexport function addReplayFilter (ctx: CollectionContext, factory, isLimitFilter?) {\n  var curr = ctx.replayFilter;\n  ctx.replayFilter = curr ? ()=>combine(curr(), factory()) : factory;\n  ctx.justLimit = isLimitFilter && !curr;\n}\n\nexport function addMatchFilter(ctx: CollectionContext, fn) {\n  ctx.isMatch = combine(ctx.isMatch, fn);\n}\n\nexport function getIndexOrStore(ctx: CollectionContext, coreSchema: DBCoreTableSchema) {\n  // TODO: Rewrite this. No need to know ctx.isPrimKey. ctx.index should hold the keypath.\n  // Still, throw if not found!\n  if (ctx.isPrimKey) return coreSchema.primaryKey;\n  const index = coreSchema.getIndexByKeyPath(ctx.index);\n  if (!index) throw new exceptions.Schema(\"KeyPath \" + ctx.index + \" on object store \" + coreSchema.name + \" is not indexed\");\n  return index;\n}\n\nexport function openCursor(ctx: CollectionContext, coreTable: DBCoreTable, trans: DBCoreTransaction) {\n  const index = getIndexOrStore(ctx, coreTable.schema);\n  return coreTable.openCursor({\n    trans,\n    values: !ctx.keysOnly,\n    reverse: ctx.dir === 'prev',\n    unique: !!ctx.unique,\n    query: {\n      index, \n      range: ctx.range\n    }\n  });\n}\n\nexport function iter (\n  ctx: CollectionContext, \n  fn: (item, cursor: DBCoreCursor, advance: Function)=>void,\n  coreTrans: DBCoreTransaction,\n  coreTable: DBCoreTable): Promise<any>\n{\n  const filter = ctx.replayFilter ? combine(ctx.filter, ctx.replayFilter()) : ctx.filter;\n  if (!ctx.or) {\n      return iterate(\n        openCursor(ctx, coreTable, coreTrans),\n        combine(ctx.algorithm, filter), fn, !ctx.keysOnly && ctx.valueMapper);\n  } else {\n      const set = {};\n\n      const union = (item: any, cursor: DBCoreCursor, advance) => {\n          if (!filter || filter(cursor, advance, result=>cursor.stop(result), err => cursor.fail(err))) {\n              var primaryKey = cursor.primaryKey;\n              var key = '' + primaryKey;\n              if (key === '[object ArrayBuffer]') key = '' + new Uint8Array(primaryKey);\n              if (!hasOwn(set, key)) {\n                  set[key] = true;\n                  fn(item, cursor, advance);\n              }\n          }\n      }\n\n      return Promise.all([\n        ctx.or._iterate(union, coreTrans),\n        iterate(openCursor(ctx, coreTable, coreTrans), ctx.algorithm, union, !ctx.keysOnly && ctx.valueMapper)\n      ]);\n  }\n}\n\nfunction iterate(cursorPromise: Promise<DBCoreCursor>, filter, fn, valueMapper): Promise<any> {\n  \n  // Apply valueMapper (hook('reading') or mappped class)\n  var mappedFn = valueMapper ? (x,c,a) => fn(valueMapper(x),c,a) : fn;\n  // Wrap fn with PSD and microtick stuff from Promise.\n  var wrappedFn = wrap(mappedFn);\n  \n  return cursorPromise.then(cursor => {\n    if (cursor) {\n      return cursor.start(()=>{\n        var c = ()=>cursor.continue();\n        if (!filter || filter(cursor, advancer => c = advancer, val=>{cursor.stop(val);c=nop}, e => {cursor.fail(e);c = nop;}))\n          wrappedFn(cursor.value, cursor, advancer => c = advancer);\n        c();\n      });\n    }\n  });\n}\n", "// Implementation of https://www.w3.org/TR/IndexedDB-3/#compare-two-keys\n\nimport { toStringTag } from './utils';\n\n// ... with the adjustment to return NaN instead of throwing.\nexport function cmp(a: any, b: any): number {\n  try {\n    const ta = type(a);\n    const tb = type(b);\n    if (ta !== tb) {\n      if (ta === 'Array') return 1;\n      if (tb === 'Array') return -1;\n      if (ta === 'binary') return 1;\n      if (tb === 'binary') return -1;\n      if (ta === 'string') return 1;\n      if (tb === 'string') return -1;\n      if (ta === 'Date') return 1;\n      if (tb !== 'Date') return NaN;\n      return -1;\n    }\n    switch (ta) {\n      case 'number':\n      case 'Date':\n      case 'string':\n        return a > b ? 1 : a < b ? -1 : 0;\n      case 'binary': {\n        return compareUint8Arrays(getUint8Array(a), getUint8Array(b));\n      }\n      case 'Array':\n        return compareArrays(a, b);\n    }\n  } catch {}\n  return NaN; // Return value if any given args are valid keys.\n}\n\nexport function compareArrays(a: any[], b: any[]): number {\n  const al = a.length;\n  const bl = b.length;\n  const l = al < bl ? al : bl;\n  for (let i = 0; i < l; ++i) {\n    const res = cmp(a[i], b[i]);\n    if (res !== 0) return res;\n  }\n  return al === bl ? 0 : al < bl ? -1 : 1;\n}\n\nexport function compareUint8Arrays(\n  a: Uint8Array,\n  b: Uint8Array\n) {\n  const al = a.length;\n  const bl = b.length;\n  const l = al < bl ? al : bl;\n  for (let i = 0; i < l; ++i) {\n    if (a[i] !== b[i]) return a[i] < b[i] ? -1 : 1;\n  }\n  return al === bl ? 0 : al < bl ? -1 : 1;\n}\n\n// Implementation of https://www.w3.org/TR/IndexedDB-3/#key-type\nfunction type(x: any) {\n  const t = typeof x;\n  if (t !== 'object') return t;\n  if (ArrayBuffer.isView(x)) return 'binary';\n  const tsTag = toStringTag(x); // Cannot use instanceof in Safari\n  return tsTag === 'ArrayBuffer' ? 'binary' : (tsTag as 'Array' | 'Date');\n}\n\ntype BinaryType =\n  | ArrayBuffer\n  | DataView\n  | Uint8ClampedArray\n  | ArrayBufferView\n  | Uint8Array\n  | Int8Array\n  | Uint16Array\n  | Int16Array\n  | Uint32Array\n  | Int32Array\n  | Float32Array\n  | Float64Array;\n\nfunction getUint8Array(a: BinaryType): Uint8Array {\n  if (a instanceof Uint8Array) return a;\n  if (ArrayBuffer.isView(a))\n    // TypedArray or DataView\n    return new Uint8Array(a.buffer, a.byteOffset, a.byteLength);\n  return new Uint8Array(a); // ArrayBuffer\n}\n", "import { Collection as ICollection } from \"../../public/types/collection\";\nimport { Dexie } from \"../dexie\";\nimport { Table } from \"../table\";\nimport { IndexableType, IndexableTypeArrayReadonly } from \"../../public/types/indexable-type\";\nimport { PromiseExtended } from \"../../public/types/promise-extended\";\nimport { iter, isPlainKeyRange, getIndexOrStore, addReplayFilter, addFilter, addMatchFilter } from \"./collection-helpers\";\nimport { rejection } from \"../../helpers/promise\";\nimport { combine } from \"../../functions/combine\";\nimport { extend, hasOwn, deepClone, keys, setByKeyPath, getByKeyPath } from \"../../functions/utils\";\nimport { ModifyError } from \"../../errors\";\nimport { hangsOnDeleteLargeKeyRange } from \"../../globals/constants\";\nimport { ThenShortcut } from \"../../public/types/then-shortcut\";\nimport { Transaction } from '../transaction';\nimport { DBCoreCursor, DBCoreTransaction, DBCoreRangeType, DBCoreMutateResponse, DBCoreKeyRange } from '../../public/types/dbcore';\nimport { cmp } from \"../../functions/cmp\";\n\n/** class Collection\n * \n * https://dexie.org/docs/Collection/Collection\n */\nexport class Collection implements ICollection {\n  db: Dexie;\n  _ctx: {\n    table: Table;\n    index?: string | null;\n    isPrimKey?: boolean;\n    range: DBCoreKeyRange;\n    keysOnly: boolean;\n    dir: \"next\" | \"prev\";\n    unique: \"\" | \"unique\";\n    algorithm?: Function | null;\n    filter?: Function | null;\n    replayFilter: Function | null;\n    justLimit: boolean; // True if a replayFilter is just a filter that performs a \"limit\" operation (or none at all)\n    isMatch: Function | null;\n    offset: number,\n    limit: number,\n    error: any, // If set, any promise must be rejected with this error\n    or: Collection,\n    valueMapper: (any) => any\n  }\n  \n  _ondirectionchange?: Function;\n\n  _read<T>(fn: (idbtrans: IDBTransaction, dxTrans: Transaction) => PromiseLike<T>, cb?): PromiseExtended<T> {\n    var ctx = this._ctx;\n    return ctx.error ?\n      ctx.table._trans(null, rejection.bind(null, ctx.error)) :\n      ctx.table._trans('readonly', fn).then(cb);\n  }\n\n  _write<T>(fn: (idbtrans: IDBTransaction, dxTrans: Transaction) => PromiseLike<T>): PromiseExtended<T> {\n    var ctx = this._ctx;\n    return ctx.error ?\n      ctx.table._trans(null, rejection.bind(null, ctx.error)) :\n      ctx.table._trans('readwrite', fn, \"locked\"); // When doing write operations on collections, always lock the operation so that upcoming operations gets queued.\n  }\n\n  _addAlgorithm(fn) {\n    var ctx = this._ctx;\n    ctx.algorithm = combine(ctx.algorithm, fn);\n  }\n\n  _iterate(\n    fn: (item, cursor: DBCoreCursor, advance: Function) => void,\n    coreTrans: DBCoreTransaction) : Promise<any>\n  {\n    return iter(this._ctx, fn, coreTrans, this._ctx.table.core);\n  }\n\n  /** Collection.clone()\n   * \n   * https://dexie.org/docs/Collection/Collection.clone()\n   * \n   **/\n  clone(props?) {\n    var rv = Object.create(this.constructor.prototype),\n      ctx = Object.create(this._ctx);\n    if (props) extend(ctx, props);\n    rv._ctx = ctx;\n    return rv;\n  }\n\n  /** Collection.raw()\n   * \n   * https://dexie.org/docs/Collection/Collection.raw()\n   * \n   **/\n  raw() {\n    this._ctx.valueMapper = null;\n    return this;\n  }\n\n  /** Collection.each()\n   * \n   * https://dexie.org/docs/Collection/Collection.each()\n   * \n   **/\n  each(fn: (obj, cursor: DBCoreCursor) => any): PromiseExtended<void> {\n    var ctx = this._ctx;\n\n    return this._read(trans => iter(ctx, fn, trans, ctx.table.core));\n  }\n\n  /** Collection.count()\n   * \n   * https://dexie.org/docs/Collection/Collection.count()\n   * \n   **/\n  count(cb?) {\n    return this._read(trans => {\n      const ctx = this._ctx;\n      const coreTable = ctx.table.core;\n      if (isPlainKeyRange(ctx, true)) {\n        // This is a plain key range. We can use the count() method if the index.\n        return coreTable.count({\n          trans,\n          query: {\n            index: getIndexOrStore(ctx, coreTable.schema),\n            range: ctx.range\n          }\n        }).then(count => Math.min(count, ctx.limit));\n      } else {\n        // Algorithms, filters or expressions are applied. Need to count manually.\n        var count = 0;\n        return iter(ctx, () => { ++count; return false; }, trans, coreTable)\n        .then(()=>count);\n      }\n    }).then(cb);\n  }\n\n  /** Collection.sortBy()\n   * \n   * https://dexie.org/docs/Collection/Collection.sortBy()\n   * \n   **/\n  sortBy(keyPath: string): PromiseExtended<any[]>;\n  sortBy<R>(keyPath: string, thenShortcut: ThenShortcut<any[], R>) : PromiseExtended<R>;\n  sortBy(keyPath: string, cb?: ThenShortcut<any[], any>) {\n    const parts = keyPath.split('.').reverse(),\n      lastPart = parts[0],\n      lastIndex = parts.length - 1;\n    function getval(obj, i) {\n      if (i) return getval(obj[parts[i]], i - 1);\n      return obj[lastPart];\n    }\n    var order = this._ctx.dir === \"next\" ? 1 : -1;\n\n    function sorter(a, b) {\n      var aVal = getval(a, lastIndex),\n        bVal = getval(b, lastIndex);\n      return aVal < bVal ? -order : aVal > bVal ? order : 0;\n    }\n    return this.toArray(function (a) {\n      return a.sort(sorter);\n    }).then(cb);\n  }\n\n  /** Collection.toArray()\n   * \n   * https://dexie.org/docs/Collection/Collection.toArray()\n   * \n   **/\n  toArray(cb?): PromiseExtended<any[]> {\n    return this._read(trans => {\n      var ctx = this._ctx;\n      if (ctx.dir === 'next' && isPlainKeyRange(ctx, true) && ctx.limit > 0) {\n        // Special optimation if we could use IDBObjectStore.getAll() or\n        // IDBKeyRange.getAll():\n        const {valueMapper} = ctx;\n        const index = getIndexOrStore(ctx, ctx.table.core.schema);\n        return ctx.table.core.query({\n          trans,\n          limit: ctx.limit,\n          values: true,\n          query: {\n            index,\n            range: ctx.range\n          }\n        }).then(({result}) => valueMapper ? result.map(valueMapper) : result);\n      } else {\n        // Getting array through a cursor.\n        const a = [];\n        return iter(ctx, item => a.push(item), trans, ctx.table.core).then(()=>a);\n      }\n    }, cb);\n  }\n\n  /** Collection.offset()\n   * \n   * https://dexie.org/docs/Collection/Collection.offset()\n   * \n   **/\n  offset(offset: number) : Collection{\n    var ctx = this._ctx;\n    if (offset <= 0) return this;\n    ctx.offset += offset; // For count()\n    if (isPlainKeyRange(ctx)) {\n      addReplayFilter(ctx, () => {\n        var offsetLeft = offset;\n        return (cursor, advance) => {\n          if (offsetLeft === 0) return true;\n          if (offsetLeft === 1) { --offsetLeft; return false; }\n          advance(() => {\n            cursor.advance(offsetLeft);\n            offsetLeft = 0;\n          });\n          return false;\n        };\n      });\n    } else {\n      addReplayFilter(ctx, () => {\n        var offsetLeft = offset;\n        return () => (--offsetLeft < 0);\n      });\n    }\n    return this;\n  }\n\n  /** Collection.limit()\n   * \n   * https://dexie.org/docs/Collection/Collection.limit()\n   * \n   **/\n  limit(numRows: number) : Collection {\n    this._ctx.limit = Math.min(this._ctx.limit, numRows); // For count()\n    addReplayFilter(this._ctx, () => {\n      var rowsLeft = numRows;\n      return function (cursor, advance, resolve) {\n        if (--rowsLeft <= 0) advance(resolve); // Stop after this item has been included\n        return rowsLeft >= 0; // If numRows is already below 0, return false because then 0 was passed to numRows initially. Otherwise we wouldnt come here.\n      };\n    }, true);\n    return this;\n  }\n\n  /** Collection.until()\n   * \n   * https://dexie.org/docs/Collection/Collection.until()\n   * \n   **/\n  until(filterFunction: (x) => boolean, bIncludeStopEntry?) {\n    addFilter(this._ctx, function (cursor, advance, resolve) {\n      if (filterFunction(cursor.value)) {\n        advance(resolve);\n        return bIncludeStopEntry;\n      } else {\n        return true;\n      }\n    });\n    return this;\n  }\n\n  /** Collection.first()\n   * \n   * https://dexie.org/docs/Collection/Collection.first()\n   * \n   **/\n  first(cb?) {\n    return this.limit(1).toArray(function (a) { return a[0]; }).then(cb);\n  }\n\n  /** Collection.last()\n   * \n   * https://dexie.org/docs/Collection/Collection.last()\n   * \n   **/\n  last(cb?) {\n    return this.reverse().first(cb);\n  }\n\n  /** Collection.filter()\n   * \n   * https://dexie.org/docs/Collection/Collection.filter()\n   * \n   **/\n  filter(filterFunction: (x) => boolean): Collection {\n    /// <param name=\"jsFunctionFilter\" type=\"Function\">function(val){return true/false}</param>\n    addFilter(this._ctx, function (cursor) {\n      return filterFunction(cursor.value);\n    });\n    // match filters not used in Dexie.js but can be used by 3rd part libraries to test a\n    // collection for a match without querying DB. Used by Dexie.Observable.\n    addMatchFilter(this._ctx, filterFunction);\n    return this;\n  }\n\n  /** Collection.and()\n   * \n   * https://dexie.org/docs/Collection/Collection.and()\n   * \n   **/\n  and(filter: (x) => boolean) {\n    return this.filter(filter);\n  }\n\n  /** Collection.or()\n   * \n   * https://dexie.org/docs/Collection/Collection.or()\n   * \n   **/\n  or(indexName: string) {\n    return new this.db.WhereClause(this._ctx.table, indexName, this);\n  }\n\n  /** Collection.reverse()\n   * \n   * https://dexie.org/docs/Collection/Collection.reverse()\n   * \n   **/\n  reverse() {\n    this._ctx.dir = (this._ctx.dir === \"prev\" ? \"next\" : \"prev\");\n    if (this._ondirectionchange) this._ondirectionchange(this._ctx.dir);\n    return this;\n  }\n\n  /** Collection.desc()\n   * \n   * https://dexie.org/docs/Collection/Collection.desc()\n   * \n   **/\n  desc() {\n    return this.reverse();\n  }\n\n  /** Collection.eachKey()\n   * \n   * https://dexie.org/docs/Collection/Collection.eachKey()\n   * \n   **/\n  eachKey(cb?) {\n    var ctx = this._ctx;\n    ctx.keysOnly = !ctx.isMatch;\n    return this.each(function (val, cursor) { cb(cursor.key, cursor); });\n  }\n\n  /** Collection.eachUniqueKey()\n   * \n   * https://dexie.org/docs/Collection/Collection.eachUniqueKey()\n   * \n   **/\n  eachUniqueKey(cb?) {\n    this._ctx.unique = \"unique\";\n    return this.eachKey(cb);\n  }\n\n  /** Collection.eachPrimaryKey()\n   * \n   * https://dexie.org/docs/Collection/Collection.eachPrimaryKey()\n   * \n   **/\n  eachPrimaryKey(cb?) {\n    var ctx = this._ctx;\n    ctx.keysOnly = !ctx.isMatch;\n    return this.each(function (val, cursor) { cb(cursor.primaryKey, cursor); });\n  }\n\n  /** Collection.keys()\n   * \n   * https://dexie.org/docs/Collection/Collection.keys()\n   * \n   **/\n  keys(cb?) {\n    var ctx = this._ctx;\n    ctx.keysOnly = !ctx.isMatch;\n    var a = [];\n    return this.each(function (item, cursor) {\n      a.push(cursor.key);\n    }).then(function () {\n      return a;\n    }).then(cb);\n  }\n\n  /** Collection.primaryKeys()\n   * \n   * https://dexie.org/docs/Collection/Collection.primaryKeys()\n   * \n   **/\n  primaryKeys(cb?) : PromiseExtended<IndexableType[]> {\n    var ctx = this._ctx;\n    if (ctx.dir === 'next' && isPlainKeyRange(ctx, true) && ctx.limit > 0) {\n      // Special optimation if we could use IDBObjectStore.getAllKeys() or\n      // IDBKeyRange.getAllKeys():\n      return this._read(trans => {\n        var index = getIndexOrStore(ctx, ctx.table.core.schema);\n        return ctx.table.core.query({\n          trans,\n          values: false,\n          limit: ctx.limit,\n          query: {\n            index,\n            range: ctx.range\n          }});\n      }).then(({result})=>result).then(cb);\n    }\n    ctx.keysOnly = !ctx.isMatch;\n    var a = [];\n    return this.each(function (item, cursor) {\n      a.push(cursor.primaryKey);\n    }).then(function () {\n      return a;\n    }).then(cb);\n  }\n\n  /** Collection.uniqueKeys()\n   * \n   * https://dexie.org/docs/Collection/Collection.uniqueKeys()\n   * \n   **/\n  uniqueKeys(cb?) {\n    this._ctx.unique = \"unique\";\n    return this.keys(cb);\n  }\n\n  /** Collection.firstKey()\n   * \n   * https://dexie.org/docs/Collection/Collection.firstKey()\n   * \n   **/\n  firstKey(cb?) {\n    return this.limit(1).keys(function (a) { return a[0]; }).then(cb);\n  }\n\n  /** Collection.lastKey()\n   * \n   * https://dexie.org/docs/Collection/Collection.lastKey()\n   * \n   **/\n  lastKey(cb?) {\n    return this.reverse().firstKey(cb);\n  }\n\n  /** Collection.distinct()\n   * \n   * https://dexie.org/docs/Collection/Collection.distinct()\n   * \n   **/\n  distinct() {\n    var ctx = this._ctx,\n      idx = ctx.index && ctx.table.schema.idxByName[ctx.index];\n    if (!idx || !idx.multi) return this; // distinct() only makes differencies on multiEntry indexes.\n    var set = {};\n    addFilter(this._ctx, function (cursor: DBCoreCursor) {\n      var strKey = cursor.primaryKey.toString(); // Converts any Date to String, String to String, Number to String and Array to comma-separated string\n      var found = hasOwn(set, strKey);\n      set[strKey] = true;\n      return !found;\n    });\n    return this;\n  }\n\n  //\n  // Methods that mutate storage\n  //\n\n  /** Collection.modify()\n   * \n   * https://dexie.org/docs/Collection/Collection.modify()\n   * \n   **/\n  modify(changes: { [keyPath: string]: any }) : PromiseExtended<number>\n  modify(changes: (obj: any, ctx:{value: any, primKey: IndexableType}) => void | boolean): PromiseExtended<number> {\n    var ctx = this._ctx;\n    return this._write(trans => {\n      var modifyer: (obj: any, ctx:{value: any, primKey: IndexableType}) => void | boolean\n      if (typeof changes === 'function') {\n        // Changes is a function that may update, add or delete propterties or even require a deletion the object itself (delete this.item)\n        modifyer = changes;\n      } else {\n        // changes is a set of {keyPath: value} and no one is listening to the updating hook.\n        var keyPaths = keys(changes);\n        var numKeys = keyPaths.length;\n        modifyer = function (item) {\n          var anythingModified = false;\n          for (var i = 0; i < numKeys; ++i) {\n            var keyPath = keyPaths[i], val = changes[keyPath];\n            if (getByKeyPath(item, keyPath) !== val) {\n              setByKeyPath(item, keyPath, val); // Adding {keyPath: undefined} means that the keyPath should be deleted. Handled by setByKeyPath\n              anythingModified = true;\n            }\n          }\n          return anythingModified;\n        };\n      }\n\n      const coreTable = ctx.table.core;\n      const {outbound, extractKey} = coreTable.schema.primaryKey;\n      const limit = this.db._options.modifyChunkSize || 200;\n      const totalFailures = [];\n      let successCount = 0;\n      const failedKeys: IndexableType[] = [];\n      const applyMutateResult = (expectedCount: number, res: DBCoreMutateResponse) => {\n        const {failures, numFailures} = res;\n        successCount += expectedCount - numFailures;\n        for (let pos of keys(failures)) {\n          totalFailures.push(failures[pos]);\n        }\n      }\n      return this.clone().primaryKeys().then(keys => {\n\n        const nextChunk = (offset: number) => {\n          const count = Math.min(limit, keys.length - offset);\n          return coreTable.getMany({\n            trans,\n            keys: keys.slice(offset, offset + count),\n            cache: \"immutable\" // Optimize for 2 things:\n            // 1) observability-middleware can track changes better.\n            // 2) hooks middleware don't have to query the existing values again when tracking changes.\n            // We can use \"immutable\" because we promise to not touch the values we retrieve here!\n          }).then(values => {\n            const addValues = [];\n            const putValues = [];\n            const putKeys = outbound ? [] : null;\n            const deleteKeys = [];\n            for (let i=0; i<count; ++i) {\n              const origValue = values[i];\n              const ctx = {\n                value: deepClone(origValue),\n                primKey: keys[offset+i]\n              };\n              if (modifyer.call(ctx, ctx.value, ctx) !== false) {\n                if (ctx.value == null) {\n                  // Deleted\n                  deleteKeys.push(keys[offset+i]);\n                } else if (!outbound && cmp(extractKey(origValue), extractKey(ctx.value)) !== 0) {\n                  // Changed primary key of inbound\n                  deleteKeys.push(keys[offset+i]);\n                  addValues.push(ctx.value)\n                } else {\n                  // Changed value\n                  putValues.push(ctx.value);\n                  if (outbound) putKeys.push(keys[offset+i]);\n                }\n              }\n            }\n            const criteria = isPlainKeyRange(ctx) &&\n              ctx.limit === Infinity &&\n              (typeof changes !== 'function' || changes === deleteCallback) && {\n                index: ctx.index,\n                range: ctx.range\n              };\n\n            return Promise.resolve(addValues.length > 0 &&\n              coreTable.mutate({trans, type: 'add', values: addValues})\n                .then(res => {\n                  for (let pos in res.failures) {\n                    // Remove from deleteKeys the key of the object that failed to change its primary key\n                    deleteKeys.splice(parseInt(pos), 1);\n                  }\n                  applyMutateResult(addValues.length, res);\n                })\n            ).then(()=>(putValues.length > 0 || (criteria && typeof changes === 'object')) &&\n                coreTable.mutate({\n                  trans,\n                  type: 'put',\n                  keys: putKeys,\n                  values: putValues,\n                  criteria,\n                  changeSpec: typeof changes !== 'function'\n                    && changes\n                }).then(res=>applyMutateResult(putValues.length, res))\n            ).then(()=>(deleteKeys.length > 0 || (criteria && changes === deleteCallback)) &&\n                coreTable.mutate({\n                  trans,\n                  type: 'delete',\n                  keys: deleteKeys,\n                  criteria\n                }).then(res=>applyMutateResult(deleteKeys.length, res))\n            ).then(()=>{\n              return keys.length > offset + count && nextChunk(offset + limit);\n            });\n          });\n        }\n\n        return nextChunk(0).then(()=>{\n          if (totalFailures.length > 0)\n            throw new ModifyError(\"Error modifying one or more objects\", totalFailures, successCount, failedKeys as IndexableTypeArrayReadonly);\n\n          return keys.length;\n        });\n      });\n\n    });\n  }\n\n  /** Collection.delete()\n   * \n   * https://dexie.org/docs/Collection/Collection.delete()\n   * \n   **/\n  delete() : PromiseExtended<number> {\n    var ctx = this._ctx,\n      range = ctx.range;\n      //deletingHook = ctx.table.hook.deleting.fire,\n      //hasDeleteHook = deletingHook !== nop;\n    if (isPlainKeyRange(ctx) &&\n      ((ctx.isPrimKey && !hangsOnDeleteLargeKeyRange) || range.type === DBCoreRangeType.Any)) // if no range, we'll use clear().\n    {\n      // May use IDBObjectStore.delete(IDBKeyRange) in this case (Issue #208)\n      // For chromium, this is the way most optimized version.\n      // For IE/Edge, this could hang the indexedDB engine and make operating system instable\n      // (https://gist.github.com/dfahlander/5a39328f029de18222cf2125d56c38f7)\n      return this._write(trans => {\n        // Our API contract is to return a count of deleted items, so we have to count() before delete().\n        const {primaryKey} = ctx.table.core.schema;\n        const coreRange = range;\n        return ctx.table.core.count({trans, query: {index: primaryKey, range: coreRange}}).then(count => {\n          return ctx.table.core.mutate({trans, type: 'deleteRange', range: coreRange})\n          .then(({failures, lastResult, results, numFailures}) => {\n            if (numFailures) throw new ModifyError(\"Could not delete some values\",\n              Object.keys(failures).map(pos => failures[pos]),\n              count - numFailures);\n            return count - numFailures;\n          });\n        });\n      });\n    }\n\n    return this.modify(deleteCallback);\n  }\n}\n\nconst deleteCallback = (value, ctx) => ctx.value = null;\n", "import { Dexie } from '../../classes/dexie';\nimport { makeClassConstructor } from '../../functions/make-class-constructor';\nimport { Collection } from './collection';\nimport { WhereClause } from '../where-clause/where-clause';\nimport { AnyRange } from '../../dbcore/keyrange';\nimport { DBCoreKeyRange } from '../../public/types/dbcore';\nimport { mirror } from '../../functions/chaining-functions';\n\n/** Constructs a Collection instance. */\nexport interface CollectionConstructor {\n  new(whereClause?: WhereClause | null, keyRangeGenerator?: () => DBCoreKeyRange): Collection;\n  prototype: Collection;\n}\n\n/** Generates a Collection constructor bound to given Dexie instance.\n * \n * The purpose of having dynamically created constructors, is to allow\n * addons to extend classes for a certain Dexie instance without affecting\n * other db instances.\n */\nexport function createCollectionConstructor(db: Dexie) {\n  return makeClassConstructor<CollectionConstructor>(\n    Collection.prototype,\n\n    function Collection(\n      this: Collection,\n      whereClause?: WhereClause | null,\n      keyRangeGenerator?: () => DBCoreKeyRange)\n    {\n      this.db = db;\n      let keyRange = AnyRange, error = null;\n      if (keyRangeGenerator) try {\n        keyRange = keyRangeGenerator();\n      } catch (ex) {\n        error = ex;\n      }\n\n      const whereCtx = whereClause._ctx;\n      const table = whereCtx.table;\n      const readingHook = table.hook.reading.fire;\n      this._ctx = {\n        table: table,\n        index: whereCtx.index,\n        isPrimKey: (!whereCtx.index || (table.schema.primKey.keyPath && whereCtx.index === table.schema.primKey.name)),\n        range: keyRange,\n        keysOnly: false,\n        dir: \"next\",\n        unique: \"\",\n        algorithm: null,\n        filter: null,\n        replayFilter: null,\n        justLimit: true, // True if a replayFilter is just a filter that performs a \"limit\" operation (or none at all)\n        isMatch: null,\n        offset: 0,\n        limit: Infinity,\n        error: error, // If set, any promise must be rejected with this error\n        or: whereCtx.or,\n        valueMapper: readingHook !== mirror ? readingHook : null\n      };\n    }\n  );\n}\n", "import { IndexableType } from '../public/types/indexable-type';\n\nexport function simpleCompare(a, b) {\n  return a < b ? -1 : a === b ? 0 : 1;\n}\n\nexport function simpleCompareReverse(a, b) {\n  return a > b ? -1 : a === b ? 0 : 1;\n}\n", "import { WhereClause } from './where-clause';\nimport { Collection } from '../collection';\nimport { STRING_EXPECTED } from '../../globals/constants';\nimport { simpleCompare, simpleCompareReverse } from '../../functions/compare-functions';\nimport { IndexableType } from '../../public';\nimport { DBCoreKeyRange, DBCoreRangeType } from '../../public/types/dbcore';\n\nexport function fail(collectionOrWhereClause: Collection | WhereClause, err, T?) {\n  var collection = collectionOrWhereClause instanceof WhereClause ?\n      new collectionOrWhereClause.Collection (collectionOrWhereClause) :\n      collectionOrWhereClause;\n      \n  collection._ctx.error = T ? new T(err) : new TypeError(err);\n  return collection;\n}\n\nexport function emptyCollection(whereClause: WhereClause) {\n  return new whereClause.Collection (whereClause, () => rangeEqual(\"\")).limit(0);\n}\n\nexport function upperFactory(dir: 'next' | 'prev') {\n  return dir === \"next\" ?\n    (s: string) => s.toUpperCase() :\n    (s: string) => s.toLowerCase();\n}\n\nexport function lowerFactory(dir: 'next' | 'prev') {\n  return dir === \"next\" ?\n    (s: string) => s.toLowerCase() :\n    (s: string) => s.toUpperCase();\n}\n\nexport function nextCasing(key, lowerKey, upperNeedle, lowerNeedle, cmp, dir) {\n  var length = Math.min(key.length, lowerNeedle.length);\n  var llp = -1;\n  for (var i = 0; i < length; ++i) {\n      var lwrKeyChar = lowerKey[i];\n      if (lwrKeyChar !== lowerNeedle[i]) {\n          if (cmp(key[i], upperNeedle[i]) < 0) return key.substr(0, i) + upperNeedle[i] + upperNeedle.substr(i + 1);\n          if (cmp(key[i], lowerNeedle[i]) < 0) return key.substr(0, i) + lowerNeedle[i] + upperNeedle.substr(i + 1);\n          if (llp >= 0) return key.substr(0, llp) + lowerKey[llp] + upperNeedle.substr(llp + 1);\n          return null;\n      }\n      if (cmp(key[i], lwrKeyChar) < 0) llp = i;\n  }\n  if (length < lowerNeedle.length && dir === \"next\") return key + upperNeedle.substr(key.length);\n  if (length < key.length && dir === \"prev\") return key.substr(0, upperNeedle.length);\n  return (llp < 0 ? null : key.substr(0, llp) + lowerNeedle[llp] + upperNeedle.substr(llp + 1));\n}\n\nexport function addIgnoreCaseAlgorithm(whereClause: WhereClause, match, needles, suffix) {\n  /// <param name=\"needles\" type=\"Array\" elementType=\"String\"></param>\n  var upper, lower, compare, upperNeedles, lowerNeedles, direction, nextKeySuffix,\n      needlesLen = needles.length;\n  if (!needles.every(s => typeof s === 'string')) {\n      return fail(whereClause, STRING_EXPECTED);\n  }\n  function initDirection(dir) {\n      upper = upperFactory(dir);\n      lower = lowerFactory(dir);\n      compare = (dir === \"next\" ? simpleCompare : simpleCompareReverse);\n      var needleBounds = needles.map(function (needle){\n          return {lower: lower(needle), upper: upper(needle)};\n      }).sort(function(a,b) {\n          return compare(a.lower, b.lower);\n      });\n      upperNeedles = needleBounds.map(function (nb){ return nb.upper; });\n      lowerNeedles = needleBounds.map(function (nb){ return nb.lower; });\n      direction = dir;\n      nextKeySuffix = (dir === \"next\" ? \"\" : suffix);\n  }\n  initDirection(\"next\");\n\n  var c = new whereClause.Collection (\n      whereClause,\n      ()=>createRange(upperNeedles[0], lowerNeedles[needlesLen-1] + suffix)\n  );\n\n  c._ondirectionchange = function (direction) {\n      // This event onlys occur before filter is called the first time.\n      initDirection(direction);\n  };\n\n  var firstPossibleNeedle = 0;\n\n  c._addAlgorithm(function (cursor, advance, resolve) {\n      /// <param name=\"cursor\" type=\"IDBCursor\"></param>\n      /// <param name=\"advance\" type=\"Function\"></param>\n      /// <param name=\"resolve\" type=\"Function\"></param>\n      var key = cursor.key;\n      if (typeof key !== 'string') return false;\n      var lowerKey = lower(key);\n      if (match(lowerKey, lowerNeedles, firstPossibleNeedle)) {\n          return true;\n      } else {\n          var lowestPossibleCasing = null;\n          for (var i=firstPossibleNeedle; i<needlesLen; ++i) {\n              var casing = nextCasing(key, lowerKey, upperNeedles[i], lowerNeedles[i], compare, direction);\n              if (casing === null && lowestPossibleCasing === null)\n                  firstPossibleNeedle = i + 1;\n              else if (lowestPossibleCasing === null || compare(lowestPossibleCasing, casing) > 0) {\n                  lowestPossibleCasing = casing;\n              }\n          }\n          if (lowestPossibleCasing !== null) {\n              advance(function () { cursor.continue(lowestPossibleCasing + nextKeySuffix); });\n          } else {\n              advance(resolve);\n          }\n          return false;\n      }\n  });\n  return c;\n}\n\nexport function createRange (lower: IndexableType, upper: IndexableType, lowerOpen?: boolean, upperOpen?: boolean): DBCoreKeyRange {\n    return {\n        type: DBCoreRangeType.Range,\n        lower,\n        upper,\n        lowerOpen,\n        upperOpen\n    };\n}\n\nexport function rangeEqual (value: IndexableType) : DBCoreKeyRange {\n    return {\n        type: DBCoreRangeType.Equal,\n        lower: value,\n        upper: value\n    };\n}\n", "import { WhereClause as IWhereClause } from \"../../public/types/where-clause\";\nimport { Collection } from \"../collection\";\nimport { Table } from \"../table\";\nimport { IndexableType } from \"../../public/types/indexable-type\";\nimport { emptyCollection, fail, addIgnoreCaseAlgorithm, createRange, rangeEqual } from './where-clause-helpers';\nimport { INVALID_KEY_ARGUMENT, STRING_EXPECTED, maxString, minKey } from '../../globals/constants';\nimport { getArrayOf, NO_CHAR_ARRAY } from '../../functions/utils';\nimport { exceptions } from '../../errors';\nimport { Dexie } from '../dexie';\nimport { Collection as ICollection} from \"../../public/types/collection\";\n\n/** class WhereClause\n * \n * https://dexie.org/docs/WhereClause/WhereClause\n */\nexport class WhereClause implements IWhereClause {\n  db: Dexie;\n  _IDBKeyRange: typeof IDBKeyRange;\n  _ctx: {\n    table: Table;\n    index: string;\n    or: Collection;\n  }\n  _cmp: (a: IndexableType, b: IndexableType) => number;\n  _ascending: (a: IndexableType, b: IndexableType) => number;\n  _descending: (a: IndexableType, b: IndexableType) => number;\n  _min: (a: IndexableType, b: IndexableType) => IndexableType;\n  _max: (a: IndexableType, b: IndexableType) => IndexableType;\n\n  get Collection() {\n    return this._ctx.table.db.Collection;\n  }\n\n  /** WhereClause.between()\n   * \n   * https://dexie.org/docs/WhereClause/WhereClause.between()\n   * \n   **/\n  between(lower: IndexableType, upper: IndexableType, includeLower?: boolean, includeUpper?: boolean) {\n    includeLower = includeLower !== false;   // Default to true\n    includeUpper = includeUpper === true;    // Default to false\n    try {\n      if ((this._cmp(lower, upper) > 0) ||\n        (this._cmp(lower, upper) === 0 && (includeLower || includeUpper) && !(includeLower && includeUpper)))\n        return emptyCollection(this); // Workaround for idiotic W3C Specification that DataError must be thrown if lower > upper. The natural result would be to return an empty collection.\n      return new this.Collection(this, ()=>createRange(lower, upper, !includeLower, !includeUpper));\n    } catch (e) {\n      return fail(this, INVALID_KEY_ARGUMENT);\n    }\n  }\n\n  /** WhereClause.equals()\n   * \n   * https://dexie.org/docs/WhereClause/WhereClause.equals()\n   * \n   **/\n  equals(value: IndexableType) {\n    if (value == null) return fail(this, INVALID_KEY_ARGUMENT);\n    return new this.Collection(this, () => rangeEqual(value)) as ICollection;\n  }\n\n  /** WhereClause.above()\n   * \n   * https://dexie.org/docs/WhereClause/WhereClause.above()\n   * \n   **/\n  above(value: IndexableType) {\n    if (value == null) return fail(this, INVALID_KEY_ARGUMENT);\n    return new this.Collection(this, () => createRange(value, undefined, true));\n  }\n\n  /** WhereClause.aboveOrEqual()\n   * \n   * https://dexie.org/docs/WhereClause/WhereClause.aboveOrEqual()\n   * \n   **/\n  aboveOrEqual(value: IndexableType) {\n    if (value == null) return fail(this, INVALID_KEY_ARGUMENT);\n    return new this.Collection(this, () => createRange(value, undefined, false));\n  }\n\n  /** WhereClause.below()\n   * \n   * https://dexie.org/docs/WhereClause/WhereClause.below()\n   * \n   **/\n  below(value: IndexableType) {\n    if (value == null) return fail(this, INVALID_KEY_ARGUMENT);\n    return new this.Collection(this, () => createRange(undefined, value, false, true));\n  }\n\n  /** WhereClause.belowOrEqual()\n   * \n   * https://dexie.org/docs/WhereClause/WhereClause.belowOrEqual()\n   * \n   **/\n  belowOrEqual(value: IndexableType) {\n    if (value == null) return fail(this, INVALID_KEY_ARGUMENT);\n    return new this.Collection(this, () => createRange(undefined, value));\n  }\n\n  /** WhereClause.startsWith()\n   * \n   * https://dexie.org/docs/WhereClause/WhereClause.startsWith()\n   * \n   **/\n  startsWith(str: string) {\n    if (typeof str !== 'string') return fail(this, STRING_EXPECTED);\n    return this.between(str, str + maxString, true, true);\n  }\n\n  /** WhereClause.startsWithIgnoreCase()\n   * \n   * https://dexie.org/docs/WhereClause/WhereClause.startsWithIgnoreCase()\n   * \n   **/\n  startsWithIgnoreCase(str: string) {\n    if (str === \"\") return this.startsWith(str);\n    return addIgnoreCaseAlgorithm(this, (x, a) => x.indexOf(a[0]) === 0, [str], maxString);\n  }\n\n  /** WhereClause.equalsIgnoreCase()\n   * \n   * https://dexie.org/docs/WhereClause/WhereClause.equalsIgnoreCase()\n   * \n   **/\n  equalsIgnoreCase(str: string) {\n    return addIgnoreCaseAlgorithm(this, (x, a) => x === a[0], [str], \"\");\n  }\n\n  /** WhereClause.anyOfIgnoreCase()\n   * \n   * https://dexie.org/docs/WhereClause/WhereClause.anyOfIgnoreCase()\n   * \n   **/\n  anyOfIgnoreCase(...values: string[]): Collection;\n  anyOfIgnoreCase(values: string[]): Collection;\n  anyOfIgnoreCase() {\n    var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n    if (set.length === 0) return emptyCollection(this);\n    return addIgnoreCaseAlgorithm(this, (x, a) => a.indexOf(x) !== -1, set, \"\");\n  }\n\n  /** WhereClause.startsWithAnyOfIgnoreCase()\n   * \n   * https://dexie.org/docs/WhereClause/WhereClause.startsWithAnyOfIgnoreCase()\n   * \n   **/\n  startsWithAnyOfIgnoreCase(...values: string[]): Collection;\n  startsWithAnyOfIgnoreCase(values: string[]): Collection;\n  startsWithAnyOfIgnoreCase() {\n    var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n    if (set.length === 0) return emptyCollection(this);\n    return addIgnoreCaseAlgorithm(this, (x, a) => a.some(n => x.indexOf(n) === 0), set, maxString);\n  }\n\n  /** WhereClause.anyOf()\n   * \n   * https://dexie.org/docs/WhereClause/WhereClause.anyOf()\n   * \n   **/\n  anyOf(...values: string[]): Collection;\n  anyOf(values: string[]): Collection;\n  anyOf() {\n    const set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n    let compare = this._cmp;\n    try { set.sort(compare); } catch (e) { return fail(this, INVALID_KEY_ARGUMENT); }\n    if (set.length === 0) return emptyCollection(this);\n    const c = new this.Collection(this, () => createRange(set[0], set[set.length - 1]));\n\n    c._ondirectionchange = direction => {\n      compare = (direction === \"next\" ?\n        this._ascending :\n        this._descending);\n      set.sort(compare);\n    };\n\n    let i = 0;\n    c._addAlgorithm((cursor, advance, resolve) => {\n      const key = cursor.key;\n      while (compare(key, set[i]) > 0) {\n        // The cursor has passed beyond this key. Check next.\n        ++i;\n        if (i === set.length) {\n          // There is no next. Stop searching.\n          advance(resolve);\n          return false;\n        }\n      }\n      if (compare(key, set[i]) === 0) {\n        // The current cursor value should be included and we should continue a single step in case next item has the same key or possibly our next key in set.\n        return true;\n      } else {\n        // cursor.key not yet at set[i]. Forward cursor to the next key to hunt for.\n        advance(() => { cursor.continue(set[i]); });\n        return false;\n      }\n    });\n    return c;\n  }\n\n  /** WhereClause.notEqual()\n   * \n   * https://dexie.org/docs/WhereClause/WhereClause.notEqual()\n   * \n   **/\n  notEqual(value: IndexableType) {\n    return this.inAnyRange([[minKey, value], [value, this.db._maxKey]], { includeLowers: false, includeUppers: false });\n  }\n\n  /** WhereClause.noneOf()\n   * \n   * https://dexie.org/docs/WhereClause/WhereClause.noneOf()\n   * \n   **/\n  noneOf(...values: string[]): Collection;\n  noneOf(values: string[]): Collection;\n  noneOf() {\n    const set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n    if (set.length === 0) return new this.Collection(this); // Return entire collection.\n    try { set.sort(this._ascending); } catch (e) { return fail(this, INVALID_KEY_ARGUMENT); }\n    // Transform [\"a\",\"b\",\"c\"] to a set of ranges for between/above/below: [[minKey,\"a\"], [\"a\",\"b\"], [\"b\",\"c\"], [\"c\",maxKey]]\n    const ranges = set.reduce(\n      (res, val) => res ?\n        res.concat([[res[res.length - 1][1], val]]) :\n        [[minKey, val]],\n      null);\n    ranges.push([set[set.length - 1], this.db._maxKey]);\n    return this.inAnyRange(ranges, { includeLowers: false, includeUppers: false });\n  }\n\n  /** WhereClause.inAnyRange()\n   * \n   * https://dexie.org/docs/WhereClause/WhereClause.inAnyRange()\n   * \n   **/\n  inAnyRange(\n    ranges: ReadonlyArray<{ 0: IndexableType, 1: IndexableType }>,\n    options?: { includeLowers?: boolean, includeUppers?: boolean })\n  {\n    const cmp = this._cmp,\n          ascending = this._ascending,\n          descending = this._descending,\n          min = this._min,\n          max = this._max;\n\n    if (ranges.length === 0) return emptyCollection(this);\n    if (!ranges.every(range =>\n      range[0] !== undefined &&\n      range[1] !== undefined &&\n      ascending(range[0], range[1]) <= 0)) {\n      return fail(\n        this,\n        \"First argument to inAnyRange() must be an Array of two-value Arrays [lower,upper] where upper must not be lower than lower\",\n        exceptions.InvalidArgument);\n    }\n    const includeLowers = !options || options.includeLowers !== false;   // Default to true\n    const includeUppers = options && options.includeUppers === true;    // Default to false\n\n    function addRange(ranges, newRange) {\n      let i = 0, l = ranges.length;\n      for (; i < l; ++i) {\n        const range = ranges[i];\n        if (cmp(newRange[0], range[1]) < 0 && cmp(newRange[1], range[0]) > 0) {\n          range[0] = min(range[0], newRange[0]);\n          range[1] = max(range[1], newRange[1]);\n          break;\n        }\n      }\n      if (i === l)\n        ranges.push(newRange);\n      return ranges;\n    }\n\n    let sortDirection = ascending;\n    function rangeSorter(a, b) { return sortDirection(a[0], b[0]); }\n\n    // Join overlapping ranges\n    let set;\n    try {\n      set = ranges.reduce(addRange, []);\n      set.sort(rangeSorter);\n    } catch (ex) {\n      return fail(this, INVALID_KEY_ARGUMENT);\n    }\n\n    let rangePos = 0;\n    const keyIsBeyondCurrentEntry = includeUppers ?\n      key => ascending(key, set[rangePos][1]) > 0 :\n      key => ascending(key, set[rangePos][1]) >= 0;\n\n    const keyIsBeforeCurrentEntry = includeLowers ?\n      key => descending(key, set[rangePos][0]) > 0 :\n      key => descending(key, set[rangePos][0]) >= 0;\n\n    function keyWithinCurrentRange(key) {\n      return !keyIsBeyondCurrentEntry(key) && !keyIsBeforeCurrentEntry(key);\n    }\n\n    let checkKey = keyIsBeyondCurrentEntry;\n\n    const c = new this.Collection(\n      this,\n      () => createRange(set[0][0], set[set.length - 1][1], !includeLowers, !includeUppers));\n\n    c._ondirectionchange = direction => {\n      if (direction === \"next\") {\n        checkKey = keyIsBeyondCurrentEntry;\n        sortDirection = ascending;\n      } else {\n        checkKey = keyIsBeforeCurrentEntry;\n        sortDirection = descending;\n      }\n      set.sort(rangeSorter);\n    };\n\n    c._addAlgorithm((cursor, advance, resolve) => {\n      var key = cursor.key;\n      while (checkKey(key)) {\n        // The cursor has passed beyond this key. Check next.\n        ++rangePos;\n        if (rangePos === set.length) {\n          // There is no next. Stop searching.\n          advance(resolve);\n          return false;\n        }\n      }\n      if (keyWithinCurrentRange(key)) {\n        // The current cursor value should be included and we should continue a single step in case next item has the same key or possibly our next key in set.\n        return true;\n      } else if (this._cmp(key, set[rangePos][1]) === 0 || this._cmp(key, set[rangePos][0]) === 0) {\n        // includeUpper or includeLower is false so keyWithinCurrentRange() returns false even though we are at range border.\n        // Continue to next key but don't include this one.\n        return false;\n      } else {\n        // cursor.key not yet at set[i]. Forward cursor to the next key to hunt for.\n        advance(() => {\n          if (sortDirection === ascending) cursor.continue(set[rangePos][0]);\n          else cursor.continue(set[rangePos][1]);\n        });\n        return false;\n      }\n    });\n    return c;\n  }\n\n  /** WhereClause.startsWithAnyOf()\n   * \n   * https://dexie.org/docs/WhereClause/WhereClause.startsWithAnyOf()\n   * \n   **/\n  startsWithAnyOf(...prefixes: string[]): Collection;\n  startsWithAnyOf(prefixes: string[]): Collection;\n  startsWithAnyOf() {\n    const set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n\n    if (!set.every(s => typeof s === 'string')) {\n        return fail(this, \"startsWithAnyOf() only works with strings\");\n    }\n    if (set.length === 0) return emptyCollection(this);\n\n    return this.inAnyRange(set.map((str: string) => [str, str + maxString]));\n  }\n\n}\n", "import { Dexie } from '../dexie';\nimport { makeClassConstructor } from '../../functions/make-class-constructor';\nimport { WhereClause } from './where-clause';\nimport { Table } from '../table';\nimport { Collection } from '../collection';\nimport { exceptions } from '../../errors';\n\nexport interface WhereClauseConstructor {\n  new(table: Table, index?: string, orCollection?: Collection): WhereClause;\n  prototype: WhereClause;\n}\n\n/** Generates a WhereClause constructor.\n * \n * The purpose of having dynamically created constructors, is to allow\n * addons to extend classes for a certain Dexie instance without affecting\n * other db instances.\n */\nexport function createWhereClauseConstructor(db: Dexie) {\n  return makeClassConstructor<WhereClauseConstructor>(\n    WhereClause.prototype,\n\n    function WhereClause(this: WhereClause, table: Table, index?: string, orCollection?: Collection) {\n      this.db = db;\n      this._ctx = {\n        table: table,\n        index: index === \":id\" ? null : index,\n        or: orCollection\n      };\n      const indexedDB = db._deps.indexedDB;\n      if (!indexedDB) throw new exceptions.MissingAPI();\n      this._cmp = this._ascending = indexedDB.cmp.bind(indexedDB);\n      this._descending = (a, b) => indexedDB.cmp(b, a);\n      this._max = (a, b) => indexedDB.cmp(a,b) > 0 ? a : b;\n      this._min = (a, b) => indexedDB.cmp(a,b) < 0 ? a : b;\n      this._IDBKeyRange = db._deps.IDBKeyRange;\n    }\n  );\n}\n", "import { wrap } from \"../helpers/promise\";\n\nexport function eventRejectHandler(reject) {\n  return wrap(function (event) {\n      preventDefault(event);\n      reject (event.target.error);\n      return false;\n  });\n}\n\nexport function eventSuccessHandler (resolve) {\n  return wrap(function (event){\n      resolve(event.target.result);\n  });\n}\n\nexport function hookedEventRejectHandler (reject) {\n  return wrap(function (event) {\n      // See comment on hookedEventSuccessHandler() why wrap() is needed only when supporting hooks.\n      \n      var req = event.target,\n          err = req.error,\n          ctx = req._hookCtx,// Contains the hook error handler. Put here instead of closure to boost performance.\n          hookErrorHandler = ctx && ctx.onerror;\n      hookErrorHandler && hookErrorHandler(err);\n      preventDefault(event);\n      reject (err);\n      return false;\n  });\n}\n\nexport function hookedEventSuccessHandler(resolve) {\n  // wrap() is needed when calling hooks because the rare scenario of:\n  //  * hook does a db operation that fails immediately (IDB throws exception)\n  //    For calling db operations on correct transaction, wrap makes sure to set PSD correctly.\n  //    wrap() will also execute in a virtual tick.\n  //  * If not wrapped in a virtual tick, direct exception will launch a new physical tick.\n  //  * If this was the last event in the bulk, the promise will resolve after a physical tick\n  //    and the transaction will have committed already.\n  // If no hook, the virtual tick will be executed in the reject()/resolve of the final promise,\n  // because it is always marked with _lib = true when created using Transaction._promise().\n  return wrap(function(event) {\n      var req = event.target,\n          ctx = req._hookCtx,// Contains the hook error handler. Put here instead of closure to boost performance.\n          result = ctx.value || req.result, // Pass the object value on updates. The result from IDB is the primary key.\n          hookSuccessHandler = ctx && ctx.onsuccess;\n      hookSuccessHandler && hookSuccessHandler(result);\n      resolve && resolve(result);\n  }, resolve);\n}\n\n\nexport function preventDefault(event) {\n  if (event.stopPropagation) // IndexedDBShim doesnt support this on Safari 8 and below.\n      event.stopPropagation();\n  if (event.preventDefault) // IndexedDBShim doesnt support this on Safari 8 and below.\n      event.preventDefault();\n}\n\nexport function BulkErrorHandlerCatchAll(errorList, done?, supportHooks?) {\n  return (supportHooks ? hookedEventRejectHandler : eventRejectHandler)(e => {\n      errorList.push(e);\n      done && done();\n  });\n}\n\n", "import Events from '../helpers/Events';\nimport { GlobalDexieEvents } from '../public/types/db-events';\n\nexport const DEXIE_STORAGE_MUTATED_EVENT_NAME = 'storagemutated' as 'storagemutated';\n\n// Name of the global event fired using DOM dispatchEvent (if not in node).\n// Reason for propagating this as a DOM event is for getting reactivity across\n// multiple versions of Dexie within the same app (as long as they are\n// compatible with regards to the event data).\n// If the ObservabilitySet protocol change in a way that would not be backward\n// compatible, make sure also update the event name to a new number at the end\n// so that two Dexie instances of different versions continue to work together\n//  - maybe not able to communicate but won't fail due to unexpected data in\n// the detail property of the CustomEvent. If so, also make sure to udpate\n// docs and explain at which Dexie version the new name and format of the event\n// is being used.\nexport const STORAGE_MUTATED_DOM_EVENT_NAME = 'x-storagemutated-1';\n\nexport const globalEvents = Events(null, DEXIE_STORAGE_MUTATED_EVENT_NAME) as GlobalDexieEvents;\n", "import { Transaction as ITransaction } from '../../public/types/transaction';\nimport { DexiePromise, wrap, rejection } from \"../../helpers/promise\";\nimport { DbSchema } from '../../public/types/db-schema';\nimport { assert, hasOwn } from '../../functions/utils';\nimport { PSD, usePSD } from '../../helpers/promise';\nimport { Dexie } from '../dexie';\nimport { exceptions } from '../../errors';\nimport { safariMultiStoreFix } from '../../functions/quirks';\nimport { preventDefault } from '../../functions/event-wrappers';\nimport { newScope } from '../../helpers/promise';\nimport * as Debug from '../../helpers/debug';\nimport { Table } from '../table';\nimport { globalEvents } from '../../globals/global-events';\n\n/** Transaction\n * \n * https://dexie.org/docs/Transaction/Transaction\n * \n **/\nexport class Transaction implements ITransaction {\n  db: Dexie;\n  active: boolean;\n  mode: IDBTransactionMode;\n  chromeTransactionDurability: ChromeTransactionDurability;\n  idbtrans: IDBTransaction;\n  storeNames: string[];\n  on: any;\n  parent?: Transaction;\n  schema: DbSchema;\n  _memoizedTables: {[tableName: string]: Table};\n\n  _reculock: number;\n  _blockedFuncs: { 0: () => any, 1: any }[];\n  _resolve: () => void;\n  _reject: (Error) => void;\n  _waitingFor: DexiePromise; // for waitFor()\n  _waitingQueue: Function[]; // for waitFor()\n  _spinCount: number; // Just for debugging waitFor()\n  _completion: DexiePromise;\n\n  //\n  // Transaction internal methods (not required by API users, but needed internally and eventually by dexie extensions)\n  //\n\n  /** Transaction._lock()\n   * \n   * Internal method.\n   */\n  _lock() {\n    assert(!PSD.global); // Locking and unlocking reuires to be within a PSD scope.\n    // Temporary set all requests into a pending queue if they are called before database is ready.\n    ++this._reculock; // Recursive read/write lock pattern using PSD (Promise Specific Data) instead of TLS (Thread Local Storage)\n    if (this._reculock === 1 && !PSD.global) PSD.lockOwnerFor = this;\n    return this;\n  }\n\n  /** Transaction._unlock()\n   * \n   * Internal method.\n   */\n  _unlock() {\n    assert(!PSD.global); // Locking and unlocking reuires to be within a PSD scope.\n    if (--this._reculock === 0) {\n      if (!PSD.global) PSD.lockOwnerFor = null;\n      while (this._blockedFuncs.length > 0 && !this._locked()) {\n        var fnAndPSD = this._blockedFuncs.shift();\n        try { usePSD(fnAndPSD[1], fnAndPSD[0]); } catch (e) { }\n      }\n    }\n    return this;\n  }\n\n  /** Transaction._lock()\n   * \n   * Internal method.\n   */\n  _locked() {\n    // Checks if any write-lock is applied on this transaction.\n    // To simplify the Dexie API for extension implementations, we support recursive locks.\n    // This is accomplished by using \"Promise Specific Data\" (PSD).\n    // PSD data is bound to a Promise and any child Promise emitted through then() or resolve( new Promise() ).\n    // PSD is local to code executing on top of the call stacks of any of any code executed by Promise():\n    //         * callback given to the Promise() constructor  (function (resolve, reject){...})\n    //         * callbacks given to then()/catch()/finally() methods (function (value){...})\n    // If creating a new independant Promise instance from within a Promise call stack, the new Promise will derive the PSD from the call stack of the parent Promise.\n    // Derivation is done so that the inner PSD __proto__ points to the outer PSD.\n    // PSD.lockOwnerFor will point to current transaction object if the currently executing PSD scope owns the lock.\n    return this._reculock && PSD.lockOwnerFor !== this;\n  }\n\n  /** Transaction.create()\n   * \n   * Internal method.\n   * \n   */\n  create(idbtrans?: IDBTransaction) {\n    if (!this.mode) return this;\n    const idbdb = this.db.idbdb;\n    const dbOpenError = this.db._state.dbOpenError;\n    assert(!this.idbtrans);\n    if (!idbtrans && !idbdb) {\n      switch (dbOpenError && dbOpenError.name) {\n        case \"DatabaseClosedError\":\n          // Errors where it is no difference whether it was caused by the user operation or an earlier call to db.open()\n          throw new exceptions.DatabaseClosed(dbOpenError);\n        case \"MissingAPIError\":\n          // Errors where it is no difference whether it was caused by the user operation or an earlier call to db.open()\n          throw new exceptions.MissingAPI(dbOpenError.message, dbOpenError);\n        default:\n          // Make it clear that the user operation was not what caused the error - the error had occurred earlier on db.open()!\n          throw new exceptions.OpenFailed(dbOpenError);\n      }\n    }\n    if (!this.active) throw new exceptions.TransactionInactive();\n    assert(this._completion._state === null); // Completion Promise must still be pending.\n\n    idbtrans = this.idbtrans = idbtrans ||\n      (this.db.core \n        ? this.db.core.transaction(this.storeNames, this.mode as 'readwrite' | 'readonly', { durability: this.chromeTransactionDurability })\n        : idbdb.transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability })\n      ) as IDBTransaction;\n\n    idbtrans.onerror = wrap(ev => {\n      preventDefault(ev);// Prohibit default bubbling to window.error\n      this._reject(idbtrans.error);\n    });\n    idbtrans.onabort = wrap(ev => {\n      preventDefault(ev);\n      this.active && this._reject(new exceptions.Abort(idbtrans.error));\n      this.active = false;\n      this.on(\"abort\").fire(ev);\n    });\n    idbtrans.oncomplete = wrap(() => {\n      this.active = false;\n      this._resolve();\n      if ('mutatedParts' in idbtrans) {\n        globalEvents.storagemutated.fire(idbtrans[\"mutatedParts\"]);\n      }\n    });\n    return this;\n  }\n\n  /** Transaction._promise()\n   * \n   * Internal method.\n   */\n  _promise(\n    mode: IDBTransactionMode,\n    fn: (resolve, reject, trans: Transaction) => PromiseLike<any> | void,\n    bWriteLock?: string | boolean): DexiePromise\n  {\n    if (mode === 'readwrite' && this.mode !== 'readwrite')\n      return rejection(new exceptions.ReadOnly(\"Transaction is readonly\"));\n\n    if (!this.active)\n      return rejection(new exceptions.TransactionInactive());\n\n    if (this._locked()) {\n      return new DexiePromise((resolve, reject) => {\n        this._blockedFuncs.push([() => {\n          this._promise(mode, fn, bWriteLock).then(resolve, reject);\n        }, PSD]);\n      });\n\n    } else if (bWriteLock) {\n      return newScope(() => {\n        var p = new DexiePromise((resolve, reject) => {\n          this._lock();\n          const rv = fn(resolve, reject, this);\n          if (rv && rv.then) rv.then(resolve, reject);\n        });\n        p.finally(() => this._unlock());\n        p._lib = true;\n        return p;\n      });\n\n    } else {\n      var p = new DexiePromise((resolve, reject) => {\n        var rv = fn(resolve, reject, this);\n        if (rv && rv.then) rv.then(resolve, reject);\n      });\n      p._lib = true;\n      return p;\n    }\n  }\n\n  /** Transaction._root()\n   * \n   * Internal method. Retrieves the root transaction in the tree of sub transactions.\n   */\n  _root() {\n    return this.parent ? this.parent._root() : this;\n  }\n\n  /** Transaction.waitFor()\n   * \n   * Internal method. Can be accessed from the public API through\n   * Dexie.waitFor(): https://dexie.org/docs/Dexie/Dexie.waitFor()\n   * \n   **/\n  waitFor(promiseLike: PromiseLike<any>) {\n    // Always operate on the root transaction (in case this is a sub stransaction)\n    var root = this._root();\n    // For stability reasons, convert parameter to promise no matter what type is passed to waitFor().\n    // (We must be able to call .then() on it.)\n    const promise = DexiePromise.resolve(promiseLike);\n    if (root._waitingFor) {\n      // Already called waitFor(). Wait for both to complete.\n      root._waitingFor = root._waitingFor.then(() => promise);\n    } else {\n      // We're not in waiting state. Start waiting state.\n      root._waitingFor = promise;\n      root._waitingQueue = [];\n      // Start interacting with indexedDB until promise completes:\n      var store = root.idbtrans.objectStore(root.storeNames[0]);\n      (function spin() {\n        ++root._spinCount; // For debugging only\n        while (root._waitingQueue.length) (root._waitingQueue.shift())();\n        if (root._waitingFor) store.get(-Infinity).onsuccess = spin;\n      }());\n    }\n    var currentWaitPromise = root._waitingFor;\n    return new DexiePromise((resolve, reject) => {\n      promise.then(\n        res => root._waitingQueue.push(wrap(resolve.bind(null, res))),\n        err => root._waitingQueue.push(wrap(reject.bind(null, err)))\n      ).finally(() => {\n        if (root._waitingFor === currentWaitPromise) {\n          // No one added a wait after us. Safe to stop the spinning.\n          root._waitingFor = null;\n        }\n      });\n    });\n  }  \n\n  /** Transaction.abort()\n   * \n   * https://dexie.org/docs/Transaction/Transaction.abort()\n   */\n  abort() {\n    if (this.active) {\n      this.active = false;\n      if (this.idbtrans) this.idbtrans.abort();\n      this._reject(new exceptions.Abort());\n    }\n  }\n\n  /** Transaction.table()\n   * \n   * https://dexie.org/docs/Transaction/Transaction.table()\n   */\n  table(tableName: string) {\n    const memoizedTables = (this._memoizedTables || (this._memoizedTables = {}));\n    if (hasOwn(memoizedTables, tableName))\n      return memoizedTables[tableName];\n    const tableSchema = this.schema[tableName];\n    if (!tableSchema) {\n      throw new exceptions.NotFound(\"Table \" + tableName + \" not part of transaction\");        \n    }\n\n    const transactionBoundTable = new this.db.Table(tableName, tableSchema, this);\n    transactionBoundTable.core = this.db.core.table(tableName);\n    memoizedTables[tableName] = transactionBoundTable;\n    return transactionBoundTable;\n  }\n}\n", "import { Dexie } from '../dexie';\nimport { makeClassConstructor } from '../../functions/make-class-constructor';\nimport { Transaction } from './transaction';\nimport { DbSchema } from '../../public/types/db-schema';\nimport Events from '../../helpers/Events';\nimport Promise, { rejection } from '../../helpers/promise';\n\nexport interface TransactionConstructor<T extends Transaction=Transaction> {\n  new (\n    mode: IDBTransactionMode,\n    storeNames: string[],\n    dbschema: DbSchema,\n    chromeTransactionDurability: ChromeTransactionDurability,\n    parent?: Transaction) : T;\n  prototype: T;\n}\n\n/** Generates a Transaction constructor bound to given Dexie instance.\n * \n * The purpose of having dynamically created constructors, is to allow\n * addons to extend classes for a certain Dexie instance without affecting\n * other db instances.\n */\nexport function createTransactionConstructor(db: Dexie) {\n  return makeClassConstructor<TransactionConstructor<Transaction>>(\n    Transaction.prototype,\n    function Transaction (\n      this: Transaction,\n      mode: IDBTransactionMode,\n      storeNames: string[],\n      dbschema: DbSchema,\n      chromeTransactionDurability: ChromeTransactionDurability,\n      parent?: Transaction)\n    {\n      this.db = db;\n      this.mode = mode;\n      this.storeNames = storeNames;\n      this.schema = dbschema;\n      this.chromeTransactionDurability = chromeTransactionDurability;\n      this.idbtrans = null;\n      this.on = Events(this, \"complete\", \"error\", \"abort\");\n      this.parent = parent || null;\n      this.active = true;\n      this._reculock = 0;\n      this._blockedFuncs = [];\n      this._resolve = null;\n      this._reject = null;\n      this._waitingFor = null;\n      this._waitingQueue = null;\n      this._spinCount = 0; // Just for debugging waitFor()\n      this._completion = new Promise ((resolve, reject) => {\n          this._resolve = resolve;\n          this._reject = reject;\n      });\n      \n      this._completion.then(\n          ()=> {\n              this.active = false;\n              this.on.complete.fire();\n          },\n          e => {\n              var wasActive = this.active;\n              this.active = false;\n              this.on.error.fire(e);\n              this.parent ?\n                  this.parent._reject(e) :\n                  wasActive && this.idbtrans && this.idbtrans.abort();\n              return rejection(e); // Indicate we actually DO NOT catch this error.\n          });\n    \n    });\n}\n", "import { IndexSpec } from '../public/types/index-spec';\n\nexport function createIndexSpec(\n  name: string,\n  keyPath: string | string[],\n  unique: boolean,\n  multi: boolean,\n  auto: boolean,\n  compound: boolean,\n  isPrimKey: boolean\n): IndexSpec {\n  return {\n    name,\n    keyPath,\n    unique,\n    multi,\n    auto,\n    compound,\n    src: (unique && !isPrimKey ? '&' : '') + (multi ? '*' : '') + (auto ? \"++\" : \"\") + nameFromKeyPath(keyPath)\n  }\n}\n\nexport function nameFromKeyPath (keyPath?: string | string[]): string {\n  return typeof keyPath === 'string' ?\n    keyPath :\n    keyPath ? ('[' + [].join.call(keyPath, '+') + ']') : \"\";\n}\n", "import { IndexSpec } from '../public/types/index-spec';\nimport { TableSchema } from '../public/types/table-schema';\nimport { createIndexSpec } from './index-spec';\nimport { arrayToObject } from '../functions/utils';\n\nexport function createTableSchema (\n  name: string,\n  primKey: IndexSpec,\n  indexes: IndexSpec[]\n): TableSchema {\n  return {\n    name,\n    primKey,\n    indexes,\n    mappedClass: null,\n    idxByName: arrayToObject(indexes, index => [index.name, index])\n  };\n}\n", "import { maxString } from '../globals/constants';\n\nexport function safariMultiStoreFix(storeNames: string[]) {\n  return storeNames.length === 1 ? storeNames[0] : storeNames;\n}\n\nexport function getNativeGetDatabaseNamesFn(indexedDB) {\n  var fn = indexedDB && (indexedDB.getDatabaseNames || indexedDB.webkitGetDatabaseNames);\n  return fn && fn.bind(indexedDB);\n}\n\nexport let getMaxKey = (IdbKeyRange: typeof IDBKeyRange) => {\n  try {\n    IdbKeyRange.only([[]]);\n    getMaxKey = () => [[]];\n    return [[]];\n  } catch (e) {\n    getMaxKey = () => maxString;\n    return maxString;\n  }\n}\n", "import { getByKeyPath } from '../functions/utils';\n\nexport function getKeyExtractor (keyPath: null | string | string[]) : (a: any) => any {\n  if (keyPath == null) {\n    return () => undefined;\n  } else if (typeof keyPath === 'string') {\n    return getSinglePathKeyExtractor(keyPath);\n  } else {\n    return obj => getByKeyPath(obj, keyPath);\n  }\n}\n\nexport function getSinglePathKeyExtractor(keyPath: string) {\n  const split = keyPath.split('.');\n  if (split.length === 1) {\n    return obj => obj[keyPath];\n  } else {\n    return obj => getByKeyPath(obj, keyPath);\n  }\n}\n", "import {\n  DBCore,\n  DBCoreCursor,\n  DBCoreOpenCursorRequest,\n  DBCoreQueryRequest,\n  DBCoreIndex,\n  DBCoreKeyRange,\n  DBCoreQueryResponse,\n  DBCoreRangeType,\n  DBCoreSchema,\n  DBCoreTableSchema,\n  DBCoreTable,\n  DBCoreMutateResponse,\n} from \"../public/types/dbcore\";\nimport { isArray } from '../functions/utils';\nimport { eventRejectHandler, preventDefault } from '../functions/event-wrappers';\nimport { wrap } from '../helpers/promise';\nimport { getMaxKey } from '../functions/quirks';\nimport { getKeyExtractor } from './get-key-extractor';\n\nexport function arrayify<T>(arrayLike: {length: number, [index: number]: T}): T[] {\n  return [].slice.call(arrayLike);\n}\nexport function pick<T,Prop extends keyof T>(obj: T, props: Prop[]): Pick<T, Prop> {\n  const result = {} as Pick<T, Prop>;\n  props.forEach(prop => result[prop] = obj[prop]);\n  return result;\n}\n\nlet _id_counter = 0;\n\nexport function getKeyPathAlias(keyPath: null | string | string[]) {\n  return keyPath == null ?\n    \":id\" :\n    typeof keyPath === 'string' ?\n      keyPath :\n      `[${keyPath.join('+')}]`;\n}\n\nexport function createDBCore (\n  db: IDBDatabase,\n  IdbKeyRange: typeof IDBKeyRange,\n  tmpTrans: IDBTransaction) : DBCore\n{\n  function extractSchema(db: IDBDatabase, trans: IDBTransaction) : {schema: DBCoreSchema, hasGetAll: boolean} {\n    const tables = arrayify(db.objectStoreNames);\n    return {\n      schema: {\n        name: db.name,\n        tables: tables.map(table => trans.objectStore(table)).map(store => {\n          const {keyPath, autoIncrement} = store;\n          const compound = isArray(keyPath);\n          const outbound = keyPath == null;\n          const indexByKeyPath: {[keyPathAlias: string]: DBCoreIndex} = {};\n          const result = {\n            name: store.name,\n            primaryKey: {\n              name: null,\n              isPrimaryKey: true,\n              outbound,\n              compound,\n              keyPath,\n              autoIncrement,\n              unique: true,\n              extractKey: getKeyExtractor(keyPath)\n            } as DBCoreIndex,\n            indexes: arrayify(store.indexNames).map(indexName => store.index(indexName))\n              .map(index => {\n                const {name, unique, multiEntry, keyPath} = index;\n                const compound = isArray(keyPath);\n                const result: DBCoreIndex = {\n                  name,\n                  compound,\n                  keyPath,\n                  unique,\n                  multiEntry,\n                  extractKey: getKeyExtractor(keyPath)\n                };\n                indexByKeyPath[getKeyPathAlias(keyPath)] = result;\n                return result;\n              }),\n            getIndexByKeyPath: (keyPath: null | string | string[]) => indexByKeyPath[getKeyPathAlias(keyPath)]\n          };\n          indexByKeyPath[\":id\"] = result.primaryKey;\n          if (keyPath != null) {\n            indexByKeyPath[getKeyPathAlias(keyPath)] = result.primaryKey;\n          }\n          return result;\n        })\n      },\n      hasGetAll: tables.length > 0 && ('getAll' in trans.objectStore(tables[0])) &&\n        !(typeof navigator !== 'undefined' && /Safari/.test(navigator.userAgent) &&\n        !/(Chrome\\/|Edge\\/)/.test(navigator.userAgent) &&\n        [].concat(navigator.userAgent.match(/Safari\\/(\\d*)/))[1] < 604) // Bug with getAll() on Safari ver<604. See discussion following PR #579\n    };\n  }\n\n  function makeIDBKeyRange (range: DBCoreKeyRange) : IDBKeyRange | null {\n    if (range.type === DBCoreRangeType.Any) return null;\n    if (range.type === DBCoreRangeType.Never) throw new Error(\"Cannot convert never type to IDBKeyRange\");\n    const {lower, upper, lowerOpen, upperOpen} = range;\n    const idbRange = lower === undefined ?\n      upper === undefined ?\n        null : //IDBKeyRange.lowerBound(-Infinity, false) : // Any range (TODO: Should we return null instead?)\n        IdbKeyRange.upperBound(upper, !!upperOpen) : // below\n      upper === undefined ?\n        IdbKeyRange.lowerBound(lower, !!lowerOpen) : // above\n        IdbKeyRange.bound(lower, upper, !!lowerOpen, !!upperOpen);\n    return idbRange;\n  }\n\n  function createDbCoreTable(tableSchema: DBCoreTableSchema): DBCoreTable {\n    const tableName = tableSchema.name;\n\n    function mutate ({trans, type, keys, values, range}) {\n      return new Promise<DBCoreMutateResponse>((resolve, reject) => {\n        resolve = wrap(resolve);\n        const store = (trans as IDBTransaction).objectStore(tableName);\n        const outbound = store.keyPath == null;\n        const isAddOrPut = type === \"put\" || type === \"add\";\n        if (!isAddOrPut && type !== 'delete' && type !== 'deleteRange')\n          throw new Error (\"Invalid operation type: \" + type);\n\n        const {length} = keys || values || {length: 1}; // keys.length if keys. values.length if values. 1 if range.\n        if (keys && values && keys.length !== values.length) {\n          throw new Error(\"Given keys array must have same length as given values array.\");\n        }\n        if (length === 0)\n          // No items to write. Don't even bother!\n          return resolve({numFailures: 0, failures: {}, results: [], lastResult: undefined});\n\n        let req: IDBRequest;\n        const reqs: IDBRequest[] = [];\n          \n        const failures: {[operationNumber: number]: Error} = [];\n        let numFailures = 0;\n        const errorHandler = \n          event => {\n            ++numFailures;\n            preventDefault(event);\n          };\n  \n        if (type === 'deleteRange') {\n          // Here the argument is the range\n          if (range.type === DBCoreRangeType.Never)\n            return resolve({numFailures, failures, results: [], lastResult: undefined}); // Deleting the Never range shoulnt do anything.\n          if (range.type === DBCoreRangeType.Any)\n            reqs.push(req = store.clear()); // Deleting the Any range is equivalent to store.clear()\n          else\n            reqs.push(req = store.delete(makeIDBKeyRange(range)));\n        } else {\n          // No matter add, put or delete - find out arrays of first and second arguments to it.\n          const [args1, args2] = isAddOrPut ?\n            outbound ?\n              [values, keys] :\n              [values, null] :\n            [keys, null];\n\n          if (isAddOrPut) {\n            for (let i=0; i<length; ++i) {\n              reqs.push(req = (args2 && args2[i] !== undefined ?\n                store[type](args1[i], args2[i]) :\n                store[type](args1[i])) as IDBRequest);\n              req.onerror = errorHandler;\n            }\n          } else {\n            for (let i=0; i<length; ++i) {\n              reqs.push(req = store[type](args1[i]) as IDBRequest);\n              req.onerror = errorHandler;\n            }\n          }\n        }\n        const done = event => {\n          const lastResult = event.target.result;\n          reqs.forEach((req, i) => req.error != null && (failures[i] = req.error));\n          resolve({\n            numFailures,\n            failures,\n            results: type === \"delete\" ? keys : reqs.map(req => req.result),\n            lastResult\n          });\n        };\n  \n        req.onerror = event => { // wrap() not needed. All paths calling outside will wrap!\n          errorHandler(event);\n          done(event);\n        };\n  \n        req.onsuccess = done;\n      });\n    }\n    \n    function openCursor ({trans, values, query, reverse, unique}: DBCoreOpenCursorRequest): Promise<DBCoreCursor>\n    {\n      return new Promise((resolve, reject) => {\n        resolve = wrap(resolve);\n        const {index, range} = query;\n        const store = (trans as IDBTransaction).objectStore(tableName);\n        // source\n        const source = index.isPrimaryKey ?\n          store :\n          store.index(index.name);\n        // direction\n        const direction = reverse ?\n          unique ?\n            \"prevunique\" :\n            \"prev\" :\n          unique ?\n            \"nextunique\" :\n            \"next\";\n        // request\n        const req = values || !('openKeyCursor' in source) ?\n          source.openCursor(makeIDBKeyRange(range), direction) :\n          source.openKeyCursor(makeIDBKeyRange(range), direction);\n          \n        // iteration\n        req.onerror = eventRejectHandler(reject);\n        req.onsuccess = wrap(ev => {\n\n          const cursor = req.result as unknown as DBCoreCursor;\n          if (!cursor) {\n            resolve(null);\n            return;\n          }\n          (cursor as any).___id = ++_id_counter;\n          (cursor as any).done = false;\n          const _cursorContinue = cursor.continue.bind(cursor);\n          let _cursorContinuePrimaryKey = cursor.continuePrimaryKey;\n          if (_cursorContinuePrimaryKey) _cursorContinuePrimaryKey = _cursorContinuePrimaryKey.bind(cursor);\n          const _cursorAdvance = cursor.advance.bind(cursor);\n          const doThrowCursorIsNotStarted = ()=>{throw new Error(\"Cursor not started\");}\n          const doThrowCursorIsStopped = ()=>{throw new Error(\"Cursor not stopped\");}\n          (cursor as any).trans = trans;\n          cursor.stop = cursor.continue = cursor.continuePrimaryKey = cursor.advance = doThrowCursorIsNotStarted;\n          cursor.fail = wrap(reject);\n          cursor.next = function (this: DBCoreCursor) {\n            // next() must work with \"this\" pointer in order to function correctly for ProxyCursors (derived objects)\n            // without having to re-define next() on each child.\n            let gotOne = 1;\n            return this.start(() => gotOne-- ? this.continue() : this.stop()).then(() => this);\n          };\n          cursor.start = (callback) => {\n            //console.log(\"Starting cursor\", (cursor as any).___id);\n            const iterationPromise = new Promise<void>((resolveIteration, rejectIteration) =>{\n              resolveIteration = wrap(resolveIteration);\n              req.onerror = eventRejectHandler(rejectIteration);\n              cursor.fail = rejectIteration;\n              cursor.stop = value => {\n                //console.log(\"Cursor stop\", cursor);\n                cursor.stop = cursor.continue = cursor.continuePrimaryKey = cursor.advance = doThrowCursorIsStopped;\n                resolveIteration(value);\n              };\n            });\n            // Now change req.onsuccess to a callback that doesn't call initCursor but just observer.next()\n            const guardedCallback = () => {\n              if (req.result) {\n                //console.log(\"Next result\", cursor);\n                try {\n                  callback();\n                } catch (err) {\n                  cursor.fail(err);\n                }\n              } else {\n                (cursor as any).done = true;\n                cursor.start = ()=>{throw new Error(\"Cursor behind last entry\");}\n                cursor.stop();\n              }\n            }\n            req.onsuccess = wrap(ev => {\n              //cursor.continue = _cursorContinue;\n              //cursor.continuePrimaryKey = _cursorContinuePrimaryKey;\n              //cursor.advance = _cursorAdvance;\n              req.onsuccess = guardedCallback;\n              guardedCallback();\n            });\n            cursor.continue = _cursorContinue;\n            cursor.continuePrimaryKey = _cursorContinuePrimaryKey;\n            cursor.advance = _cursorAdvance;\n            guardedCallback();\n            return iterationPromise;\n          };\n          resolve(cursor);\n        }, reject); \n      });\n    }\n  \n    function query (hasGetAll: boolean) {\n      return (request: DBCoreQueryRequest) => {\n        return new Promise<DBCoreQueryResponse>((resolve, reject) => {\n          resolve = wrap(resolve);\n          const {trans, values, limit, query} = request;\n          const nonInfinitLimit = limit === Infinity ? undefined : limit;\n          const {index, range} = query;\n          const store = (trans as IDBTransaction).objectStore(tableName);\n          const source = index.isPrimaryKey ? store : store.index(index.name);\n          const idbKeyRange = makeIDBKeyRange(range);\n          if (limit === 0) return resolve({result: []});\n          if (hasGetAll) {\n            const req = values ?\n                (source as any).getAll(idbKeyRange, nonInfinitLimit) :\n                (source as any).getAllKeys(idbKeyRange, nonInfinitLimit);\n            req.onsuccess = event => resolve({result: event.target.result});\n            req.onerror = eventRejectHandler(reject);\n          } else {\n            let count = 0;\n            const req = values || !('openKeyCursor' in source) ?\n              source.openCursor(idbKeyRange) :\n              source.openKeyCursor(idbKeyRange)\n            const result = [];\n            req.onsuccess = event => {\n              const cursor = req.result as IDBCursorWithValue;\n              if (!cursor) return resolve({result});\n              result.push(values ? cursor.value : cursor.primaryKey);\n              if (++count === limit) return resolve({result});\n              cursor.continue();\n            };\n            req.onerror = eventRejectHandler(reject);\n          }\n        });\n      };\n    }\n  \n    return {\n      name: tableName,\n      schema: tableSchema,\n      \n      mutate,\n\n      getMany ({trans, keys}) {\n        return new Promise<any[]>((resolve, reject) => {\n          resolve = wrap(resolve);\n          const store = (trans as IDBTransaction).objectStore(tableName);\n          const length = keys.length;\n          const result = new Array(length);\n          let keyCount = 0;\n          let callbackCount = 0;\n          let valueCount = 0;\n          let req: IDBRequest & {_pos?: number};\n    \n          const successHandler = event => {\n            const req = event.target;\n            if ((result[req._pos] = req.result) != null) ++valueCount;\n            if (++callbackCount === keyCount) resolve(result);\n          };\n          const errorHandler = eventRejectHandler(reject);\n    \n          for (let i=0; i<length; ++i) {\n            const key = keys[i];\n            if (key != null) {\n              req = store.get(keys[i]);\n              req._pos = i;\n              req.onsuccess = successHandler;\n              req.onerror = errorHandler;\n              ++keyCount;\n            }\n          }\n          if (keyCount === 0) resolve(result);\n        });\n      },\n\n      get ({trans, key}) {\n        return new Promise<any>((resolve, reject) => {\n          resolve = wrap (resolve);\n          const store = (trans as IDBTransaction).objectStore(tableName);\n          const req = store.get(key);\n          req.onsuccess = event => resolve((event.target as any).result);\n          req.onerror = eventRejectHandler(reject);\n        });\n      },\n\n      query: query(hasGetAll),\n      \n      openCursor,\n\n      count ({query, trans}) {\n        const {index, range} = query;\n        return new Promise<number>((resolve, reject) => {\n          const store = (trans as IDBTransaction).objectStore(tableName);\n          const source = index.isPrimaryKey ? store : store.index(index.name);\n          const idbKeyRange = makeIDBKeyRange(range);\n          const req = idbKeyRange ? source.count(idbKeyRange) : source.count();\n          req.onsuccess = wrap(ev => resolve((ev.target as IDBRequest).result));\n          req.onerror = eventRejectHandler(reject);\n        });\n      }\n    };\n  }\n\n  const {schema, hasGetAll} = extractSchema(db, tmpTrans);\n  const tables = schema.tables.map(tableSchema => createDbCoreTable(tableSchema));\n  const tableMap: {[name: string]: DBCoreTable} = {};\n  tables.forEach(table => tableMap[table.name] = table);\n  return {\n    stack: \"dbcore\",\n    \n    transaction: db.transaction.bind(db),\n\n    table(name: string) {\n      const result = tableMap[name];\n      if (!result) throw new Error(`Table '${name}' not found`);\n      return tableMap[name];\n    },\n\n    MIN_KEY: -Infinity,\n\n    MAX_KEY: getMaxKey(IdbKeyRange),\n\n    schema\n\n  };\n}\n", "import { Dexie } from './';\nimport { createDBCore } from '../../dbcore/dbcore-indexeddb';\nimport { DBCore } from '../../public/types/dbcore';\nimport { DexieDOMDependencies } from '../../public/types/dexie-dom-dependencies';\nimport { DexieStacks, Middleware } from '../../public/types/middleware';\nimport { exceptions } from '../../errors';\n\nfunction createMiddlewareStack<TStack extends {stack: string}>(\n  stackImpl: {stack: string},\n  middlewares: Middleware<{stack: string}>[]): TStack {\n  return middlewares.reduce((down, {create}) => ({...down, ...create(down)}), stackImpl) as TStack;\n} \n\nfunction createMiddlewareStacks(\n  middlewares: {[StackName in keyof DexieStacks]?: Middleware<DexieStacks[StackName]>[]},\n  idbdb: IDBDatabase,\n  {IDBKeyRange, indexedDB}: DexieDOMDependencies,\n  tmpTrans: IDBTransaction): {[StackName in keyof DexieStacks]?: DexieStacks[StackName]}\n{\n  const dbcore = createMiddlewareStack<DBCore>(\n    createDBCore(idbdb, IDBKeyRange, tmpTrans),\n    middlewares.dbcore);\n  \n  // TODO: Create other stacks the same way as above. They might be dependant on the result\n  // of creating dbcore stack.\n\n  return {\n    dbcore\n  };\n}\n\nexport function generateMiddlewareStacks({_novip: db}: Dexie, tmpTrans: IDBTransaction) {\n  const idbdb = tmpTrans.db;\n  const stacks = createMiddlewareStacks(db._middlewares, idbdb, db._deps, tmpTrans);\n  db.core = stacks.dbcore!;\n  db.tables.forEach(table => {\n    const tableName = table.name;\n    if (db.core.schema.tables.some(tbl => tbl.name === tableName)) {\n      table.core = db.core.table(tableName);\n      if (db[tableName] instanceof db.Table) {\n          db[tableName].core = table.core;\n      }\n    }\n  });\n}\n", "import { Dexie } from '../dexie';\nimport { DbSchema } from '../../public/types/db-schema';\nimport { _global } from \"../../globals/global\";\nimport { setProp, keys, slice, isArray, shallowClone, isAsyncFunction, defineProperty, getPropertyDescriptor } from '../../functions/utils';\nimport { Transaction } from '../transaction';\nimport { Version } from './version';\nimport Promise, { PSD, newScope, NativePromise, decrementExpectedAwaits, incrementExpectedAwaits } from '../../helpers/promise';\nimport { exceptions } from '../../errors';\nimport { TableSchema } from '../../public/types/table-schema';\nimport { IndexSpec } from '../../public/types/index-spec';\nimport { hasIEDeleteObjectStoreBug, isIEOrEdge } from '../../globals/constants';\nimport { safariMultiStoreFix } from '../../functions/quirks';\nimport { createIndexSpec, nameFromKeyPath } from '../../helpers/index-spec';\nimport { createTableSchema } from '../../helpers/table-schema';\nimport { generateMiddlewareStacks } from '../dexie/generate-middleware-stacks';\n\nexport function setApiOnPlace({_novip: db}: Dexie, objs: Object[], tableNames: string[], dbschema: DbSchema) {\n  tableNames.forEach(tableName => {\n    const schema = dbschema[tableName];\n    objs.forEach(obj => {\n      const propDesc = getPropertyDescriptor(obj, tableName);\n      if (!propDesc || (\"value\" in propDesc && propDesc.value === undefined)) {\n        // Either the prop is not declared, or it is initialized to undefined.\n        if (obj === db.Transaction.prototype || obj instanceof db.Transaction) {\n          // obj is a Transaction prototype (or prototype of a subclass to Transaction)\n          // Make the API a getter that returns this.table(tableName)\n          setProp(obj, tableName, {\n            get(this: Transaction) { return this.table(tableName); },\n            set(value: any) {\n              // Issue #1039\n              // Let \"this.schema = dbschema;\" and other props in transaction constructor work even if there's a name collision with the table name.\n              defineProperty(this, tableName, {value, writable: true, configurable: true, enumerable: true});\n            }\n          });\n        } else {\n          // Table will not be bound to a transaction (will use Dexie.currentTransaction)\n          obj[tableName] = new db.Table(tableName, schema);\n        }\n      }\n    });\n  });\n}\n\nexport function removeTablesApi({_novip: db}: Dexie, objs: Object[]) {\n  objs.forEach(obj => {\n    for (let key in obj) {\n      if (obj[key] instanceof db.Table) delete obj[key];\n    }\n  });\n}\n\nexport function lowerVersionFirst(a: Version, b: Version) {\n  return a._cfg.version - b._cfg.version;\n}\n\nexport function runUpgraders(db: Dexie, oldVersion: number, idbUpgradeTrans: IDBTransaction, reject) {\n  const globalSchema = db._dbSchema;\n  const trans = db._createTransaction('readwrite', db._storeNames, globalSchema);\n  trans.create(idbUpgradeTrans);\n  trans._completion.catch(reject);\n  const rejectTransaction = trans._reject.bind(trans);\n  const transless = PSD.transless || PSD;\n  newScope(() => {\n    PSD.trans = trans;\n    PSD.transless = transless;\n    if (oldVersion === 0) {\n      // Create tables:\n      keys(globalSchema).forEach(tableName => {\n        createTable(idbUpgradeTrans, tableName, globalSchema[tableName].primKey, globalSchema[tableName].indexes);\n      });\n      generateMiddlewareStacks(db, idbUpgradeTrans);\n      Promise.follow(() => db.on.populate.fire(trans)).catch(rejectTransaction);\n    } else\n      updateTablesAndIndexes(db, oldVersion, trans, idbUpgradeTrans).catch(rejectTransaction);\n  });\n}\n\nexport type UpgradeQueueItem = (idbtrans: IDBTransaction) => PromiseLike<any> | void;\n\nexport function updateTablesAndIndexes(\n  {_novip: db}: Dexie,\n  oldVersion: number,\n  trans: Transaction,\n  idbUpgradeTrans: IDBTransaction)\n{\n  // Upgrade version to version, step-by-step from oldest to newest version.\n  // Each transaction object will contain the table set that was current in that version (but also not-yet-deleted tables from its previous version)\n  const queue: UpgradeQueueItem[] = [];\n  const versions = db._versions;\n  let globalSchema = db._dbSchema = buildGlobalSchema(db, db.idbdb, idbUpgradeTrans);\n  let anyContentUpgraderHasRun = false;\n\n  const versToRun = versions.filter(v => v._cfg.version >= oldVersion);\n  versToRun.forEach(version => {\n    queue.push(() => {\n      const oldSchema = globalSchema;\n      const newSchema = version._cfg.dbschema;\n      adjustToExistingIndexNames(db, oldSchema, idbUpgradeTrans);\n      adjustToExistingIndexNames(db, newSchema, idbUpgradeTrans);\n\n      globalSchema = db._dbSchema = newSchema;\n\n      const diff = getSchemaDiff(oldSchema, newSchema);\n      // Add tables           \n      diff.add.forEach(tuple => {\n        createTable(idbUpgradeTrans, tuple[0], tuple[1].primKey, tuple[1].indexes);\n      });\n      // Change tables\n      diff.change.forEach(change => {\n        if (change.recreate) {\n          throw new exceptions.Upgrade(\"Not yet support for changing primary key\");\n        } else {\n          const store = idbUpgradeTrans.objectStore(change.name);\n          // Add indexes\n          change.add.forEach(idx => addIndex(store, idx));\n          // Update indexes\n          change.change.forEach(idx => {\n            store.deleteIndex(idx.name);\n            addIndex(store, idx);\n          });\n          // Delete indexes\n          change.del.forEach(idxName => store.deleteIndex(idxName));\n        }\n      });\n\n      const contentUpgrade = version._cfg.contentUpgrade;\n\n      if (contentUpgrade && version._cfg.version > oldVersion) {\n        // Update db.core with new tables and indexes:\n        generateMiddlewareStacks(db, idbUpgradeTrans);\n        trans._memoizedTables = {}; // Invalidate memoization as transaction shape may change between versions.\n\n        anyContentUpgraderHasRun = true;\n\n        // Add to-be-deleted tables to contentUpgrade transaction\n        let upgradeSchema = shallowClone(newSchema);\n        diff.del.forEach(table => {\n          upgradeSchema[table] = oldSchema[table];\n        });\n\n        // Safe to affect Transaction.prototype globally in this moment,\n        // because when this code runs, there may not be any other code\n        // that can access any transaction instance, else than this particular\n        // upgrader function.\n        removeTablesApi(db, [db.Transaction.prototype]);\n        setApiOnPlace(db, [db.Transaction.prototype], keys(upgradeSchema), upgradeSchema);\n        trans.schema = upgradeSchema;\n\n        // Support for native async await.\n        const contentUpgradeIsAsync = isAsyncFunction(contentUpgrade);\n        if (contentUpgradeIsAsync) {\n          incrementExpectedAwaits();\n        }\n        \n        let returnValue: any;\n        const promiseFollowed = Promise.follow(() => {\n          // Finally, call the scope function with our table and transaction arguments.\n          returnValue = contentUpgrade(trans);\n          if (returnValue) {\n            if (contentUpgradeIsAsync) {\n              // contentUpgrade is a native async function - we know for sure returnValue is native promise.\n              var decrementor = decrementExpectedAwaits.bind(null, null);\n              returnValue.then(decrementor, decrementor);\n            }\n          }\n        });\n        return (returnValue && typeof returnValue.then === 'function' ?\n          Promise.resolve(returnValue) : promiseFollowed.then(()=>returnValue));\n      }\n    });\n    queue.push(idbtrans => {\n      if (!anyContentUpgraderHasRun || !hasIEDeleteObjectStoreBug) { // Dont delete old tables if ieBug is present and a content upgrader has run. Let tables be left in DB so far. This needs to be taken care of.\n        const newSchema = version._cfg.dbschema;\n        // Delete old tables\n        deleteRemovedTables(newSchema, idbtrans);\n      }\n      // Restore the final API\n      removeTablesApi(db, [db.Transaction.prototype]);\n      setApiOnPlace(db, [db.Transaction.prototype], db._storeNames, db._dbSchema);\n      trans.schema = db._dbSchema;\n    });\n  });\n\n  // Now, create a queue execution engine\n  function runQueue() {\n    return queue.length ? Promise.resolve(queue.shift()(trans.idbtrans)).then(runQueue) :\n      Promise.resolve();\n  }\n\n  return runQueue().then(() => {\n    createMissingTables(globalSchema, idbUpgradeTrans); // At last, make sure to create any missing tables. (Needed by addons that add stores to DB without specifying version)\n  });\n}\n\nexport interface SchemaDiff {\n  del: string[],\n  add: [string, TableSchema][];\n  change: TableSchemaDiff[];\n}\n\nexport interface TableSchemaDiff {\n  name: string,\n  recreate: boolean,\n  del: string[],\n  add: IndexSpec[],\n  change: IndexSpec[]\n}\n\nexport function getSchemaDiff(oldSchema: DbSchema, newSchema: DbSchema): SchemaDiff {\n  const diff: SchemaDiff = {\n    del: [], // Array of table names\n    add: [], // Array of [tableName, newDefinition]\n    change: [] // Array of {name: tableName, recreate: newDefinition, del: delIndexNames, add: newIndexDefs, change: changedIndexDefs}\n  };\n  let table: string;\n  for (table in oldSchema) {\n    if (!newSchema[table]) diff.del.push(table);\n  }\n  for (table in newSchema) {\n    const oldDef = oldSchema[table],\n      newDef = newSchema[table];\n    if (!oldDef) {\n      diff.add.push([table, newDef]);\n    } else {\n      const change = {\n        name: table,\n        def: newDef,\n        recreate: false,\n        del: [],\n        add: [],\n        change: []\n      };\n      if (\n          (\n             // compare keyPaths no matter if string or string[]\n             // compare falsy keypaths same no matter if they are null or empty string.\n            ''+(oldDef.primKey.keyPath||'')\n          ) !== (\n            ''+(newDef.primKey.keyPath||'')\n          ) ||\n            // Compare the autoIncrement flag also\n          (oldDef.primKey.auto !== newDef.primKey.auto && !isIEOrEdge)) // IE has bug reading autoIncrement prop.\n      {\n        // Primary key has changed. Remove and re-add table.\n        change.recreate = true;\n        diff.change.push(change);\n      } else {\n        // Same primary key. Just find out what differs:\n        const oldIndexes = oldDef.idxByName;\n        const newIndexes = newDef.idxByName;\n        let idxName: string;\n        for (idxName in oldIndexes) {\n          if (!newIndexes[idxName]) change.del.push(idxName);\n        }\n        for (idxName in newIndexes) {\n          const oldIdx = oldIndexes[idxName],\n            newIdx = newIndexes[idxName];\n          if (!oldIdx) change.add.push(newIdx);\n          else if (oldIdx.src !== newIdx.src) change.change.push(newIdx);\n        }\n        if (change.del.length > 0 || change.add.length > 0 || change.change.length > 0) {\n          diff.change.push(change);\n        }\n      }\n    }\n  }\n  return diff;\n}\n\nexport function createTable(\n  idbtrans: IDBTransaction,\n  tableName: string,\n  primKey: IndexSpec,\n  indexes: IndexSpec[]\n) {\n  const store = idbtrans.db.createObjectStore(\n    tableName,\n    primKey.keyPath ?\n      { keyPath: primKey.keyPath, autoIncrement: primKey.auto } :\n      { autoIncrement: primKey.auto }\n  );\n  indexes.forEach(idx => addIndex(store, idx));\n  return store;\n}\n\nexport function createMissingTables(newSchema: DbSchema, idbtrans: IDBTransaction) {\n  keys(newSchema).forEach(tableName => {\n    if (!idbtrans.db.objectStoreNames.contains(tableName)) {\n      createTable(idbtrans, tableName, newSchema[tableName].primKey, newSchema[tableName].indexes);\n    }\n  });\n}\n\nexport function deleteRemovedTables(newSchema: DbSchema, idbtrans: IDBTransaction) {\n  [].slice.call(idbtrans.db.objectStoreNames).forEach(storeName =>\n    newSchema[storeName] == null && idbtrans.db.deleteObjectStore(storeName));\n}\n\nexport function addIndex(store: IDBObjectStore, idx: IndexSpec) {\n  store.createIndex(idx.name, idx.keyPath, { unique: idx.unique, multiEntry: idx.multi });\n}\n\nfunction buildGlobalSchema(\n  db: Dexie,\n  idbdb: IDBDatabase,\n  tmpTrans: IDBTransaction\n) {\n  const globalSchema = {};\n  const dbStoreNames = slice(idbdb.objectStoreNames, 0);\n  dbStoreNames.forEach(storeName => {\n    const store = tmpTrans.objectStore(storeName);\n    let keyPath = store.keyPath;\n    const primKey = createIndexSpec(\n      nameFromKeyPath(keyPath),\n      keyPath || \"\",\n      false,\n      false,\n      !!store.autoIncrement,\n      keyPath && typeof keyPath !== \"string\",\n      true\n    );\n    const indexes: IndexSpec[] = [];\n    for (let j = 0; j < store.indexNames.length; ++j) {\n      const idbindex = store.index(store.indexNames[j]);\n      keyPath = idbindex.keyPath;\n      var index = createIndexSpec(\n        idbindex.name,\n        keyPath,\n        !!idbindex.unique,\n        !!idbindex.multiEntry,\n        false,\n        keyPath && typeof keyPath !== \"string\",\n        false\n      );\n      indexes.push(index);\n    }\n    globalSchema[storeName] = createTableSchema(storeName, primKey, indexes);\n  });\n  return globalSchema;\n}\n\nexport function readGlobalSchema({_novip: db}: Dexie, idbdb: IDBDatabase, tmpTrans: IDBTransaction) {\n  db.verno = idbdb.version / 10;\n  const globalSchema = db._dbSchema = buildGlobalSchema(db, idbdb, tmpTrans);\n  db._storeNames = slice(idbdb.objectStoreNames, 0);\n  setApiOnPlace(db, [db._allTables], keys(globalSchema), globalSchema);\n}\n\nexport function verifyInstalledSchema(db: Dexie, tmpTrans: IDBTransaction): boolean {\n  const installedSchema = buildGlobalSchema(db, db.idbdb, tmpTrans);\n  const diff = getSchemaDiff(installedSchema, db._dbSchema);\n  return !(diff.add.length || diff.change.some(ch => ch.add.length || ch.change.length));\n}\n\nexport function adjustToExistingIndexNames({_novip: db}: Dexie, schema: DbSchema, idbtrans: IDBTransaction) {\n  // Issue #30 Problem with existing db - adjust to existing index names when migrating from non-dexie db\n  const storeNames = idbtrans.db.objectStoreNames;\n\n  for (let i = 0; i < storeNames.length; ++i) {\n    const storeName = storeNames[i];\n    const store = idbtrans.objectStore(storeName);\n    db._hasGetAll = 'getAll' in store;\n\n    for (let j = 0; j < store.indexNames.length; ++j) {\n      const indexName = store.indexNames[j];\n      const keyPath = store.index(indexName).keyPath;\n      const dexieName = typeof keyPath === 'string' ? keyPath : \"[\" + slice(keyPath).join('+') + \"]\";\n      if (schema[storeName]) {\n        const indexSpec = schema[storeName].idxByName[dexieName];\n        if (indexSpec) {\n          indexSpec.name = indexName;\n          delete schema[storeName].idxByName[dexieName];\n          schema[storeName].idxByName[indexName] = indexSpec;\n        }\n      }\n    }\n  }\n\n  // Bug with getAll() on Safari ver<604 on Workers only, see discussion following PR #579\n  if (typeof navigator !== 'undefined' && /Safari/.test(navigator.userAgent) &&\n    !/(Chrome\\/|Edge\\/)/.test(navigator.userAgent) &&\n    _global.WorkerGlobalScope && _global instanceof _global.WorkerGlobalScope &&\n    [].concat(navigator.userAgent.match(/Safari\\/(\\d*)/))[1] < 604)\n  {\n    db._hasGetAll = false;\n  }\n}\n\nexport function parseIndexSyntax(primKeyAndIndexes: string): IndexSpec[] {\n  return primKeyAndIndexes.split(',').map((index, indexNum) => {\n    index = index.trim();\n    const name = index.replace(/([&*]|\\+\\+)/g, \"\"); // Remove \"&\", \"++\" and \"*\"\n    // Let keyPath of \"[a+b]\" be [\"a\",\"b\"]:\n    const keyPath = /^\\[/.test(name) ? name.match(/^\\[(.*)\\]$/)[1].split('+') : name;\n\n    return createIndexSpec(\n      name,\n      keyPath || null,\n      /\\&/.test(index),\n      /\\*/.test(index),\n      /\\+\\+/.test(index),\n      isArray(keyPath),\n      indexNum === 0\n    );\n  });\n}\n", "import { Version as IVersion } from '../../public/types/version';\nimport { DbSchema } from '../../public/types/db-schema';\nimport { extend, keys } from '../../functions/utils';\nimport { Dexie } from '../dexie';\nimport { Transaction } from '../transaction';\nimport { removeTablesApi, setApiOnPlace, parseIndexSyntax } from './schema-helpers';\nimport { exceptions } from '../../errors';\nimport { createTableSchema } from '../../helpers/table-schema';\nimport { nop, promisableChain } from '../../functions/chaining-functions';\n\n/** class Version\n *\n * https://dexie.org/docs/Version/Version\n */\nexport class Version implements IVersion {\n  db: Dexie;\n  _cfg: {\n    version: number,\n    storesSource: { [tableName: string]: string | null },\n    dbschema: DbSchema,\n    tables: {},\n    contentUpgrade: Function | null\n  }\n\n  _parseStoresSpec(stores: { [tableName: string]: string | null }, outSchema: DbSchema): any {\n    keys(stores).forEach(tableName => {\n      if (stores[tableName] !== null) {\n          var indexes = parseIndexSyntax(stores[tableName]);\n          var primKey = indexes.shift();\n          if (primKey.multi) throw new exceptions.Schema(\"Primary key cannot be multi-valued\");\n          indexes.forEach(idx => {\n              if (idx.auto) throw new exceptions.Schema(\"Only primary key can be marked as autoIncrement (++)\");\n              if (!idx.keyPath) throw new exceptions.Schema(\"Index must have a name and cannot be an empty string\");\n          });\n          outSchema[tableName] = createTableSchema(tableName, primKey, indexes);\n      }\n    });\n  }\n\n  stores(stores: { [key: string]: string | null; }): IVersion {\n    const db = this.db;\n    this._cfg.storesSource = this._cfg.storesSource ?\n      extend(this._cfg.storesSource, stores) :\n      stores;\n    const versions = db._versions;\n\n    // Derive stores from earlier versions if they are not explicitely specified as null or a new syntax.\n    const storesSpec: { [key: string]: string; } = {};\n    let dbschema = {};\n    versions.forEach(version => { // 'versions' is always sorted by lowest version first.\n      extend(storesSpec, version._cfg.storesSource);\n      dbschema = (version._cfg.dbschema = {});\n      version._parseStoresSpec(storesSpec, dbschema);\n    });\n    // Update the latest schema to this version\n    db._dbSchema = dbschema;\n    // Update APIs\n    removeTablesApi(db, [db._allTables, db, db.Transaction.prototype]);\n    setApiOnPlace(db, [db._allTables, db, db.Transaction.prototype, this._cfg.tables], keys(dbschema), dbschema);\n    db._storeNames = keys(dbschema);\n    return this;\n  }\n\n  upgrade(upgradeFunction: (trans: Transaction) => PromiseLike<any> | void): Version {\n    this._cfg.contentUpgrade = promisableChain(this._cfg.contentUpgrade || nop, upgradeFunction);\n    return this;\n  }\n}\n", "import { Dexie } from '../dexie';\nimport { makeClassConstructor } from '../../functions/make-class-constructor';\nimport { Version } from './version';\n\nexport interface VersionConstructor {\n  new(versionNumber: number): Version;\n  prototype: Version;\n}\n\n/** Generates a Version constructor bound to given Dexie instance.\n * \n * The purpose of having dynamically created constructors, is to allow\n * addons to extend classes for a certain Dexie instance without affecting\n * other db instances.\n */\nexport function createVersionConstructor(db: Dexie) {\n  return makeClassConstructor<VersionConstructor>(\n    Version.prototype,\n\n    function Version(this: Version, versionNumber: number) {\n      this.db = db;\n      this._cfg = {\n        version: versionNumber,\n        storesSource: null,\n        dbschema: {},\n        tables: {},\n        contentUpgrade: null\n      };\n    });\n\n}\n", "import { Dexie } from \"../classes/dexie/dexie\";\nimport { Table } from \"../public/types/table\";\nimport { DBNAMES_DB } from \"../globals/constants\";\nimport { DexieDOMDependencies } from \"../public/types/dexie-dom-dependencies\";\nimport { nop } from \"../functions/chaining-functions\";\n\ntype IDBKeyNamesVar = typeof IDBKeyRange;\n\nfunction getDbNamesTable(indexedDB: IDBFactory, IDBKeyRange: IDBKeyNamesVar) {\n  let dbNamesDB = indexedDB[\"_dbNamesDB\"];\n  if (!dbNamesDB) {\n    dbNamesDB = indexedDB[\"_dbNamesDB\"] = new Dexie(DBNAMES_DB, {\n      addons: [],\n      indexedDB,\n      IDBKeyRange,\n    });\n    dbNamesDB.version(1).stores({ dbnames: \"name\" });\n  }\n  return dbNamesDB.table(\"dbnames\") as Table<{ name: string }, string>;\n}\n\nfunction hasDatabasesNative(indexedDB: IDBFactory) {\n  return indexedDB && typeof indexedDB.databases === \"function\";\n}\n\nexport function getDatabaseNames({\n  indexedDB,\n  IDBKeyRange,\n}: DexieDOMDependencies) {\n  return hasDatabasesNative(indexedDB)\n    ? Promise.resolve(indexedDB.databases()).then((infos) =>\n        infos\n          // Select name prop of infos:\n          .map((info) => info.name)\n          // Filter out DBNAMES_DB as previous Dexie or browser version would not have included it in the result.\n          .filter((name) => name !== DBNAMES_DB)\n      )\n    : getDbNamesTable(indexedDB, IDBKeyRange).toCollection().primaryKeys();\n}\n\nexport function _onDatabaseCreated(\n  { indexedDB, IDBKeyRange }: DexieDOMDependencies,\n  name: string\n) {\n  !hasDatabasesNative(indexedDB) &&\n    name !== DBNAMES_DB &&\n    getDbNamesTable(indexedDB, IDBKeyRange).put({name}).catch(nop);\n}\n\nexport function _onDatabaseDeleted(\n  { indexedDB, IDBKeyRange }: DexieDOMDependencies,\n  name: string\n) {\n  !hasDatabasesNative(indexedDB) &&\n    name !== DBNAMES_DB &&\n    getDbNamesTable(indexedDB, IDBKeyRange).delete(name).catch(nop);\n}\n", "import { newScope } from '../../helpers/promise';\nimport { PSD } from '../../helpers/promise';\n\nexport function vip (fn) {\n  // To be used by subscribers to the on('ready') event.\n  // This will let caller through to access DB even when it is blocked while the db.ready() subscribers are firing.\n  // This would have worked automatically if we were certain that the Provider was using Dexie.Promise for all asyncronic operations. The promise PSD\n  // from the provider.connect() call would then be derived all the way to when provider would call localDatabase.applyChanges(). But since\n  // the provider more likely is using non-promise async APIs or other thenable implementations, we cannot assume that.\n  // Note that this method is only useful for on('ready') subscribers that is returning a Promise from the event. If not using vip()\n  // the database could deadlock since it wont open until the returned Promise is resolved, and any non-VIPed operation started by\n  // the caller will not resolve until database is opened.\n  return newScope(function () {\n    PSD.letThrough = true; // Make sure we are let through if still blocking db due to onready is firing.\n    return fn();\n  });\n}\n\n", "/**\n * Work around Safari 14 IndexedDB open bug.\n *\n * Safari has a horrible bug where IDB requests can hang while the browser is starting up. https://bugs.webkit.org/show_bug.cgi?id=226547\n * The only solution is to keep nudging it until it's awake.\n */\nfunction idbReady() {\n    var isSafari = !navigator.userAgentData &&\n        /Safari\\//.test(navigator.userAgent) &&\n        !/Chrom(e|ium)\\//.test(navigator.userAgent);\n    // No point putting other browsers or older versions of Safari through this mess.\n    if (!isSafari || !indexedDB.databases)\n        return Promise.resolve();\n    var intervalId;\n    return new Promise(function (resolve) {\n        var tryIdb = function () { return indexedDB.databases().finally(resolve); };\n        intervalId = setInterval(tryIdb, 100);\n        tryIdb();\n    }).finally(function () { return clearInterval(intervalId); });\n}\n\nexport default idbReady;\n", "import { Dexie } from './dexie';\nimport * as Debug from '../../helpers/debug';\nimport { rejection } from '../../helpers/promise';\nimport { exceptions } from '../../errors';\nimport { eventRejectHandler, preventDefault } from '../../functions/event-wrappers';\nimport Promise, { wrap } from '../../helpers/promise';\nimport { connections } from '../../globals/constants';\nimport { runUpgraders, readGlobalSchema, adjustToExistingIndexNames, verifyInstalledSchema } from '../version/schema-helpers';\nimport { safariMultiStoreFix } from '../../functions/quirks';\nimport { _onDatabaseCreated } from '../../helpers/database-enumerator';\nimport { vip } from './vip';\nimport { promisableChain, nop } from '../../functions/chaining-functions';\nimport { generateMiddlewareStacks } from './generate-middleware-stacks';\nimport { slice } from '../../functions/utils';\nimport safari14Workaround from 'safari-14-idb-fix';\n\nexport function dexieOpen (db: Dexie) {\n  const state = db._state;\n  const {indexedDB} = db._deps;\n  if (state.isBeingOpened || db.idbdb)\n      return state.dbReadyPromise.then<Dexie>(() => state.dbOpenError ?\n        rejection (state.dbOpenError) :\n        db);\n  Debug.debug && (state.openCanceller._stackHolder = Debug.getErrorWithStack()); // Let stacks point to when open() was called rather than where new Dexie() was called.\n  state.isBeingOpened = true;\n  state.dbOpenError = null;\n  state.openComplete = false;\n  const openCanceller = state.openCanceller;\n\n  function throwIfCancelled() {\n    // If state.openCanceller object reference is replaced, it means db.close() has been called,\n    // meaning this open flow should be cancelled.\n    if (state.openCanceller !== openCanceller) throw new exceptions.DatabaseClosed('db.open() was cancelled');\n  }\n  \n  // Function pointers to call when the core opening process completes.\n  let resolveDbReady = state.dbReadyResolve,\n      // upgradeTransaction to abort on failure.\n      upgradeTransaction: (IDBTransaction | null) = null,\n      wasCreated = false;\n  \n  // safari14Workaround = Workaround by jakearchibald for new nasty bug in safari 14.\n  return Promise.race([openCanceller, (typeof navigator === 'undefined' ? Promise.resolve() : safari14Workaround()).then(() => new Promise((resolve, reject) => {\n      // Multiply db.verno with 10 will be needed to workaround upgrading bug in IE:\n      // IE fails when deleting objectStore after reading from it.\n      // A future version of Dexie.js will stopover an intermediate version to workaround this.\n      // At that point, we want to be backward compatible. Could have been multiplied with 2, but by using 10, it is easier to map the number to the real version number.\n      \n      throwIfCancelled();\n      // If no API, throw!\n      if (!indexedDB) throw new exceptions.MissingAPI();\n      const dbName = db.name;\n      \n      const req = state.autoSchema ?\n        indexedDB.open(dbName) :\n        indexedDB.open(dbName, Math.round(db.verno * 10));\n      if (!req) throw new exceptions.MissingAPI(); // May happen in Safari private mode, see https://github.com/dfahlander/Dexie.js/issues/134\n      req.onerror = eventRejectHandler(reject);\n      req.onblocked = wrap(db._fireOnBlocked);\n      req.onupgradeneeded = wrap (e => {\n          upgradeTransaction = req.transaction;\n          if (state.autoSchema && !db._options.allowEmptyDB) { // Unless an addon has specified db._allowEmptyDB, lets make the call fail.\n              // Caller did not specify a version or schema. Doing that is only acceptable for opening alread existing databases.\n              // If onupgradeneeded is called it means database did not exist. Reject the open() promise and make sure that we\n              // do not create a new database by accident here.\n              req.onerror = preventDefault; // Prohibit onabort error from firing before we're done!\n              upgradeTransaction.abort(); // Abort transaction (would hope that this would make DB disappear but it doesnt.)\n              // Close database and delete it.\n              req.result.close();\n              const delreq = indexedDB.deleteDatabase(dbName); // The upgrade transaction is atomic, and javascript is single threaded - meaning that there is no risk that we delete someone elses database here!\n              delreq.onsuccess = delreq.onerror = wrap(() => {\n                  reject (new exceptions.NoSuchDatabase(`Database ${dbName} doesnt exist`));\n              });\n          } else {\n              upgradeTransaction.onerror = eventRejectHandler(reject);\n              var oldVer = e.oldVersion > Math.pow(2, 62) ? 0 : e.oldVersion; // Safari 8 fix.\n              wasCreated = oldVer < 1;\n              db._novip.idbdb = req.result;// db._novip is because db can be an Object.create(origDb).\n              runUpgraders(db, oldVer / 10, upgradeTransaction, reject);\n          }\n      }, reject);\n      \n      req.onsuccess = wrap (() => {\n          // Core opening procedure complete. Now let's just record some stuff.\n          upgradeTransaction = null;\n          const idbdb = db._novip.idbdb = req.result; // db._novip is because db can be an Object.create(origDb).\n\n          const objectStoreNames = slice(idbdb.objectStoreNames);\n          if (objectStoreNames.length > 0) try {\n            const tmpTrans = idbdb.transaction(safariMultiStoreFix(objectStoreNames), 'readonly');\n            if (state.autoSchema) readGlobalSchema(db, idbdb, tmpTrans);\n            else {\n                adjustToExistingIndexNames(db, db._dbSchema, tmpTrans);\n                if (!verifyInstalledSchema(db, tmpTrans)) {\n                    console.warn(`Dexie SchemaDiff: Schema was extended without increasing the number passed to db.version(). Some queries may fail.`);\n                }\n            }\n            generateMiddlewareStacks(db, tmpTrans);\n          } catch (e) {\n            // Safari 8 may bail out if > 1 store names. However, this shouldnt be a showstopper. Issue #120.\n            // BUGBUG: It will bail out anyway as of Dexie 3.\n            // Should we support Safari 8 anymore? Believe all\n            // Dexie users use the shim for that platform anyway?!\n            // If removing Safari 8 support, go ahead and remove the safariMultiStoreFix() function\n            // as well as absurd upgrade version quirk for Safari.\n          }\n          \n          connections.push(db); // Used for emulating versionchange event on IE/Edge/Safari.\n          \n          idbdb.onversionchange = wrap(ev => {\n              state.vcFired = true; // detect implementations that not support versionchange (IE/Edge/Safari)\n              db.on(\"versionchange\").fire(ev);\n          });\n          \n          idbdb.onclose = wrap(ev => {\n              db.on(\"close\").fire(ev);\n          });\n\n          if (wasCreated) _onDatabaseCreated(db._deps, dbName);\n\n          resolve();\n\n      }, reject);\n  }))]).then(() => {\n      // Before finally resolving the dbReadyPromise and this promise,\n      // call and await all on('ready') subscribers:\n      // Dexie.vip() makes subscribers able to use the database while being opened.\n      // This is a must since these subscribers take part of the opening procedure.\n      throwIfCancelled();\n      state.onReadyBeingFired = [];\n      return Promise.resolve(vip(()=>db.on.ready.fire(db.vip))).then(function fireRemainders() {\n          if (state.onReadyBeingFired.length > 0) {\n              // In case additional subscribers to db.on('ready') were added during the time db.on.ready.fire was executed.\n              let remainders = state.onReadyBeingFired.reduce(promisableChain, nop);\n              state.onReadyBeingFired = [];\n              return Promise.resolve(vip(()=>remainders(db.vip))).then(fireRemainders)\n          }\n      });\n  }).finally(()=>{\n      state.onReadyBeingFired = null;\n      state.isBeingOpened = false;\n  }).then(()=>{\n      // Resolve the db.open() with the db instance.\n      return db;\n  }).catch(err => {\n      state.dbOpenError = err; // Record the error. It will be used to reject further promises of db operations.\n      try {\n        // Did we fail within onupgradeneeded? Make sure to abort the upgrade transaction so it doesnt commit.\n        upgradeTransaction && upgradeTransaction.abort();\n      } catch { }\n      if (openCanceller === state.openCanceller) {\n        // Still in the same open flow - The error reason was not due to external call to db.close().\n        // Make sure to call db.close() to finalize resources.\n        db._close(); // Closes and resets idbdb, removes connections, resets dbReadyPromise and openCanceller so that a later db.open() is fresh.\n      }\n      return rejection (err);\n  }).finally(()=>{\n      state.openComplete = true;\n      resolveDbReady(); // dbReadyPromise is resolved no matter if open() rejects or resolved. It's just to wake up waiters.\n  });\n}\n", "import { isArray } from '../functions/utils';\n\nexport function awaitIterator (iterator: Iterator<any>) {\n  var callNext = result => iterator.next(result),\n      doThrow = error => iterator.throw(error),\n      onSuccess = step(callNext),\n      onError = step(doThrow);\n\n  function step(getNext: (any)=>any) {\n      return (val?) => {\n          var next = getNext(val),\n              value = next.value;\n\n          return next.done ? value :\n              (!value || typeof value.then !== 'function' ?\n                  isArray(value) ? Promise.all(value).then(onSuccess, onError) : onSuccess(value) :\n                  value.then(onSuccess, onError));\n      };\n  }\n\n  return step(callNext)();\n}\n", "import { TransactionMode } from '../../public/types/transaction-mode';\nimport { errnames, exceptions } from '../../errors';\nimport { flatten, isAsyncFunction } from '../../functions/utils';\nimport { Dexie } from './dexie';\nimport { Transaction } from '../transaction';\nimport { awaitIterator } from '../../helpers/yield-support';\nimport Promise, {\n  PSD,\n  NativePromise,\n  decrementExpectedAwaits,\n  rejection,\n  incrementExpectedAwaits\n} from '../../helpers/promise';\n\nexport function extractTransactionArgs(mode: TransactionMode, _tableArgs_, scopeFunc) {\n  // Let table arguments be all arguments between mode and last argument.\n  var i = arguments.length;\n  if (i < 2) throw new exceptions.InvalidArgument(\"Too few arguments\");\n  // Prevent optimzation killer (https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#32-leaking-arguments)\n  // and clone arguments except the first one into local var 'args'.\n  var args = new Array(i - 1);\n  while (--i) args[i - 1] = arguments[i];\n  // Let scopeFunc be the last argument and pop it so that args now only contain the table arguments.\n  scopeFunc = args.pop();\n  var tables = flatten(args); // Support using array as middle argument, or a mix of arrays and non-arrays.\n  return [mode, tables, scopeFunc];\n}\n\nexport function enterTransactionScope(\n  db: Dexie,\n  mode: IDBTransactionMode,\n  storeNames: string[],\n  parentTransaction: Transaction | undefined,\n  scopeFunc: ()=>PromiseLike<any> | any\n) {\n  return Promise.resolve().then(() => {\n    // Keep a pointer to last non-transactional PSD to use if someone calls Dexie.ignoreTransaction().\n    const transless = PSD.transless || PSD;\n    // Our transaction.\n    //return new Promise((resolve, reject) => {\n    const trans = db._createTransaction(mode, storeNames, db._dbSchema, parentTransaction);\n    // Let the transaction instance be part of a Promise-specific data (PSD) value.\n    const zoneProps = {\n      trans: trans,\n      transless: transless\n    };\n\n    if (parentTransaction) {\n      // Emulate transaction commit awareness for inner transaction (must 'commit' when the inner transaction has no more operations ongoing)\n      trans.idbtrans = parentTransaction.idbtrans;\n    } else {\n      try {\n        trans.create(); // Create the native transaction so that complete() or error() will trigger even if no operation is made upon it.\n        db._state.PR1398_maxLoop = 3;\n      } catch (ex) {\n        if (ex.name === errnames.InvalidState && db.isOpen() && --db._state.PR1398_maxLoop > 0) {\n          console.warn('Dexie: Need to reopen db');\n          db._close();\n          return db.open().then(() => enterTransactionScope(\n            db,\n            mode,\n            storeNames,\n            null,\n            scopeFunc\n          ));\n        }\n        return rejection(ex);\n      }\n    }\n\n    // Support for native async await.\n    const scopeFuncIsAsync = isAsyncFunction(scopeFunc);\n    if (scopeFuncIsAsync) {\n      incrementExpectedAwaits();\n    }\n\n    let returnValue;\n    const promiseFollowed = Promise.follow(() => {\n      // Finally, call the scope function with our table and transaction arguments.\n      returnValue = scopeFunc.call(trans, trans);\n      if (returnValue) {\n        if (scopeFuncIsAsync) {\n          // scopeFunc is a native async function - we know for sure returnValue is native promise.\n          var decrementor = decrementExpectedAwaits.bind(null, null);\n          returnValue.then(decrementor, decrementor);\n        } else if (typeof returnValue.next === 'function' && typeof returnValue.throw === 'function') {\n          // scopeFunc returned an iterator with throw-support. Handle yield as await.\n          returnValue = awaitIterator(returnValue);\n        }\n      }\n    }, zoneProps);\n    return (returnValue && typeof returnValue.then === 'function' ?\n      // Promise returned. User uses promise-style transactions.\n      Promise.resolve(returnValue).then(x => trans.active ?\n        x // Transaction still active. Continue.\n        : rejection(new exceptions.PrematureCommit(\n          \"Transaction committed too early. See http://bit.ly/2kdckMn\")))\n      // No promise returned. Wait for all outstanding promises before continuing. \n      : promiseFollowed.then(() => returnValue)\n    ).then(x => {\n      // sub transactions don't react to idbtrans.oncomplete. We must trigger a completion:\n      if (parentTransaction) trans._resolve();\n      // wait for trans._completion\n      // (if root transaction, this means 'complete' event. If sub-transaction, we've just fired it ourselves)\n      return trans._completion.then(() => x);\n    }).catch(e => {\n      trans._reject(e); // Yes, above then-handler were maybe not called because of an unhandled rejection in scopeFunc!\n      return rejection(e);\n    });\n  });\n}\n", "import {\n  DBCore,\n  DBCoreIndex,\n  DBCoreKeyRange,\n  DBCoreQueryRequest,\n  DBCoreRangeType,\n  DBCoreOpenCursorRequest,\n  DBCoreCountRequest,\n  DBCoreCursor,\n  DBCoreTable,\n} from \"../public/types/dbcore\";\nimport { isArray } from '../functions/utils';\nimport { getKeyExtractor } from './get-key-extractor';\nimport { getKeyPathAlias } from './dbcore-indexeddb';\nimport { Middleware } from '../public/types/middleware';\n\ninterface VirtualIndex extends DBCoreIndex {\n  /** True if this index is virtual, i.e. represents a compound index internally,\n   * but makes it act as as having a subset of its keyPaths.\n   */\n  isVirtual: boolean;\n\n  /** Number of keypaths that this index comprises. Can be 0..N.\n   * Note: This is the length of the *virtual index*, not the real index.\n   */\n  keyLength: number;\n\n  /** Number of popped keypaths from the real index.\n   */\n  keyTail: number;\n}\n\n// Move into some util:\nexport function pad (a: any | any[], value: any, count: number) {\n  const result = isArray(a) ? a.slice() : [a];\n  for (let i=0; i<count; ++i) result.push(value);\n  return result;\n}\n\n\nexport function createVirtualIndexMiddleware (down: DBCore) : DBCore {\n  return {\n    ...down,\n    table(tableName: string) {\n      const table = down.table(tableName);\n      const {schema} = table;\n      const indexLookup: {[indexAlias: string]: VirtualIndex[]} = {};\n      const allVirtualIndexes: VirtualIndex[] = [];\n\n      function addVirtualIndexes (keyPath: null | string | string[], keyTail: number, lowLevelIndex: DBCoreIndex): VirtualIndex {\n        const keyPathAlias = getKeyPathAlias(keyPath);\n        const indexList = (indexLookup[keyPathAlias] = indexLookup[keyPathAlias] || []);\n        const keyLength = keyPath == null ? 0: typeof keyPath === 'string' ? 1 : keyPath.length;\n        const isVirtual = keyTail > 0;\n        const virtualIndex = {\n          ...lowLevelIndex,\n          isVirtual,\n          keyTail,\n          keyLength,\n          extractKey: getKeyExtractor(keyPath),\n          unique: !isVirtual && lowLevelIndex.unique\n        };\n        indexList.push(virtualIndex);\n        if (!virtualIndex.isPrimaryKey) {\n          allVirtualIndexes.push(virtualIndex);\n        }\n        if (keyLength > 1) {\n          const virtualKeyPath = keyLength === 2 ?\n            keyPath[0] : // This is a compound [a, b]. Add a virtual normal index a.\n            keyPath.slice(0, keyLength - 1); // This is compound [a,b,c]. Add virtual compound [a,b].\n          addVirtualIndexes(virtualKeyPath, keyTail + 1, lowLevelIndex);\n        }\n        indexList.sort((a,b) => a.keyTail - b.keyTail); // Shortest keyTail is the best one (represents real index)\n        return virtualIndex;\n      }\n    \n      const primaryKey = addVirtualIndexes(schema.primaryKey.keyPath, 0, schema.primaryKey);\n      indexLookup[\":id\"] = [primaryKey];\n      for (const index of schema.indexes) {\n        addVirtualIndexes(index.keyPath, 0, index);\n      }\n    \n      function findBestIndex(keyPath: null | string | string[]): VirtualIndex {\n        const result = indexLookup[getKeyPathAlias(keyPath)];\n        return result && result[0];\n      }\n    \n      function translateRange (range: DBCoreKeyRange, keyTail: number): DBCoreKeyRange {\n        return {\n          type: range.type === DBCoreRangeType.Equal ?\n            DBCoreRangeType.Range :\n            range.type,\n          lower: pad(range.lower, range.lowerOpen ? down.MAX_KEY : down.MIN_KEY, keyTail),\n          lowerOpen: true, // doesn't matter true or false\n          upper: pad(range.upper, range.upperOpen ? down.MIN_KEY : down.MAX_KEY, keyTail),\n          upperOpen: true // doesn't matter true or false\n        };\n      }\n    \n      function translateRequest (req: DBCoreQueryRequest): DBCoreQueryRequest;\n      function translateRequest (req: DBCoreOpenCursorRequest): DBCoreOpenCursorRequest;\n      function translateRequest (req: DBCoreCountRequest): DBCoreCountRequest {\n        const index = req.query.index as VirtualIndex;\n        return index.isVirtual ? {\n          ...req,\n          query: {\n            index,\n            range: translateRange(req.query.range, index.keyTail)\n          }\n        } : req;\n      }\n    \n      const result: DBCoreTable = {\n        ...table,\n        schema: {\n          ...schema,\n          primaryKey,\n          indexes: allVirtualIndexes,\n          getIndexByKeyPath: findBestIndex\n        },\n\n        count(req) {\n          return table.count(translateRequest(req));\n        },    \n    \n        query(req) {\n          return table.query(translateRequest(req));\n        },\n    \n        openCursor(req) {\n          const {keyTail, isVirtual, keyLength} = (req.query.index as VirtualIndex);\n          if (!isVirtual) return table.openCursor(req);\n    \n          function createVirtualCursor(cursor: DBCoreCursor) : DBCoreCursor {\n            function _continue (key?: any) {\n              key != null ?\n                cursor.continue(pad(key, req.reverse ? down.MAX_KEY : down.MIN_KEY, keyTail)) :\n                req.unique ?\n                  cursor.continue(\n                    cursor.key.slice(0, keyLength)\n                      .concat(req.reverse\n                        ? down.MIN_KEY\n                        : down.MAX_KEY, keyTail)\n                  ) :\n                  cursor.continue()\n            }\n            const virtualCursor = Object.create(cursor, {\n              continue: {value: _continue},\n              continuePrimaryKey: {\n                value(key: any, primaryKey: any) {\n                  cursor.continuePrimaryKey(pad(key, down.MAX_KEY, keyTail), primaryKey);\n                }\n              },\n              primaryKey: {\n                get() {\n                  return cursor.primaryKey;\n                }\n              },\n              key: {\n                get() {\n                  const key = cursor.key as any[]; // A virtual cursor always operates on compound key\n                  return keyLength === 1 ?\n                    key[0] : // Cursor.key should not be an array.\n                    key.slice(0, keyLength); // Cursor.key should be first part of array.\n                }\n              },\n              value: {\n                get() {\n                  return cursor.value;\n                }\n              }\n            });\n            return virtualCursor;\n          }\n    \n          return table.openCursor(translateRequest(req))\n            .then(cursor => cursor && createVirtualCursor(cursor));\n        }\n      };\n      return result;\n    }\n  }\n}\n\nexport const virtualIndexMiddleware : Middleware<DBCore> = {\n  stack: \"dbcore\",\n  name: \"VirtualIndexMiddleware\",\n  level: 1,\n  create: createVirtualIndexMiddleware\n};\n\n", "import { keys, hasOwn, toStringTag } from './utils';\n\nexport function getObjectDiff(a: any, b: any, rv?: any, prfx?: string) {\n  // Compares objects a and b and produces a diff object.\n  rv = rv || {};\n  prfx = prfx || '';\n  keys(a).forEach((prop) => {\n    if (!hasOwn(b, prop)) {\n      // Property removed\n      rv[prfx + prop] = undefined;\n    } else {\n      var ap = a[prop],\n        bp = b[prop];\n      if (typeof ap === 'object' && typeof bp === 'object' && ap && bp) {\n        const apTypeName = toStringTag(ap);\n        const bpTypeName = toStringTag(bp);\n\n        if (apTypeName !== bpTypeName) {\n          rv[prfx + prop] = b[prop]; // Property changed to other type\n        } else if (apTypeName === 'Object') {\n          // Pojo objects (not Date, ArrayBuffer, Array etc). Go deep.\n          getObjectDiff(ap, bp, rv, prfx + prop + '.');\n        } else if (ap !== bp) {\n          // Values differ.\n          // Could have checked if Date, arrays or binary types have same\n          // content here but I think that would be a suboptimation.\n          // Prefer simplicity.\n          rv[prfx + prop] = b[prop];\n        }\n      } else if (ap !== bp) rv[prfx + prop] = b[prop]; // Primitive value changed\n    }\n  });\n  keys(b).forEach((prop) => {\n    if (!hasOwn(a, prop)) {\n      rv[prfx + prop] = b[prop]; // Property added\n    }\n  });\n  return rv;\n}\n", "import {\n  DBCoreAddRequest,\n  DBCorePutRequest,\n  DBCoreDeleteRequest,\n  DBCoreIndex,\n  DBCoreTable,\n} from \"../public/types/dbcore\";\n\nexport function getEffectiveKeys (\n  primaryKey: DBCoreIndex,\n  req: (Pick<DBCoreAddRequest | DBCorePutRequest, \"type\" | \"values\"> & {keys?: any[]}) | Pick<DBCoreDeleteRequest, \"keys\" | \"type\">)\n{\n  //const {outbound} = primaryKey;\n  if (req.type === 'delete') return req.keys;\n  return req.keys || req.values.map(primaryKey.extractKey)\n}\n", "import {\n  DBCore,\n  DBCoreTable,\n  DBCoreMutateResponse,\n  DBCoreDeleteRangeRequest,\n  DBCoreAddRequest,\n  DBCorePutRequest,\n  DBCoreDeleteRequest,\n  DBCoreTransaction,\n  DBCoreKeyRange\n} from \"../public/types/dbcore\";\nimport { nop } from '../functions/chaining-functions';\nimport { hasOwn, setByKeyPath } from '../functions/utils';\nimport { getObjectDiff } from \"../functions/get-object-diff\";\nimport { PSD } from '../helpers/promise';\n//import { LockableTableMiddleware } from '../dbcore/lockable-table-middleware';\nimport { getEffectiveKeys } from '../dbcore/get-effective-keys';\nimport { Middleware } from '../public/types/middleware';\nimport { Transaction } from '../classes/transaction';\n\nexport const hooksMiddleware: Middleware<DBCore>  = {\n  stack: \"dbcore\",\n  name: \"HooksMiddleware\",\n  level: 2,\n  create: (downCore: DBCore) => ({\n    ...downCore,\n    table(tableName: string) {\n      const downTable = downCore.table(tableName);\n      const {primaryKey} = downTable.schema;\n  \n      const tableMiddleware: DBCoreTable = {\n        ...downTable,\n        mutate(req):Promise<DBCoreMutateResponse> {\n          const dxTrans = PSD.trans as Transaction;\n          // Hooks can be transaction-bound. Need to grab them from transaction.table and not\n          // db.table!\n          const {deleting, creating, updating} = dxTrans.table(tableName).hook;\n          switch (req.type) {\n            case 'add':\n              if (creating.fire === nop) break;\n              return dxTrans._promise('readwrite', ()=>addPutOrDelete(req), true);\n            case 'put':\n              if (creating.fire === nop && updating.fire === nop) break;\n              return dxTrans._promise('readwrite', ()=>addPutOrDelete(req), true);\n            case 'delete':\n              if (deleting.fire === nop) break;\n              return dxTrans._promise('readwrite', ()=>addPutOrDelete(req), true);\n            case 'deleteRange':\n              if (deleting.fire === nop) break;\n              return dxTrans._promise('readwrite', ()=>deleteRange(req), true);\n          }\n          // Any of the breaks above happened (no hooks) - do the default:\n          return downTable.mutate(req);\n\n\n          function addPutOrDelete(req: DBCoreAddRequest | DBCorePutRequest | DBCoreDeleteRequest): Promise<DBCoreMutateResponse> {\n            const dxTrans = PSD.trans;\n            const keys = req.keys || getEffectiveKeys(primaryKey, req);\n            if (!keys) throw new Error(\"Keys missing\");\n            // Clone Request and set keys arg\n            req = req.type === 'add' || req.type === 'put' ?\n              {...req, keys} :\n              {...req};\n            if (req.type !== 'delete') req.values = [...req.values];\n            if (req.keys) req.keys = [...req.keys];\n  \n            return getExistingValues(downTable, req, keys).then (existingValues => {\n              const contexts = keys.map((key, i) => {\n                const existingValue = existingValues[i];\n                const ctx = { onerror: null, onsuccess: null };\n                if (req.type === 'delete') {\n                  // delete operation\n                  deleting.fire.call(ctx, key, existingValue, dxTrans);\n                } else if (req.type === 'add' || existingValue === undefined) {\n                  // The add() or put() resulted in a create\n                  const generatedPrimaryKey = creating.fire.call(ctx, key, req.values[i], dxTrans);\n                  if (key == null && generatedPrimaryKey != null) {\n                    key = generatedPrimaryKey;\n                    req.keys[i] = key;\n                    if (!primaryKey.outbound) {\n                      setByKeyPath(req.values[i], primaryKey.keyPath, key);\n                    }\n                  }\n                } else {\n                  // The put() operation resulted in an update\n                  const objectDiff = getObjectDiff(existingValue, req.values[i]);\n                  const additionalChanges = updating.fire.call(ctx, objectDiff, key, existingValue, dxTrans);\n                  if (additionalChanges) {\n                    const requestedValue = req.values[i];\n                    Object.keys(additionalChanges).forEach(keyPath => {\n                      if (hasOwn(requestedValue, keyPath)) {\n                        // keyPath is already present as a literal property of the object\n                        requestedValue[keyPath] = additionalChanges[keyPath];\n                      } else {\n                        // keyPath represents a new or existing path into the object\n                        setByKeyPath(requestedValue, keyPath, additionalChanges[keyPath]);\n                      }\n                    });\n                  }\n                }\n                return ctx;\n              });\n              return downTable.mutate(req).then(({failures, results, numFailures, lastResult}) => {\n                for (let i=0; i<keys.length; ++i) {\n                  const primKey = results ? results[i] : keys[i];\n                  const ctx = contexts[i];\n                  if (primKey == null) {\n                    ctx.onerror && ctx.onerror(failures[i]);\n                  } else {\n                    ctx.onsuccess && ctx.onsuccess(\n                      req.type === 'put' && existingValues[i] ? // the put resulted in an update\n                        req.values[i] : // update hooks expects existing value\n                        primKey // create hooks expects primary key\n                    );\n                  }\n                }\n                return {failures, results, numFailures, lastResult};\n              }).catch(error => {\n                contexts.forEach(ctx => ctx.onerror && ctx.onerror(error));\n                return Promise.reject(error);\n              });\n            });\n          }\n  \n          function deleteRange(req: DBCoreDeleteRangeRequest): Promise<DBCoreMutateResponse> {\n            return deleteNextChunk(req.trans, req.range, 10000);\n          }\n  \n          function deleteNextChunk(trans: DBCoreTransaction, range: DBCoreKeyRange, limit: number) {\n            // Query what keys in the DB within the given range\n            return downTable.query({trans, values: false, query: {index: primaryKey, range}, limit})\n            .then(({result}) => {\n              // Given a set of keys, bulk delete those using the same procedure as in addPutOrDelete().\n              // This will make sure that deleting hook is called.\n              return addPutOrDelete({type: 'delete', keys: result, trans}).then(res => {\n                if (res.numFailures > 0) return Promise.reject(res.failures[0]);\n                if (result.length < limit) {\n                  return {failures: [], numFailures: 0, lastResult: undefined} as DBCoreMutateResponse;\n                } else {\n                  return deleteNextChunk(trans, {...range, lower: result[result.length - 1], lowerOpen: true}, limit);\n                }\n              });\n            })\n          }\n        }\n      };\n      //const {lock, lockableMiddleware} = LockableTableMiddleware(tableMiddleware);\n\n      return tableMiddleware;\n    },\n  }) as DBCore\n};\n\nfunction getExistingValues(\n  table: DBCoreTable,\n  req: DBCoreAddRequest | DBCorePutRequest | DBCoreDeleteRequest,\n  effectiveKeys: any[]\n) {\n  return req.type === \"add\"\n    ? Promise.resolve([])\n    : table.getMany({ trans: req.trans, keys: effectiveKeys, cache: \"immutable\" });\n}\n", "import { deepClone } from \"../functions/utils\";\nimport { DBCore } from \"../public/types/dbcore\";\nimport { Middleware } from \"../public/types/middleware\";\nimport Promise from \"../helpers/promise\";\nimport { cmp } from '../functions/cmp';\n\nexport function getFromTransactionCache(\n  keys: any[],\n  cache: { keys: any[]; values: any[] } | undefined | null,\n  clone?: boolean\n) {\n  try {\n    if (!cache) return null;\n    if (cache.keys.length < keys.length) return null;\n    const result: any[] = [];\n    // Compare if the exact same order of keys was retrieved in same transaction:\n    // Allow some cached keys to be omitted from provided set of keys\n    // Use case: 1. getMany(keys) 2. update a subset of those 3. call put with the updated ones ==> middlewares should be able to find old values\n    for (let i = 0, j = 0; i < cache.keys.length && j < keys.length; ++i) {\n      if (cmp(cache.keys[i], keys[j]) !== 0) continue;\n      result.push(clone ? deepClone(cache.values[i]) : cache.values[i]);\n      ++j;\n    }\n    // If got all keys caller was looking for, return result.\n    return result.length === keys.length ? result : null;\n  } catch {\n    return null;\n  }\n}\n\nexport const cacheExistingValuesMiddleware: Middleware<DBCore> = {\n  stack: \"dbcore\",\n  level: -1,\n  create: (core) => {\n    return {\n      table: (tableName) => {\n        const table = core.table(tableName);\n        return {\n          ...table,\n          getMany: (req) => {\n            if (!req.cache) {\n              return table.getMany(req);\n            }\n            const cachedResult = getFromTransactionCache(\n              req.keys,\n              req.trans[\"_cache\"],\n              req.cache === \"clone\"\n            );\n            if (cachedResult) {\n              return Promise.resolve(cachedResult);\n            }\n            return table.getMany(req).then((res) => {\n              req.trans[\"_cache\"] = {\n                keys: req.keys,\n                values: req.cache === \"clone\" ? deepClone(res) : res,\n              };\n              return res;\n            });\n          },\n          mutate: (req) => {\n            // Invalidate cache on any mutate except \"add\" which can't change existing values:\n            if (req.type !== \"add\") req.trans[\"_cache\"] = null;\n            return table.mutate(req);\n          },\n        };\n      },\n    };\n  },\n};\n", "import { cmp } from \"../functions/cmp\";\nimport { extend, iteratorSymbol, props } from '../functions/utils';\nimport { IndexableType } from '../public';\nimport {\n  EmptyRange,\n  IntervalTree,\n  IntervalTreeNode,\n  RangeSetConstructor,\n  RangeSetPrototype,\n} from \"../public/types/rangeset\";\n\n/* An interval tree implementation to efficiently detect overlapping ranges of queried indexes.\n *\n * https://en.wikipedia.org/wiki/Interval_tree\n * \n */\n\nfunction isEmptyRange(node: IntervalTree | {from: IndexableType, to: IndexableType}): node is EmptyRange {\n  return !(\"from\" in node);\n}\n\nexport type RangeSet = RangeSetPrototype & IntervalTree;\n\nexport const RangeSet = function(fromOrTree: any, to?: any) {\n  if (this) {\n    // Called with new()\n    extend(this, arguments.length ? {d:1, from: fromOrTree, to: arguments.length > 1 ? to : fromOrTree} : {d:0});\n  } else {\n    // Called without new()\n    const rv = new RangeSet();\n    if (fromOrTree && (\"d\" in fromOrTree)) {\n      extend(rv, fromOrTree);\n    }\n    return rv;\n  }\n} as RangeSetConstructor;\n\nprops(RangeSet.prototype, {\n  add(rangeSet: IntervalTree | {from: IndexableType, to: IndexableType}) {\n    mergeRanges(this, rangeSet);\n    return this;\n  },\n  addKey(key: IndexableType) {\n    addRange(this, key, key);\n    return this;\n  },\n  addKeys(keys: IndexableType[]) {\n    keys.forEach(key => addRange(this, key, key));\n    return this;\n  },\n\n  [iteratorSymbol](): Iterator<IntervalTreeNode, undefined, IndexableType | undefined> {\n    return getRangeSetIterator(this);\n  }\n});\n\nfunction addRange(target: IntervalTree, from: IndexableType, to: IndexableType) {\n  const diff = cmp(from, to);\n  // cmp() returns NaN if one of the args are IDB-invalid keys.\n  // Avoid storing invalid keys in rangeset:\n  if (isNaN(diff)) return;\n\n  // Caller is trying to add a range where from is greater than to:\n  if (diff > 0) throw RangeError();\n  \n  if (isEmptyRange(target)) return extend(target, { from, to, d: 1 });\n  const left = target.l;\n  const right = target.r;\n  if (cmp(to, target.from) < 0) {\n    left\n      ? addRange(left, from, to)\n      : (target.l = { from, to, d: 1, l: null, r: null });\n    return rebalance(target);\n  }\n  if (cmp(from, target.to) > 0) {\n    right\n      ? addRange(right, from, to)\n      : (target.r = { from, to, d: 1, l: null, r: null });\n    return rebalance(target);\n  }\n  // Now we have some kind of overlap. We will be able to merge the new range into the node or let it be swallowed.\n\n  // Grow left?\n  if (cmp(from, target.from) < 0) {\n    target.from = from;\n    target.l = null; // Cut off for now. Re-add later.\n    target.d = right ? right.d + 1 : 1;\n  }\n  // Grow right?\n  if (cmp(to, target.to) > 0) {\n    target.to = to;\n    target.r = null; // Cut off for now. Re-add later.\n    target.d = target.l ? target.l.d + 1 : 1;\n  }\n  const rightWasCutOff = !target.r;\n  // Re-add left?\n  if (left && !target.l) {\n    //Ranges to the left may be swallowed. Cut it of and re-add all.\n    //Could probably be done more efficiently!\n    mergeRanges(target, left);\n  }\n  // Re-add right?\n  if (right && rightWasCutOff) {\n    //Ranges to the right may be swallowed. Cut it of and re-add all.\n    //Could probably be done more efficiently!\n    mergeRanges(target, right);\n  }\n}\n\nexport function mergeRanges(target: IntervalTree, newSet: IntervalTree | {from: IndexableType, to: IndexableType}) {\n  function _addRangeSet(\n    target: IntervalTree,\n    { from, to, l, r }: IntervalTreeNode | {from: IndexableType, to: IndexableType, l?: undefined, r?: undefined}\n  ) {\n    addRange(target, from, to);\n    if (l) _addRangeSet(target, l);\n    if (r) _addRangeSet(target, r);\n  }\n\n  if(!isEmptyRange(newSet)) _addRangeSet(target, newSet);\n}\n\nexport function rangesOverlap(\n  rangeSet1: IntervalTree,\n  rangeSet2: IntervalTree\n): boolean {\n    // Start iterating other from scratch.\n    const i1 = getRangeSetIterator(rangeSet2);\n    let nextResult1 = i1.next();\n    if (nextResult1.done) return false;\n    let a = nextResult1.value;\n\n    // Start iterating this from start of other\n    const i2 = getRangeSetIterator(rangeSet1);\n    let nextResult2 = i2.next(a.from); // Start from beginning of other range\n    let b = nextResult2.value;\n\n    while (!nextResult1.done && !nextResult2.done) {\n      if (cmp(b!.from, a.to) <= 0 && cmp(b!.to, a.from) >= 0) return true;\n      cmp(a.from, b!.from) < 0\n        ? (a = (nextResult1 = i1.next(b!.from)).value!) // a is behind. forward it to beginning of next b-range\n        : (b = (nextResult2 = i2.next(a.from)).value); // b is behind. forward it to beginning of next a-range\n    }\n  return false;\n}\n\ntype RangeSetIteratorState =\n  | {\n      up?: RangeSetIteratorState;\n      n: IntervalTreeNode;\n      s: 0 | 1 | 2 | 3;\n    }\n  | undefined\n  | null;\nexport function getRangeSetIterator(\n  node: EmptyRange | IntervalTreeNode\n): Generator<IntervalTreeNode, undefined, IndexableType | undefined> {\n  let state: RangeSetIteratorState = isEmptyRange(node) ? null : { s: 0, n: node };\n\n  return {\n    next(key?) {\n      const keyProvided = arguments.length > 0;\n      while (state) {\n        switch (state.s) {\n          case 0:\n            // Initial state for node.\n            // Fast forward to leftmost node.\n            state.s = 1;\n            if (keyProvided) {\n              while (state.n.l && cmp(key, state.n.from) < 0)\n                state = { up: state, n: state.n.l, s: 1 };\n            } else {\n              while (state.n.l) state = { up: state, n: state.n.l, s: 1 };\n            }\n          // intentionally fall into case 1:\n          case 1:\n            // We're on a node where it's left part is already handled or does not exist.\n            state.s = 2;\n            if (!keyProvided || cmp(key, state.n.to) <= 0)\n              return { value: state.n, done: false };\n          case 2:\n            // We've emitted our node and should continue with the right part or let parent take over from it's state 1\n            if (state.n.r) {\n              state.s = 3; // So when child is done, we know we're done.\n              state = { up: state, n: state.n.r, s: 0 };\n              continue; // Will fall in to case 0 with fast forward to left leaf of this subtree.\n            }\n          // intentionally fall into case 3:\n          case 3:\n            state = state.up;\n        }\n      }\n      return { done: true };\n    },\n  } as Generator<IntervalTreeNode, undefined, IndexableType>;\n}\n\nfunction rebalance(target: IntervalTreeNode) {\n  const diff = (target.r?.d || 0) - (target.l?.d || 0);\n  const r = diff > 1 ? \"r\" : diff < -1 ? \"l\" : \"\";\n  if (r) {\n\n    // Rotate (https://en.wikipedia.org/wiki/Tree_rotation)\n    //\n    // \n    //                    [OLDROOT]\n    //       [OLDROOT.L]            [NEWROOT]\n    //                        [NEWROOT.L] [NEWROOT.R]\n    //\n    // Is going to become:\n    //\n    // \n    //                    [NEWROOT]\n    //        [OLDROOT]             [NEWROOT.R]\n    // [OLDROOT.L] [NEWROOT.L]  \n\n    // * clone now has the props of OLDROOT\n    // Plan:\n    // * target must be given the props of NEWROOT\n    // * target[l] must point to a new OLDROOT\n    // * target[r] must point to NEWROOT.R\n    // * OLDROOT[r] must point to NEWROOT.L\n    const l = r === \"r\" ? \"l\" : \"r\"; // Support both left/right rotation\n    const rootClone = { ...target };\n    // We're gonna copy props from target's right node into target so that target will\n    // have same range as old target[r] (instead of changing pointers, we copy values.\n    // that way we do not need to adjust pointers in parents).\n    const oldRootRight = target[r]; \n    target.from = oldRootRight.from;\n    target.to = oldRootRight.to;\n    target[r] = oldRootRight[r];\n    rootClone[r] = oldRootRight[l];\n    target[l] = rootClone;\n    rootClone.d = computeDepth(rootClone);\n  }\n  target.d = computeDepth(target);\n}\n\nfunction computeDepth({ r, l }: Pick<IntervalTreeNode, \"l\" | \"r\">) {\n  return (r ? (l ? Math.max(r.d, l.d) : r.d) : l ? l.d : 0) + 1;\n}\n", "import { getFromTransactionCache } from \"../dbcore/cache-existing-values-middleware\";\nimport { cmp } from \"../functions/cmp\";\nimport { isArray, keys } from \"../functions/utils\";\nimport { PSD } from \"../helpers/promise\";\nimport { RangeSet } from \"../helpers/rangeset\";\nimport { ObservabilitySet } from \"../public/types/db-events\";\nimport {\n  DBCore,\n  DBCoreCountRequest,\n  DBCoreCursor,\n  DBCoreGetManyRequest,\n  DBCoreGetRequest,\n  DBCoreIndex,\n  DBCoreOpenCursorRequest,\n  DBCoreQueryRequest,\n  DBCoreQueryResponse,\n  DBCoreTable,\n  DBCoreTableSchema,\n  DBCoreTransaction,\n} from \"../public/types/dbcore\";\nimport { Middleware } from \"../public/types/middleware\";\n\nexport const observabilityMiddleware: Middleware<DBCore> = {\n  stack: \"dbcore\",\n  level: 0,\n  create: (core) => {\n    const dbName = core.schema.name;\n    const FULL_RANGE = new RangeSet(core.MIN_KEY, core.MAX_KEY);\n\n    return {\n      ...core,\n      table: (tableName) => {\n        const table = core.table(tableName);\n        const { schema } = table;\n        const { primaryKey } = schema;\n        const { extractKey, outbound } = primaryKey;\n        const tableClone: DBCoreTable = {\n          ...table,\n          mutate: (req) => {\n            const trans = req.trans as DBCoreTransaction & {\n              mutatedParts?: ObservabilitySet;\n            };\n            const mutatedParts =\n              trans.mutatedParts || (trans.mutatedParts = {});\n            const getRangeSet = (indexName: string) => {\n              const part = `idb://${dbName}/${tableName}/${indexName}`;\n              return (mutatedParts[part] ||\n                (mutatedParts[part] = new RangeSet())) as RangeSet;\n            };\n            const pkRangeSet = getRangeSet(\"\");\n            const delsRangeSet = getRangeSet(\":dels\");\n\n            const { type } = req;\n            let [keys, newObjs] =\n              req.type === \"deleteRange\"\n                ? [req.range] // keys will be an DBCoreKeyRange object - transformed later on to a [from,to]-style range.\n                : req.type === \"delete\"\n                ? [req.keys] // keys known already here. newObjs will be undefined.\n                : req.values.length < 50\n                ? [[], req.values] // keys = empty array - will be resolved in mutate().then(...).\n                : []; // keys and newObjs will both be undefined - changeSpec will become true (changed for entire table)\n            const oldCache = req.trans[\"_cache\"];\n            return table.mutate(req).then((res) => {\n              // Add the mutated table and optionally keys to the mutatedTables set on the transaction.\n              // Used by subscribers to txcommit event and for Collection.prototype.subscribe().\n              if (isArray(keys)) {\n                // keys is an array - delete, add or put of less than 50 rows.\n                if (type !== \"delete\") keys = res.results;\n                // individual keys (add put or delete)\n                pkRangeSet.addKeys(keys);\n                // Only get oldObjs if they have been cached recently\n                // (This applies to Collection.modify() only, but also if updating/deleting hooks have subscribers)\n                const oldObjs = getFromTransactionCache(keys, oldCache);\n\n                // Supply detailed values per index for both old and new objects:\n                if (!oldObjs && type !== \"add\") {\n                  // delete or put and we don't know old values.\n                  // Indicate this in the \":dels\" part, for the sake of count() queries only!\n                  delsRangeSet.addKeys(keys);\n                }\n                if (oldObjs || newObjs) {\n                  // No matter if knowning oldObjs or not, track the indices if it's a put, add or delete.\n                  trackAffectedIndexes(getRangeSet, schema, oldObjs, newObjs);\n                }\n              } else if (keys) {\n                // As we can't know deleted index ranges, mark index-based subscriptions must trigger.\n                const range = { from: keys.lower, to: keys.upper };\n                delsRangeSet.add(range);\n                // deleteRange. keys is a DBCoreKeyRange objects. Transform it to [from,to]-style range.\n                pkRangeSet.add(range);\n              } else {\n                // Too many requests to record the details without slowing down write performance.\n                // Let's just record a generic large range on primary key, the virtual :dels index and\n                // all secondary indices:\n                pkRangeSet.add(FULL_RANGE);\n                delsRangeSet.add(FULL_RANGE);\n                schema.indexes.forEach(idx => getRangeSet(idx.name).add(FULL_RANGE));\n              }\n              return res;\n            });\n          },\n        };\n\n        const getRange: (req: any) => [DBCoreIndex, RangeSet] = ({\n          query: { index, range },\n        }:\n          | DBCoreQueryRequest\n          | DBCoreCountRequest\n          | DBCoreOpenCursorRequest) => [\n          index,\n          new RangeSet(range.lower ?? core.MIN_KEY, range.upper ?? core.MAX_KEY),\n        ];\n\n        const readSubscribers: {[method in\n          Exclude<keyof DBCoreTable, \"name\" | \"schema\" | \"mutate\">]: \n          (req: any) => [DBCoreIndex, RangeSet]\n        } = {\n          get: (req) => [primaryKey, new RangeSet(req.key)],\n          getMany: (req) => [primaryKey, new RangeSet().addKeys(req.keys)],\n          count: getRange,\n          query: getRange,\n          openCursor: getRange,\n        }\n\n        keys(readSubscribers).forEach(method => {\n          tableClone[method] = function (\n            req:\n              | DBCoreGetRequest\n              | DBCoreGetManyRequest\n              | DBCoreQueryRequest\n              | DBCoreCountRequest\n              | DBCoreOpenCursorRequest\n          ) {\n            const { subscr } = PSD;\n            if (subscr) {\n              // Current zone want's to track all queries so they can be subscribed to.\n              // (The query is executed within a \"liveQuery\" zone)\n              // Check whether the query applies to a certain set of ranges:\n              // Track what we should be observing:\n              const getRangeSet = (indexName: string) => {\n                const part = `idb://${dbName}/${tableName}/${indexName}`;\n                return (subscr[part] ||\n                  (subscr[part] = new RangeSet())) as RangeSet;\n              };\n              const pkRangeSet = getRangeSet(\"\");\n              const delsRangeSet = getRangeSet(\":dels\");\n              const [queriedIndex, queriedRanges] = readSubscribers[method](req);\n              // A generic rule here: queried ranges should always be subscribed to.\n              getRangeSet(queriedIndex.name || \"\").add(queriedRanges);\n              if (!queriedIndex.isPrimaryKey) {\n                // Only count(), query() and openCursor() operates on secondary indices.\n                // Since put(), delete() and deleteRange() mutations may happen without knowing oldObjs,\n                // the mutate() method will be missing what secondary indices that are being deleted from\n                // the subscribed range. We are working around this issue by recording all the resulting\n                // primary keys from the queries. This only works for those kinds of queries where we can\n                // derive the primary key from the result.\n                // In this block we are accomplishing this using various strategies depending on the properties\n                // of the query result.\n\n                if (method === \"count\") {\n                  // We've got a problem! Delete and put mutations happen without known the oldObjs.\n                  // Those mutation could change the count.\n                  // Solution: Dedicated \":dels\" url represends a subscription to all mutations without oldObjs\n                  // (specially triggered in the mutators put(), delete() and deleteRange() when they don't know oldObject)\n                  delsRangeSet.add(FULL_RANGE);\n                } else {\n                  // openCursor() or query()\n\n                  // Prepare a keysPromise in case the we're doing an IDBIndex.getAll() on a store with outbound keys.\n                  const keysPromise =\n                    method === \"query\" &&\n                    outbound &&\n                    (req as DBCoreQueryRequest).values &&\n                    table.query({\n                      ...(req as DBCoreQueryRequest),\n                      values: false,\n                    });\n\n                  return table[method].apply(this, arguments).then((res) => {\n                    if (method === \"query\") {\n                      if (outbound && (req as DBCoreQueryRequest).values) {\n                        // If keys are outbound, we can't use extractKey to map what keys to observe.\n                        // We've queried an index (like 'dateTime') on an outbound table\n                        // and retrieve a list of objects\n                        // from who we cannot know their primary keys.\n                        // \"Luckily\" though, we've prepared the keysPromise to assist us in exact this condition.\n                        return keysPromise.then(\n                          ({ result: resultingKeys }: DBCoreQueryResponse) => {\n                            pkRangeSet.addKeys(resultingKeys);\n                            return res;\n                          }\n                        );\n                      }\n                      // query() inbound values, keys or outbound keys. Secondary indexes only since\n                      // for primary keys we would only add results within the already registered range.\n                      const pKeys = (req as DBCoreQueryRequest).values\n                        ? (res as DBCoreQueryResponse).result.map(extractKey)\n                        : (res as DBCoreQueryResponse).result;\n                      if ((req as DBCoreQueryRequest).values) {\n                        // Subscribe to any mutation made on the returned keys,\n                        // so that we detect both deletions and updated properties.\n                        pkRangeSet.addKeys(pKeys);\n                      } else {\n                        // Subscribe only to mutations on the returned keys\n                        // in case the mutator was unable to know oldObjs.\n                        // If it has oldObj, the mutator won't put anything in \":dels\" because\n                        // it can more fine-grained put the exact removed and added index value in the correct\n                        // index range that we subscribe to in the queried range sets.\n                        // We don't load values so a change on a property outside our index will not\n                        // require us to re-execute the query.\n                        delsRangeSet.addKeys(pKeys);\n                      }\n                    } else if (method === \"openCursor\") {\n                      // Caller requests a cursor.\n                      // For the same reason as when method===\"query\", we only need to observe\n                      // those keys whose values are possibly used or rendered - which could\n                      // only happen on keys where they get the cursor's key, primaryKey or value.\n                      const cursor: DBCoreCursor | null = res;\n                      const wantValues = (req as DBCoreOpenCursorRequest).values;\n                      return (\n                        cursor &&\n                        Object.create(cursor, {\n                          key: {\n                            get() {\n                              delsRangeSet.addKey(cursor.primaryKey);\n                              return cursor.key;\n                            },\n                          },\n                          primaryKey: {\n                            get() {\n                              const pkey = cursor.primaryKey;\n                              delsRangeSet.addKey(pkey);\n                              return pkey;\n                            },\n                          },\n                          value: {\n                            get() {\n                              wantValues && pkRangeSet.addKey(cursor.primaryKey);\n                              return cursor.value;\n                            },\n                          },\n                        })\n                      );\n                    }\n                    return res;\n                  });\n                }\n              }\n            }\n            return table[method].apply(this, arguments);\n          };\n        });\n        return tableClone;\n      },\n    };\n  },\n};\n\nfunction trackAffectedIndexes(\n  getRangeSet: (index: string) => RangeSet,\n  schema: DBCoreTableSchema,\n  oldObjs: any[] | undefined,\n  newObjs: any[] | undefined\n) {\n  function addAffectedIndex(ix: DBCoreIndex) {\n    const rangeSet = getRangeSet(ix.name || \"\");\n    function extractKey(obj: any) {\n      return obj != null ? ix.extractKey(obj) : null;\n    }\n    const addKeyOrKeys = (key: any) => ix.multiEntry && isArray(key)\n      // multiEntry and the old property was an array - add each array entry to the rangeSet:\n      ? key.forEach(key => rangeSet.addKey(key))\n      // Not multiEntry or the old property was not an array - add each array entry to the rangeSet:\n      : rangeSet.addKey(key);\n\n    (oldObjs || newObjs).forEach((_, i) => {\n      const oldKey = oldObjs && extractKey(oldObjs[i]);\n      const newKey = newObjs && extractKey(newObjs[i]);\n      if (cmp(oldKey, newKey) !== 0) {\n        // The index has changed. Add both old and new value of the index.\n        if (oldKey != null) addKeyOrKeys(oldKey); // If oldKey is invalid key, addKey() will be a noop.\n        if (newKey != null) addKeyOrKeys(newKey); // If newKey is invalid key, addKey() will be a noop.\n      }\n    });\n  }\n  schema.indexes.forEach(addAffectedIndex);\n}\n", "// Import types from the public API\nimport { Dexie as IDexie } from \"../../public/types/dexie\";\nimport { DexieOptions, DexieConstructor } from \"../../public/types/dexie-constructor\";\nimport { DbEvents } from \"../../public/types/db-events\";\n//import { PromiseExtended, PromiseExtendedConstructor } from '../../public/types/promise-extended';\nimport { Table as ITable } from '../../public/types/table';\nimport { TableSchema } from \"../../public/types/table-schema\";\nimport { DbSchema } from '../../public/types/db-schema';\n\n// Internal imports\nimport { Table, TableConstructor, createTableConstructor } from \"../table\";\nimport { Collection, CollectionConstructor, createCollectionConstructor } from '../collection';\nimport { WhereClause } from '../where-clause/where-clause';\nimport { WhereClauseConstructor, createWhereClauseConstructor } from '../where-clause/where-clause-constructor';\nimport { Transaction } from '../transaction';\nimport { TransactionConstructor, createTransactionConstructor } from '../transaction/transaction-constructor';\nimport { Version } from \"../version/version\";\nimport { VersionConstructor, createVersionConstructor } from '../version/version-constructor';\n\n// Other imports...\nimport { DexieEventSet } from '../../public/types/dexie-event-set';\nimport { DexieExceptionClasses } from '../../public/types/errors';\nimport { DexieDOMDependencies } from '../../public/types/dexie-dom-dependencies';\nimport { nop, promisableChain } from '../../functions/chaining-functions';\nimport Promise, { PSD } from '../../helpers/promise';\nimport { extend, override, keys, hasOwn } from '../../functions/utils';\nimport Events from '../../helpers/Events';\nimport { maxString, connections, READONLY, READWRITE } from '../../globals/constants';\nimport { getMaxKey } from '../../functions/quirks';\nimport { exceptions } from '../../errors';\nimport { lowerVersionFirst } from '../version/schema-helpers';\nimport { dexieOpen } from './dexie-open';\nimport { wrap } from '../../helpers/promise';\nimport { _onDatabaseDeleted } from '../../helpers/database-enumerator';\nimport { eventRejectHandler } from '../../functions/event-wrappers';\nimport { extractTransactionArgs, enterTransactionScope } from './transaction-helpers';\nimport { TransactionMode } from '../../public/types/transaction-mode';\nimport { rejection } from '../../helpers/promise';\nimport { usePSD } from '../../helpers/promise';\nimport { DBCore } from '../../public/types/dbcore';\nimport { Middleware, DexieStacks } from '../../public/types/middleware';\nimport { virtualIndexMiddleware } from '../../dbcore/virtual-index-middleware';\nimport { hooksMiddleware } from '../../hooks/hooks-middleware';\nimport { IndexableType } from '../../public';\nimport { observabilityMiddleware } from '../../live-query/observability-middleware';\nimport { cacheExistingValuesMiddleware } from '../../dbcore/cache-existing-values-middleware';\n\nexport interface DbReadyState {\n  dbOpenError: any;\n  isBeingOpened: boolean;\n  onReadyBeingFired: undefined | Function[];\n  openComplete: boolean;\n  dbReadyResolve: () => void;\n  dbReadyPromise: Promise<any>;\n  cancelOpen: (reason?: Error) => void;\n  openCanceller: Promise<any> & { _stackHolder?: Error };\n  autoSchema: boolean;\n  vcFired?: boolean;\n  PR1398_maxLoop?: number;\n}\n\nexport class Dexie implements IDexie {\n  _options: DexieOptions;\n  _state: DbReadyState;\n  _versions: Version[];\n  _storeNames: string[];\n  _deps: DexieDOMDependencies;\n  _allTables: { [name: string]: Table; };\n  _createTransaction: (this: Dexie, mode: IDBTransactionMode, storeNames: ArrayLike<string>, dbschema: { [tableName: string]: TableSchema; }, parentTransaction?: Transaction) => Transaction;\n  _dbSchema: { [tableName: string]: TableSchema; };\n  _hasGetAll?: boolean;\n  _maxKey: IndexableType;\n  _fireOnBlocked: (ev: Event) => void;\n  _middlewares: {[StackName in keyof DexieStacks]?: Middleware<DexieStacks[StackName]>[]} = {};\n  _vip?: boolean;\n  _novip?: Dexie;// db._novip is to escape to orig db from db.vip.\n  core: DBCore;\n\n  name: string;\n  verno: number = 0;\n  idbdb: IDBDatabase | null;\n  vip: Dexie;\n  on: DbEvents;\n\n  Table: TableConstructor;\n  WhereClause: WhereClauseConstructor;\n  Collection: CollectionConstructor;\n  Version: VersionConstructor;\n  Transaction: TransactionConstructor;\n\n  constructor(name: string, options?: DexieOptions) {\n    const deps = (Dexie as any as DexieConstructor).dependencies;\n    this._options = options = {\n      // Default Options\n      addons: (Dexie as any as DexieConstructor).addons, // Pick statically registered addons by default\n      autoOpen: true,                 // Don't require db.open() explicitely.\n      // Default DOM dependency implementations from static prop.\n      indexedDB: deps.indexedDB,      // Backend IndexedDB api. Default to browser env.\n      IDBKeyRange: deps.IDBKeyRange,  // Backend IDBKeyRange api. Default to browser env.\n      ...options\n    };\n    this._deps = {\n      indexedDB: options.indexedDB as IDBFactory,\n      IDBKeyRange: options.IDBKeyRange as typeof IDBKeyRange\n    };\n    const {\n      addons,\n    } = options;\n    this._dbSchema = {};\n    this._versions = [];\n    this._storeNames = [];\n    this._allTables = {};\n    this.idbdb = null;\n    this._novip = this;\n    const state: DbReadyState = {\n      dbOpenError: null,\n      isBeingOpened: false,\n      onReadyBeingFired: null,\n      openComplete: false,\n      dbReadyResolve: nop,\n      dbReadyPromise: null as Promise,\n      cancelOpen: nop,\n      openCanceller: null as Promise,\n      autoSchema: true,\n      PR1398_maxLoop: 3\n    };\n    state.dbReadyPromise = new Promise(resolve => {\n      state.dbReadyResolve = resolve;\n    });\n    state.openCanceller = new Promise((_, reject) => {\n      state.cancelOpen = reject;\n    });\n    this._state = state;\n    this.name = name;\n    this.on = Events(this, \"populate\", \"blocked\", \"versionchange\", \"close\", { ready: [promisableChain, nop] }) as DbEvents;\n    this.on.ready.subscribe = override(this.on.ready.subscribe, subscribe => {\n      return (subscriber, bSticky) => {\n        (Dexie as any as DexieConstructor).vip(() => {\n          const state = this._state;\n          if (state.openComplete) {\n            // Database already open. Call subscriber asap.\n            if (!state.dbOpenError) Promise.resolve().then(subscriber);\n            // bSticky: Also subscribe to future open sucesses (after close / reopen) \n            if (bSticky) subscribe(subscriber);\n          } else if (state.onReadyBeingFired) {\n            // db.on('ready') subscribers are currently being executed and have not yet resolved or rejected\n            state.onReadyBeingFired.push(subscriber);\n            if (bSticky) subscribe(subscriber);\n          } else {\n            // Database not yet open. Subscribe to it.\n            subscribe(subscriber);\n            // If bSticky is falsy, make sure to unsubscribe subscriber when fired once.\n            const db = this;\n            if (!bSticky) subscribe(function unsubscribe() {\n              db.on.ready.unsubscribe(subscriber);\n              db.on.ready.unsubscribe(unsubscribe);\n            });\n          }\n        });\n      }\n    });\n\n    // Create derived classes bound to this instance of Dexie:\n    this.Collection = createCollectionConstructor(this);\n    this.Table = createTableConstructor(this);\n    this.Transaction = createTransactionConstructor(this);\n    this.Version = createVersionConstructor(this);\n    this.WhereClause = createWhereClauseConstructor(this);\n\n    // Default subscribers to \"versionchange\" and \"blocked\".\n    // Can be overridden by custom handlers. If custom handlers return false, these default\n    // behaviours will be prevented.\n    this.on(\"versionchange\", ev => {\n      // Default behavior for versionchange event is to close database connection.\n      // Caller can override this behavior by doing db.on(\"versionchange\", function(){ return false; });\n      // Let's not block the other window from making it's delete() or open() call.\n      // NOTE! This event is never fired in IE,Edge or Safari.\n      if (ev.newVersion > 0)\n        console.warn(`Another connection wants to upgrade database '${this.name}'. Closing db now to resume the upgrade.`);\n      else\n        console.warn(`Another connection wants to delete database '${this.name}'. Closing db now to resume the delete request.`);\n      this.close();\n      // In many web applications, it would be recommended to force window.reload()\n      // when this event occurs. To do that, subscribe to the versionchange event\n      // and call window.location.reload(true) if ev.newVersion > 0 (not a deletion)\n      // The reason for this is that your current web app obviously has old schema code that needs\n      // to be updated. Another window got a newer version of the app and needs to upgrade DB but\n      // your window is blocking it unless we close it here.\n    });\n    this.on(\"blocked\", ev => {\n      if (!ev.newVersion || ev.newVersion < ev.oldVersion)\n        console.warn(`Dexie.delete('${this.name}') was blocked`);\n      else\n        console.warn(`Upgrade '${this.name}' blocked by other connection holding version ${ev.oldVersion / 10}`);\n    });\n\n    this._maxKey = getMaxKey(options.IDBKeyRange as typeof IDBKeyRange);\n\n    this._createTransaction = (\n      mode: IDBTransactionMode,\n      storeNames: string[],\n      dbschema: DbSchema,\n      parentTransaction?: Transaction) => new this.Transaction(mode, storeNames, dbschema, this._options.chromeTransactionDurability, parentTransaction);\n\n    this._fireOnBlocked = ev => {\n      this.on(\"blocked\").fire(ev);\n      // Workaround (not fully*) for missing \"versionchange\" event in IE,Edge and Safari:\n      connections\n        .filter(c => c.name === this.name && c !== this && !c._state.vcFired)\n        .map(c => c.on(\"versionchange\").fire(ev));\n    }\n\n    // Default middlewares:\n    this.use(virtualIndexMiddleware);\n    this.use(hooksMiddleware);\n    this.use(observabilityMiddleware);\n    this.use(cacheExistingValuesMiddleware);\n\n    this.vip = Object.create(this, {_vip: {value: true}}) as Dexie;\n\n    // Call each addon:\n    addons.forEach(addon => addon(this));\n  }\n\n  version(versionNumber: number): Version {\n    if (isNaN(versionNumber) || versionNumber < 0.1) throw new exceptions.Type(`Given version is not a positive number`);\n    versionNumber = Math.round(versionNumber * 10) / 10;\n    if (this.idbdb || this._state.isBeingOpened)\n      throw new exceptions.Schema(\"Cannot add version when database is open\");\n    this.verno = Math.max(this.verno, versionNumber);\n    const versions = this._versions;\n    var versionInstance = versions.filter(\n      v => v._cfg.version === versionNumber)[0];\n    if (versionInstance) return versionInstance;\n    versionInstance = new this.Version(versionNumber);\n    versions.push(versionInstance);\n    versions.sort(lowerVersionFirst);\n    versionInstance.stores({}); // Derive earlier schemas by default.\n    // Disable autoschema mode, as at least one version is specified.\n    this._state.autoSchema = false;\n    return versionInstance;\n  }\n\n  _whenReady<T>(fn: () => Promise<T>): Promise<T> {\n    return (this.idbdb && (this._state.openComplete || PSD.letThrough || this._vip)) ? fn() : new Promise<T>((resolve, reject) => {\n      if (this._state.openComplete) {\n        // idbdb is falsy but openComplete is true. Must have been an exception durin open.\n        // Don't wait for openComplete as it would lead to infinite loop.\n        return reject(new exceptions.DatabaseClosed(this._state.dbOpenError));\n      }\n      if (!this._state.isBeingOpened) {\n        if (!this._options.autoOpen) {\n          reject(new exceptions.DatabaseClosed());\n          return;\n        }\n        this.open().catch(nop); // Open in background. If if fails, it will be catched by the final promise anyway.\n      }\n      this._state.dbReadyPromise.then(resolve, reject);\n    }).then(fn);\n  }\n\n  use({stack, create, level, name}: Middleware<DBCore>): this {\n    if (name) this.unuse({stack, name}); // Be able to replace existing middleware.\n    const middlewares = this._middlewares[stack] || (this._middlewares[stack] = []);\n    middlewares.push({stack, create, level: level == null ? 10 : level, name});\n    middlewares.sort((a, b) => a.level - b.level);\n    // Todo update db.core and db.tables...core ? Or should be expect this to have effect\n    // only after next open()?\n    return this;\n  }\n\n  unuse({stack, create}: Middleware<{stack: keyof DexieStacks}>): this;\n  unuse({stack, name}: {stack: keyof DexieStacks, name: string}): this;\n  unuse({stack, name, create}: {stack: keyof DexieStacks, name?: string, create?: Function}) {\n    if (stack && this._middlewares[stack]) {\n      this._middlewares[stack] = this._middlewares[stack].filter(mw =>\n        create ? mw.create !== create : // Given middleware has a create method. Match that exactly.\n        name ? mw.name !== name : // Given middleware spec \n        false);\n    }\n    return this;\n  }\n\n  open() {\n    return dexieOpen(this);\n  }\n\n  _close(): void {\n    const state = this._state;\n    const idx = connections.indexOf(this);\n    if (idx >= 0) connections.splice(idx, 1);\n    if (this.idbdb) {\n      try { this.idbdb.close(); } catch (e) { }\n      this._novip.idbdb = null; // db._novip is because db can be an Object.create(origDb).\n    }    \n    // Reset dbReadyPromise promise:\n    state.dbReadyPromise = new Promise(resolve => {\n      state.dbReadyResolve = resolve;\n    });\n    state.openCanceller = new Promise((_, reject) => {\n      state.cancelOpen = reject;\n    });\n  }\n\n  close(): void {\n    this._close();\n    const state = this._state;\n    this._options.autoOpen = false;\n    state.dbOpenError = new exceptions.DatabaseClosed();\n    if (state.isBeingOpened)\n      state.cancelOpen(state.dbOpenError);\n  }\n\n  delete(): Promise<void> {\n    const hasArguments = arguments.length > 0;\n    const state = this._state;\n    return new Promise((resolve, reject) => {\n      const doDelete = () => {\n        this.close();\n        var req = this._deps.indexedDB.deleteDatabase(this.name);\n        req.onsuccess = wrap(() => {\n          _onDatabaseDeleted(this._deps, this.name);\n          resolve();\n        });\n        req.onerror = eventRejectHandler(reject);\n        req.onblocked = this._fireOnBlocked;\n      }\n\n      if (hasArguments) throw new exceptions.InvalidArgument(\"Arguments not allowed in db.delete()\");\n      if (state.isBeingOpened) {\n        state.dbReadyPromise.then(doDelete);\n      } else {\n        doDelete();\n      }\n    });\n  }\n\n  backendDB() {\n    return this.idbdb;\n  }\n\n  isOpen() {\n    return this.idbdb !== null;\n  }\n\n  hasBeenClosed() {\n    const dbOpenError = this._state.dbOpenError;\n    return dbOpenError && (dbOpenError.name === 'DatabaseClosed');\n  }\n\n  hasFailed() {\n    return this._state.dbOpenError !== null;\n  }\n\n  dynamicallyOpened() {\n    return this._state.autoSchema;\n  }\n\n  get tables () {\n    return keys(this._allTables).map(name => this._allTables[name]);\n  }\n\n  transaction(): Promise {\n    const args = extractTransactionArgs.apply(this, arguments);\n    return this._transaction.apply(this, args);\n  }\n\n  _transaction(mode: TransactionMode, tables: Array<ITable | string>, scopeFunc: Function) {\n    let parentTransaction = PSD.trans as Transaction | undefined;\n    // Check if parent transactions is bound to this db instance, and if caller wants to reuse it\n    if (!parentTransaction || parentTransaction.db !== this || mode.indexOf('!') !== -1) parentTransaction = null;\n    const onlyIfCompatible = mode.indexOf('?') !== -1;\n    mode = mode.replace('!', '').replace('?', '') as TransactionMode; // Ok. Will change arguments[0] as well but we wont touch arguments henceforth.\n    let idbMode: IDBTransactionMode,\n        storeNames;\n\n    try {\n        //\n        // Get storeNames from arguments. Either through given table instances, or through given table names.\n        //\n        storeNames = tables.map(table => {\n            var storeName = table instanceof this.Table ? table.name : table;\n            if (typeof storeName !== 'string') throw new TypeError(\"Invalid table argument to Dexie.transaction(). Only Table or String are allowed\");\n            return storeName;\n        });\n\n        //\n        // Resolve mode. Allow shortcuts \"r\" and \"rw\".\n        //\n        if (mode == \"r\" || mode === READONLY)\n          idbMode = READONLY;\n        else if (mode == \"rw\" || mode == READWRITE)\n          idbMode = READWRITE;\n        else\n            throw new exceptions.InvalidArgument(\"Invalid transaction mode: \" + mode);\n\n        if (parentTransaction) {\n            // Basic checks\n            if (parentTransaction.mode === READONLY && idbMode === READWRITE) {\n                if (onlyIfCompatible) {\n                    // Spawn new transaction instead.\n                    parentTransaction = null; \n                }\n                else throw new exceptions.SubTransaction(\"Cannot enter a sub-transaction with READWRITE mode when parent transaction is READONLY\");\n            }\n            if (parentTransaction) {\n                storeNames.forEach(storeName => {\n                    if (parentTransaction && parentTransaction.storeNames.indexOf(storeName) === -1) {\n                        if (onlyIfCompatible) {\n                            // Spawn new transaction instead.\n                            parentTransaction = null; \n                        }\n                        else throw new exceptions.SubTransaction(\"Table \" + storeName +\n                            \" not included in parent transaction.\");\n                    }\n                });\n            }\n            if (onlyIfCompatible && parentTransaction && !parentTransaction.active) {\n                // '?' mode should not keep using an inactive transaction.\n                parentTransaction = null;\n            }\n        }\n    } catch (e) {\n        return parentTransaction ?\n            parentTransaction._promise(null, (_, reject) => {reject(e);}) :\n            rejection (e);\n    }\n    // If this is a sub-transaction, lock the parent and then launch the sub-transaction.\n    const enterTransaction = enterTransactionScope.bind(null, this, idbMode, storeNames, parentTransaction, scopeFunc);\n    return (parentTransaction ?\n        parentTransaction._promise(idbMode, enterTransaction, \"lock\") :\n        PSD.trans ?\n            // no parent transaction despite PSD.trans exists. Make sure also\n            // that the zone we create is not a sub-zone of current, because\n            // Promise.follow() should not wait for it if so.\n            usePSD(PSD.transless, ()=>this._whenReady(enterTransaction)) :\n            this._whenReady (enterTransaction));\n  }\n\n  table(tableName: string): Table;\n  table<T, TKey extends IndexableType=IndexableType>(tableName: string): ITable<T, TKey>;\n  table(tableName: string): Table {\n    if (!hasOwn(this._allTables, tableName)) {\n      throw new exceptions.InvalidTable(`Table ${tableName} does not exist`); }\n    return this._allTables[tableName];\n  }\n}\n", "import {\n  Observable as IObservable,\n  Observer,\n  Subscription,\n} from \"../../public/types/observable\";\n\nconst symbolObservable: typeof Symbol.observable =\n  typeof Symbol !== \"undefined\" && \"observable\" in Symbol\n    ? Symbol.observable\n    : \"@@observable\" as any;\n\nexport class Observable<T> implements IObservable<T> {\n  private _subscribe: (observer: Observer<T>) => Subscription;\n  hasValue?: ()=>boolean;\n  getValue?: ()=>T;\n\n  constructor(subscribe: (observer: Observer<T>) => Subscription) {\n    this._subscribe = subscribe;\n  }\n\n  subscribe(\n    onNext?: ((value: T) => void) | null,\n    onError?: ((error: any) => void) | null,\n    onComplete?: (() => void) | null\n  ): Subscription;\n  subscribe(observer?: Observer<T> | null): Subscription;\n  subscribe(x?: any, error?: any, complete?: any): Subscription {\n    return this._subscribe(\n      !x || typeof x === \"function\" ? { next: x, error, complete } : x\n    );\n  }\n\n  [symbolObservable]() {\n    return this;\n  }\n}\n", "import { deepClone, keys } from \"../functions/utils\";\nimport { mergeRanges, RangeSet } from \"../helpers/rangeset\";\nimport { ObservabilitySet } from \"../public/types/db-events\";\n\nexport function extendObservabilitySet(\n  target: ObservabilitySet,\n  newSet: ObservabilitySet\n): ObservabilitySet {\n  keys(newSet).forEach(part => {\n    const rangeSet = target[part] || (target[part] = new RangeSet());\n    mergeRanges(rangeSet, newSet[part]);\n  });\n  return target;\n}\n", "import { isAsyncFunction, keys } from \"../functions/utils\";\nimport { globalEvents, DEXIE_STORAGE_MUTATED_EVENT_NAME } from \"../globals/global-events\";\nimport {\n  decrementExpectedAwaits,\n  incrementExpectedAwaits,\n  newScope,\n  PSD,\n  usePSD,\n} from \"../helpers/promise\";\nimport { ObservabilitySet } from \"../public/types/db-events\";\nimport {\n  Observable as IObservable,\n  Subscription,\n} from \"../public/types/observable\";\nimport { Observable } from \"../classes/observable/observable\";\nimport { extendObservabilitySet } from \"./extend-observability-set\";\nimport { rangesOverlap } from \"../helpers/rangeset\";\n\nexport function liveQuery<T>(querier: () => T | Promise<T>): IObservable<T> {\n  let hasValue = false;\n  let currentValue: T = undefined as any;\n  const observable = new Observable<T>((observer) => {\n    const scopeFuncIsAsync = isAsyncFunction(querier);\n    function execute(subscr: ObservabilitySet) {\n      if (scopeFuncIsAsync) {\n        incrementExpectedAwaits();\n      }\n      const exec = () => newScope(querier, { subscr, trans: null });\n      const rv = PSD.trans\n        ? // Ignore current transaction if active when calling subscribe().\n          usePSD(PSD.transless, exec)\n        : exec();\n      if (scopeFuncIsAsync) {\n        (rv as Promise<any>).then(\n          decrementExpectedAwaits,\n          decrementExpectedAwaits\n        );\n      }\n      return rv;\n    }\n\n    let closed = false;\n\n    let accumMuts: ObservabilitySet = {};\n    let currentObs: ObservabilitySet = {};\n\n    const subscription: Subscription = {\n      get closed() {\n        return closed;\n      },\n      unsubscribe: () => {\n        closed = true;\n        globalEvents.storagemutated.unsubscribe(mutationListener);\n      },\n    };\n\n    observer.start && observer.start(subscription); // https://github.com/tc39/proposal-observable\n\n    let querying = false,\n      startedListening = false;\n\n    function shouldNotify() {\n      return keys(currentObs).some(\n        (key) =>\n          accumMuts[key] && rangesOverlap(accumMuts[key], currentObs[key])\n      );\n    }\n\n    const mutationListener = (parts: ObservabilitySet) => {\n      extendObservabilitySet(accumMuts, parts);\n      if (shouldNotify()) {\n        doQuery();\n      }\n    };\n\n    const doQuery = () => {\n      if (querying || closed) return;\n      accumMuts = {};\n      const subscr: ObservabilitySet = {};\n      const ret = execute(subscr);\n      if (!startedListening) {\n        globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, mutationListener);\n        startedListening = true;\n      }\n      querying = true;\n      Promise.resolve(ret).then(\n        (result) => {\n          hasValue = true;\n          currentValue = result;\n          querying = false;\n          if (closed) return;\n          if (shouldNotify()) {\n            // Mutations has happened while we were querying. Redo query.\n            doQuery();\n          } else {\n            accumMuts = {};\n            // Update what we are subscribing for based on this last run:\n            currentObs = subscr;\n            observer.next && observer.next(result);\n          }\n        },\n        (err) => {\n          querying = false;\n          hasValue = false;\n          observer.error && observer.error(err);\n          subscription.unsubscribe();\n        }\n      );\n    };\n\n    doQuery();\n    return subscription;\n  });\n  observable.hasValue = () => hasValue;\n  observable.getValue = () => currentValue;\n  return observable;\n}\n", "import { _global } from '../../globals/global';\nimport { DexieDOMDependencies } from '../../public/types/dexie-dom-dependencies';\n\nexport let domDeps: DexieDOMDependencies\n\ntry {\n  domDeps = {\n    // Required:\n    indexedDB: _global.indexedDB || _global.mozIndexedDB || _global.webkitIndexedDB || _global.msIndexedDB,\n    IDBKeyRange: _global.IDBKeyRange || _global.webkitIDBKeyRange\n  };\n} catch (e) {\n  domDeps = { indexedDB: null, IDBKeyRange: null };\n}\n", "import { Dexie as _Dexie } from './dexie';\nimport { _global } from '../../globals/global';\nimport { props, derive, extend, override, getByKeyPath, setByKeyPath, delByKeyPath, shallowClone, deepClone, asap } from '../../functions/utils';\nimport { getObjectDiff } from \"../../functions/get-object-diff\";\nimport { fullNameExceptions } from '../../errors';\nimport { DexieConstructor } from '../../public/types/dexie-constructor';\nimport { getDatabaseNames } from '../../helpers/database-enumerator';\nimport { PSD } from '../../helpers/promise';\nimport { usePSD } from '../../helpers/promise';\nimport { newScope } from '../../helpers/promise';\nimport { rejection } from '../../helpers/promise';\nimport { awaitIterator } from '../../helpers/yield-support';\nimport Promise from '../../helpers/promise';\nimport * as Debug from '../../helpers/debug';\nimport { dexieStackFrameFilter, minKey, connections, DEXIE_VERSION } from '../../globals/constants';\nimport Events from '../../helpers/Events';\nimport { exceptions } from '../../errors';\nimport { errnames } from '../../errors';\nimport { getMaxKey } from '../../functions/quirks';\nimport { vip } from './vip';\nimport { globalEvents } from '../../globals/global-events';\nimport { liveQuery } from '../../live-query/live-query';\nimport { extendObservabilitySet } from '../../live-query/extend-observability-set';\nimport { domDeps } from './dexie-dom-dependencies';\nimport { cmp } from '../../functions/cmp';\n\n/* (Dexie) is an instance of DexieConstructor, as defined in public/types/dexie-constructor.d.ts\n*  (new Dexie()) is an instance of Dexie, as defined in public/types/dexie.d.ts\n* \n* Why we're doing this?\n\n* Because we've choosen to define the public Dexie API using a DexieConstructor interface\n* rather than declaring a class. On that interface, all static props are defined.\n* In practice, class Dexie's constructor implements DexieConstructor and all member props\n* are defined in interface Dexie. We could say, it's a typescript limitation of not being\n* able to define a static interface that forces us to do the cast below.\n*/\nconst Dexie = _Dexie as any as DexieConstructor;\n\n//\n// Set all static methods and properties onto Dexie:\n// \nprops(Dexie, {\n\n  // Dexie.BulkError = class BulkError {...};\n  // Dexie.XXXError = class XXXError {...};\n  ...fullNameExceptions,\n\n  //\n  // Static delete() method.\n  //\n  delete(databaseName: string) {\n    const db = new Dexie(databaseName, {addons: []});\n    return db.delete();\n  },\n\n  //\n  // Static exists() method.\n  //\n  exists(name: string) {\n    return new Dexie(name, { addons: [] }).open().then(db => {\n      db.close();\n      return true;\n    }).catch('NoSuchDatabaseError', () => false);\n  },\n\n  //\n  // Static method for retrieving a list of all existing databases at current host.\n  //\n  getDatabaseNames(cb) {\n    try {\n      return getDatabaseNames(Dexie.dependencies).then(cb);\n    } catch {\n      return rejection(new exceptions.MissingAPI());\n    }\n  },\n\n  /** @deprecated */\n  defineClass() {\n    function Class(content) {\n      extend(this, content);\n    }\n    return Class;\n  },\n\n  ignoreTransaction(scopeFunc) {\n    // In case caller is within a transaction but needs to create a separate transaction.\n    // Example of usage:\n    //\n    // Let's say we have a logger function in our app. Other application-logic should be unaware of the\n    // logger function and not need to include the 'logentries' table in all transaction it performs.\n    // The logging should always be done in a separate transaction and not be dependant on the current\n    // running transaction context. Then you could use Dexie.ignoreTransaction() to run code that starts a new transaction.\n    //\n    //     Dexie.ignoreTransaction(function() {\n    //         db.logentries.add(newLogEntry);\n    //     });\n    //\n    // Unless using Dexie.ignoreTransaction(), the above example would try to reuse the current transaction\n    // in current Promise-scope.\n    //\n    // An alternative to Dexie.ignoreTransaction() would be setImmediate() or setTimeout(). The reason we still provide an\n    // API for this because\n    //  1) The intention of writing the statement could be unclear if using setImmediate() or setTimeout().\n    //  2) setTimeout() would wait unnescessary until firing. This is however not the case with setImmediate().\n    //  3) setImmediate() is not supported in the ES standard.\n    //  4) You might want to keep other PSD state that was set in a parent PSD, such as PSD.letThrough.\n    return PSD.trans ?\n      usePSD(PSD.transless, scopeFunc) : // Use the closest parent that was non-transactional.\n      scopeFunc(); // No need to change scope because there is no ongoing transaction.\n  },\n\n  vip,\n\n  async: function (generatorFn: Function) {\n    return function () {\n      try {\n        var rv = awaitIterator(generatorFn.apply(this, arguments));\n        if (!rv || typeof rv.then !== 'function')\n          return Promise.resolve(rv);\n        return rv;\n      } catch (e) {\n        return rejection(e);\n      }\n    };\n  },\n\n  spawn: function (generatorFn, args, thiz) {\n    try {\n      var rv = awaitIterator(generatorFn.apply(thiz, args || []));\n      if (!rv || typeof rv.then !== 'function')\n        return Promise.resolve(rv);\n      return rv;\n    } catch (e) {\n      return rejection(e);\n    }\n  },\n\n  // Dexie.currentTransaction property\n  currentTransaction: {\n    get: () => PSD.trans || null\n  },\n\n  waitFor: function (promiseOrFunction, optionalTimeout) {\n    // If a function is provided, invoke it and pass the returning value to Transaction.waitFor()\n    const promise = Promise.resolve(\n      typeof promiseOrFunction === 'function' ?\n        Dexie.ignoreTransaction(promiseOrFunction) :\n        promiseOrFunction)\n      .timeout(optionalTimeout || 60000); // Default the timeout to one minute. Caller may specify Infinity if required.       \n\n    // Run given promise on current transaction. If no current transaction, just return a Dexie promise based\n    // on given value.\n    return PSD.trans ?\n      PSD.trans.waitFor(promise) :\n      promise;\n  },\n\n  // Export our Promise implementation since it can be handy as a standalone Promise implementation\n  Promise: Promise,\n\n  // Dexie.debug proptery:\n  // Dexie.debug = false\n  // Dexie.debug = true\n  // Dexie.debug = \"dexie\" - don't hide dexie's stack frames.\n  debug: {\n    get: () => Debug.debug,\n    set: value => {\n      Debug.setDebug(value, value === 'dexie' ? () => true : dexieStackFrameFilter);\n    }\n  },\n\n  // Export our derive/extend/override methodology\n  derive: derive, // Deprecate?\n  extend: extend, // Deprecate?\n  props: props,\n  override: override, // Deprecate?\n  // Export our Events() function - can be handy as a toolkit\n  Events: Events,\n  on: globalEvents,\n  liveQuery,\n  extendObservabilitySet,\n  // Utilities\n  getByKeyPath: getByKeyPath,\n  setByKeyPath: setByKeyPath,\n  delByKeyPath: delByKeyPath,\n  shallowClone: shallowClone,\n  deepClone: deepClone,\n  getObjectDiff: getObjectDiff,\n  cmp,\n  asap: asap,\n  //maxKey: new Dexie('',{addons:[]})._maxKey,\n  minKey: minKey,\n  // Addon registry\n  addons: [],\n  // Global DB connection list\n  connections: connections,\n\n  //MultiModifyError: exceptions.Modify, // Obsolete!\n  errnames: errnames,\n\n  // Export other static classes\n  //IndexSpec: IndexSpec, Obsolete!\n  //TableSchema: TableSchema, Obsolete!\n\n  //\n  // Dependencies\n  //\n  // These will automatically work in browsers with indexedDB support, or where an indexedDB polyfill has been included.\n  //\n  // In node.js, however, these properties must be set \"manually\" before instansiating a new Dexie().\n  // For node.js, you need to require indexeddb-js or similar and then set these deps.\n  //\n  dependencies: domDeps,\n\n  // API Version Number: Type Number, make sure to always set a version number that can be comparable correctly. Example: 0.9, 0.91, 0.92, 1.0, 1.01, 1.1, 1.2, 1.21, etc.\n  semVer: DEXIE_VERSION,\n  version: DEXIE_VERSION.split('.')\n    .map(n => parseInt(n))\n    .reduce((p, c, i) => p + (c / Math.pow(10, i * 2))),\n\n  // https://github.com/dfahlander/Dexie.js/issues/186\n  // typescript compiler tsc in mode ts-->es5 & commonJS, will expect require() to return\n  // x.default. Workaround: Set Dexie.default = Dexie.\n  // default: Dexie, // Commented because solved in index-umd.ts instead.\n  // Make it possible to import {Dexie} (non-default import)\n  // Reason 1: May switch to that in future.\n  // Reason 2: We declare it both default and named exported in d.ts to make it possible\n  // to let addons extend the Dexie interface with Typescript 2.1 (works only when explicitely\n  // exporting the symbol, not just default exporting)\n  // Dexie: Dexie // Commented because solved in index-umd.ts instead.\n});\n\nDexie.maxKey = getMaxKey(Dexie.dependencies.IDBKeyRange);\n", "import { isIEOrEdge } from '../globals/constants';\nimport { globalEvents, DEXIE_STORAGE_MUTATED_EVENT_NAME, STORAGE_MUTATED_DOM_EVENT_NAME } from '../globals/global-events';\nimport { ObservabilitySet } from \"../public/types/db-events\";\n\nif (typeof dispatchEvent !== 'undefined' && typeof addEventListener !== 'undefined') {\n  globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, updatedParts => {\n    if (!propagatingLocally) {\n      let event: CustomEvent<ObservabilitySet>;\n      if (isIEOrEdge) {\n        event = document.createEvent('CustomEvent');\n        event.initCustomEvent(STORAGE_MUTATED_DOM_EVENT_NAME, true, true, updatedParts);\n      } else {\n        event = new CustomEvent(STORAGE_MUTATED_DOM_EVENT_NAME, {\n          detail: updatedParts\n        });\n      }\n      propagatingLocally = true;\n      dispatchEvent(event);\n      propagatingLocally = false;\n    }\n  });\n  addEventListener(STORAGE_MUTATED_DOM_EVENT_NAME, ({detail}: CustomEvent<ObservabilitySet>) => {\n    if (!propagatingLocally) {\n      propagateLocally(detail);\n    }\n  });\n}\n\nexport function propagateLocally(updateParts: ObservabilitySet) {\n  let wasMe = propagatingLocally;\n  try {\n    propagatingLocally = true;\n    globalEvents.storagemutated.fire(updateParts);\n  } finally {\n    propagatingLocally = wasMe;\n  }\n}\n\nexport let propagatingLocally = false;\n", "import {\n  globalEvents,\n  STORAGE_MUTATED_DOM_EVENT_NAME,\n  DEXIE_STORAGE_MUTATED_EVENT_NAME,\n} from '../globals/global-events';\nimport { propagateLocally, propagatingLocally } from './propagate-locally';\n\nif (typeof BroadcastChannel !== 'undefined') {\n  const bc = new BroadcastChannel(STORAGE_MUTATED_DOM_EVENT_NAME);\n\n  /**\n     * The Node.js BroadcastChannel will prevent the node process from exiting\n     * if the BroadcastChannel is not closed.\n     * Therefore we have to call unref() which allows the process to finish\n     * properly even when the BroadcastChannel is never closed.\n     * @link https://nodejs.org/api/worker_threads.html#broadcastchannelunref\n     * @link https://github.com/dexie/Dexie.js/pull/1576\n     */\n  if (typeof (bc as any).unref === 'function') {\n    (bc as any).unref();\n  } \n   \n  //\n  // Propagate local changes to remote tabs, windows and workers via BroadcastChannel\n  //\n  globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, (changedParts) => {\n    if (!propagatingLocally) {\n      bc.postMessage(changedParts);\n    }\n  });\n\n  //\n  // Propagate remote changes locally via storage event:\n  //\n  bc.onmessage = (ev) => {\n    if (ev.data) propagateLocally(ev.data);\n  };\n} else if (typeof self !== 'undefined' && typeof navigator !== 'undefined') {\n  // DOM verified - when typeof self !== \"undefined\", we are a window or worker. Not a Node process.\n\n  //\n  // Propagate local changes to remote tabs/windows via storage event and service worker\n  // via messages. We have this code here because of https://bugs.webkit.org/show_bug.cgi?id=161472.\n  //\n  globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, (changedParts) => {\n    try {\n      if (!propagatingLocally) {\n        if (typeof localStorage !== 'undefined') {\n          // We're a browsing window or tab. Propagate to other windows/tabs via storage event:\n          localStorage.setItem(\n            STORAGE_MUTATED_DOM_EVENT_NAME,\n            JSON.stringify({\n              trig: Math.random(),\n              changedParts,\n            })\n          );\n        }\n        if (typeof self['clients'] === 'object') {\n          // We're a service worker. Propagate to our browser clients.\n          [...self['clients'].matchAll({ includeUncontrolled: true })].forEach(\n            (client) =>\n              client.postMessage({\n                type: STORAGE_MUTATED_DOM_EVENT_NAME,\n                changedParts,\n              })\n          );\n        }\n      }\n    } catch {}\n  });\n\n  //\n  // Propagate remote changes locally via storage event:\n  //\n  if (typeof addEventListener !== 'undefined') {\n      addEventListener('storage', (ev: StorageEvent) => {\n      if (ev.key === STORAGE_MUTATED_DOM_EVENT_NAME) {\n        const data = JSON.parse(ev.newValue);\n        if (data) propagateLocally(data.changedParts);\n      }\n    });\n  }\n\n  //\n  // Propagate messages from service worker\n  //\n  const swContainer = self.document && navigator.serviceWorker; // self.document is to verify we're not the SW ourself\n  if (swContainer) {\n    // We're a browser window and want to propagate message from the SW:\n    swContainer.addEventListener('message', propagateMessageLocally);\n  }\n}\n\nfunction propagateMessageLocally({ data }: MessageEvent) {\n  if (data && data.type === STORAGE_MUTATED_DOM_EVENT_NAME) {\n    propagateLocally(data.changedParts);\n  }\n}\n", "import { Dexie } from './classes/dexie';\nimport { DexieConstructor } from './public/types/dexie-constructor';\nimport { DexiePromise } from './helpers/promise';\nimport { mapError } from './errors';\nimport * as Debug from './helpers/debug';\nimport { dexieStackFrameFilter } from './globals/constants';\n\n// Generate all static properties such as Dexie.maxKey etc\n// (implement interface DexieConstructor):\nimport './classes/dexie/dexie-static-props';\nimport './live-query/enable-broadcast';\nimport { liveQuery } from './live-query/live-query';\n\n// Set rejectionMapper of DexiePromise so that it generally tries to map\n// DOMErrors and DOMExceptions to a DexieError instance with same name but with\n// async stack support and with a prototypal inheritance from DexieError and Error.\n// of Map DOMErrors and DOMExceptions to corresponding Dexie errors.\nDexiePromise.rejectionMapper = mapError;\n\n// Let the async stack filter focus on app code and filter away frames from dexie.min.js:\nDebug.setDebug(Debug.debug, dexieStackFrameFilter);\n\nexport { RangeSet, mergeRanges, rangesOverlap } from \"./helpers/rangeset\";\nexport { Dexie, liveQuery }; // Comply with public/index.d.ts.\nexport default Dexie;\n", "import Dexie from \"dexie\";\r\n\r\nconst DATABASE_NAME = \"client-state\";\r\nconst STORES = {\r\n  flights: \"flightId\",\r\n  selections: \"++id\",\r\n};\r\n\r\nfunction createStorageRepository() {\r\n  const db = new Dexie(DATABASE_NAME, { autoOpen: true });\r\n  db.version(1).stores(STORES);\r\n\r\n  return {\r\n    flights: db.flights,\r\n    selections: db.selections,\r\n  };\r\n}\r\n\r\nexport default createStorageRepository;", "\n      import * as entryWorker from \"C:\\\\Users\\\\Ukeje Chukwuemeriwo\\\\Documents\\\\shafspecs\\\\monorepo\\\\playground\\\\app/entry.worker.ts\";\n\n    import * as route0 from \"root.tsx?worker\";\nimport * as route1 from \"routes/basic-caching.tsx?worker\";\nimport * as route2 from \"routes/basic-action.tsx?worker\";\nimport * as route3 from \"routes/basic-loader.tsx?worker\";\nimport * as route4 from \"routes/_app.flights.tsx?worker\";\nimport * as route5 from \"routes/strategies.tsx?worker\";\nimport * as route6 from \"routes/selection.tsx?worker\";\nimport * as route7 from \"routes/sync-away.tsx?worker\";\nimport * as route8 from \"routes/_index.tsx?worker\";\nimport * as route9 from \"routes/_app.tsx?worker\";\n\n    export const routes = {\n      \"root\": {\n          id: \"root\",\n          parentId: undefined,\n          path: \"\",\n          index: undefined,\n          caseSensitive: undefined,\n          module: route0\n        },\n\"routes/basic-caching\": {\n          id: \"routes/basic-caching\",\n          parentId: \"root\",\n          path: \"basic-caching\",\n          index: undefined,\n          caseSensitive: undefined,\n          module: route1\n        },\n\"routes/basic-action\": {\n          id: \"routes/basic-action\",\n          parentId: \"root\",\n          path: \"basic-action\",\n          index: undefined,\n          caseSensitive: undefined,\n          module: route2\n        },\n\"routes/basic-loader\": {\n          id: \"routes/basic-loader\",\n          parentId: \"root\",\n          path: \"basic-loader\",\n          index: undefined,\n          caseSensitive: undefined,\n          module: route3\n        },\n\"routes/_app.flights\": {\n          id: \"routes/_app.flights\",\n          parentId: \"routes/_app\",\n          path: \"flights\",\n          index: undefined,\n          caseSensitive: undefined,\n          module: route4\n        },\n\"routes/strategies\": {\n          id: \"routes/strategies\",\n          parentId: \"root\",\n          path: \"strategies\",\n          index: undefined,\n          caseSensitive: undefined,\n          module: route5\n        },\n\"routes/selection\": {\n          id: \"routes/selection\",\n          parentId: \"root\",\n          path: \"selection\",\n          index: undefined,\n          caseSensitive: undefined,\n          module: route6\n        },\n\"routes/sync-away\": {\n          id: \"routes/sync-away\",\n          parentId: \"root\",\n          path: \"sync-away\",\n          index: undefined,\n          caseSensitive: undefined,\n          module: route7\n        },\n\"routes/_index\": {\n          id: \"routes/_index\",\n          parentId: \"root\",\n          path: undefined,\n          index: true,\n          caseSensitive: undefined,\n          module: route8\n        },\n\"routes/_app\": {\n          id: \"routes/_app\",\n          parentId: \"root\",\n          path: undefined,\n          index: undefined,\n          caseSensitive: undefined,\n          module: route9\n        }\n    };\n\n    export { assets } from '@remix-pwa/dev?assets';\n    export const entry = { module: entryWorker };\n    ", "import { cacheFirst } from '@remix-pwa/strategy';\nimport { toJSON } from '@remix-pwa/strategy';\nexport const workerLoader = async ({ context }: any) => {\r\n  const customStrategy = cacheFirst({\r\n    cache: 'basic-caching',\r\n    cacheQueryOptions: {\r\n      ignoreSearch: true\r\n    },\r\n    cacheOptions: {\r\n      maxItems: 5,\r\n      ttl: 30 * 1_000 // 30 seconds time-to-live (maxAge)\r\n    },\r\n    fetchDidFail: [\r\n      () => console.log('Fetch failed!')\r\n    ]\r\n  });\r\n\r\n  let response = await customStrategy(context.event.request);\r\n\r\n  // Testing out caching binary data - images, fonts, etc.\r\n  // Btw, look above, caching strategy has a ttl of 30 secs.\r\n  // Either be fast, or increase the time to test this out.\r\n  await customStrategy(new Request('https://images.unsplash.com/photo-1695570804246-a9470af7e197?ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D&auto=format&fit=crop&w=2903&q=80'))\r\n\r\n  let data = await toJSON(response);\r\n\r\n  const date = new Date();\r\n\r\n  // We showcase caching by extracting the data from the response and returning it,\r\n  // modifying one of its properties and returning it back to the client (which is only\r\n  // possible if we have a cached value to modify.)\r\n  return new Response(JSON.stringify({\r\n    data: data.data,\r\n    // Only this shows an updated time, the other one doesn't because it's cached.\r\n    // Try deleting the cache and reloading the page to see the difference.\r\n    message: `Server already up and running! Time: ${date.getMinutes()}:${date.getSeconds()}`\r\n  }), {\r\n    headers: {\r\n      'Content-Type': 'application/json'\r\n    }\r\n  });\r\n}\n", "import { WorkerActionArgs } from '@remix-pwa/sw';\nexport const workerAction = async ({ context }: WorkerActionArgs) => {\r\n  const { fetchFromServer } = context;\r\n\r\n  console.log('Worker action called');\r\n\r\n  try {\r\n    // We are now calling the actual Remix action here, but like you can see \r\n    // we are doing nothing with it, so no redirect happens \uD83D\uDE0F\r\n    //\r\n    // But open up the 'Cookies' section in your devtools for a little surprise.\r\n    const response = await fetchFromServer() as unknown as Response;\r\n\r\n    console.log(Object.fromEntries(response.headers.entries()));\r\n  } catch (error) {\r\n    console.error(error);\r\n  }\r\n\r\n  return new Response(JSON.stringify({\r\n    message: 'Modified action response, Remix Actions are quite out of the picture here'\r\n  }), {\r\n    headers: {\r\n      'Content-Type': 'application/json; charset=utf-8'\r\n    }\r\n  });\r\n}\n", "\nexport async function workerLoader ({ context }: any) {\r\n  // `fetchFromServer` is a utility function provided to \r\n  // allow you to make requests to the server directly from the worker.\r\n  const { fetchFromServer } = context;\r\n\r\n  // In here, we are racing between the server and client to see who can\r\n  // return the data first. By default, client resolves first, but if the server\r\n  // is faster, then the server's data will be returned instead. We can also use \r\n  // Promise.allSettled to get both results and return the server data if it's\r\n  // available. \r\n  const message = await Promise.race([\r\n    fetchFromServer()\r\n      .then((response: any) => response.json())\r\n      .then(({ message }: any) => message),\r\n    new Promise((resolve) => setTimeout(resolve, 500, 'Hello World!\\n\\n\u2022 This message is sent to you from the client \uD83D\uDE1C!'))\r\n  ]);\r\n\r\n  return new Response(JSON.stringify({\r\n    message\r\n  }),\r\n    {\r\n      headers: {\r\n        'Content-Type': 'application/json'\r\n      }\r\n    })\r\n}\n", "import { redirect } from '@remix-run/router';\nimport { defer } from '@remix-run/router';\nimport { json } from '@remix-run/router';\nimport { LoaderArgs } from '@remix-run/node';\nexport const workerAction = async ({ request, context }: LoaderArgs) => {\r\n  const formData = await request.formData();\r\n  \r\n  const { database, fetchFromServer } = context;\r\n\r\n  try {\r\n    // Send action to server\r\n    fetchFromServer();\r\n    // Save selection in client\r\n    await database.selections.add(Object.fromEntries(formData.entries()));\r\n    // Redirect to selection page\r\n    return redirect(\"/selection\");\r\n  } catch (error) {\r\n    throw json({ message: \"Something went wrong\", error }, 500);\r\n  }\r\n}\nexport const workerLoader = async ({ context }) => {\r\n  try {\r\n    const { fetchFromServer, database } = context;\r\n    const [serverResult, clientResult] = await Promise.allSettled([\r\n      // NOTE: If the user decides to use the server loader, must use the `context.event.request` object instead of `request`.\r\n      // This is because we strip the `_data` and `index` from the request object just to follow what Remix does.\r\n      fetchFromServer()\r\n        .then((response) => response.json())\r\n        .then(({ flights }) => flights),\r\n      database.flights.toArray(),\r\n    ]);\r\n    const flights = serverResult.value || clientResult.value;\r\n\r\n    if (serverResult.value) {\r\n      await database.flights.bulkPut(\r\n        flights.map((f) => ({\r\n          ...f,\r\n          flightNumber: `${f.flightNumber.split(\"-\")[0].trim()} - client`,\r\n        }))\r\n      );\r\n    }\r\n\r\n    // can't use same `json` here because is only for node\r\n    return defer({ flights });\r\n  } catch (error) {\r\n    console.error(error);\r\n    throw json({ message: \"Something went wrong\", error }, 500);\r\n  }\r\n}\n", "import { cacheFirst } from '@remix-pwa/strategy';\nimport { cacheOnly } from '@remix-pwa/strategy';\nimport { networkFirst } from '@remix-pwa/strategy';\nimport { staleWhileRevalidate } from '@remix-pwa/strategy';\nimport { StrategyResponse } from '@remix-pwa/strategy';\nexport const workerAction = async ({ context }) => {\r\n  const { event } = context;\r\n\r\n  const formData = await event.request.clone().formData(); // We cloned it so we can use the request later\r\n\r\n  const strategy = formData.get(\"strategy\");\r\n  // const message = formData.get(\"message\");\r\n\r\n  let customStrategy: StrategyResponse | undefined = undefined;\r\n\r\n  switch (strategy) {\r\n    case 'cache-only':\r\n      customStrategy = await cacheOnly({\r\n        cache: 'strategies-cache-only',\r\n      });\r\n      break;\r\n    case 'cache-first':\r\n      customStrategy = await cacheFirst({\r\n        cache: 'strategies-cache-first',\r\n      })\r\n      break;\r\n    case 'network-first':\r\n      customStrategy = await networkFirst({\r\n        cache: 'strategies-network-first',\r\n      })\r\n      break;\r\n    case 'swr':\r\n      customStrategy = await staleWhileRevalidate({\r\n        cache: 'strategies-swr',\r\n      })\r\n      break;\r\n    default:\r\n      break;\r\n  }\r\n\r\n  // if (customStrategy !== undefined) customStrategy(event.request)\r\n\r\n  return null;\r\n}\n", "import { json } from '@remix-run/router';\nexport async function workerLoader({ context }) {\r\n  const { database } = context;\r\n  \r\n  const selections = await database.selections.toArray();\r\n\r\n  return json({ selections });\r\n}\n", "import { WorkerActionArgs } from '@remix-pwa/sw';\nimport { queueToServer } from '@remix-pwa/sync';\nexport const workerAction = async ({ context }: WorkerActionArgs) => {\r\n  const { fetchFromServer, event } = context;\r\n\r\n  try {\r\n    // We are now calling the actual Remix action here, but like you can see\r\n    // we are doing nothing with it, so no redirect happens \uD83D\uDE0F\r\n    //\r\n    // But open up the 'Cookies' section in your devtools for a little surprise.\r\n    await fetchFromServer() as unknown as Response;\r\n  } catch (error) {\r\n    console.error(error);\r\n    queueToServer({\r\n      name: 'offline-action',\r\n      request: event.request.clone(),\r\n    })\r\n  }\r\n\r\n  return new Response(JSON.stringify({\r\n    message: 'Offline or Online. I shall always respond!'\r\n  }), {\r\n    headers: {\r\n      'Content-Type': 'application/json; charset=utf-8'\r\n    }\r\n  });\r\n}\n", "import { WorkerLoaderArgs } from '@remix-pwa/sw';\nimport { json } from '@remix-run/node';\nexport async function workerLoader({ context }: WorkerLoaderArgs) {\r\n  const { fetchFromServer } = context;\r\n\r\n  const data = await fetchFromServer().then((response: Response) => response.json());\r\n\r\n  console.log(data);\r\n\r\n  // This also works here!\r\n  // This is a bit useless, ik. But it's just to show that you can use\r\n  // worker loader and actions in pathless routes too!\r\n  return new Response(JSON.stringify(data), {\r\n    headers: {\r\n      \"Content-Type\": \"application/json\",\r\n    },\r\n  });\r\n}\n", "export const assets = [];", "import { isRouteErrorResponse } from '@remix-run/router';\nimport { ServerMode } from '@remix-run/server-runtime/dist/mode.js';\nimport { createDeferredReadableStream, isDeferredData, isRedirectResponse, isRedirectStatusCode, isResponse, json, redirect, } from '@remix-run/server-runtime/dist/responses.js';\nimport { createArgumentsFrom, getURLParameters, isActionRequest, isLoaderRequest } from './request.js';\nimport { errorResponseToJson, isRemixResponse } from './response.js';\n/**\n * A FetchEvent handler for Remix.\n * If the `event.request` has a worker loader/action defined, it will call it and return the response.\n * Otherwise, it will call the default handler...\n */\nexport async function handleRequest({ defaultHandler, errorHandler, event, loadContext, routes, }) {\n    const url = new URL(event.request.url);\n    const routeId = url.searchParams.get('_data');\n    // if the request is not a loader or action request, we call the default handler and the routeId will be undefined\n    const route = routeId ? routes[routeId] : undefined;\n    const _arguments = {\n        request: event.request,\n        params: getURLParameters(event.request, route?.path),\n        context: loadContext,\n    };\n    try {\n        if (isLoaderRequest(event.request) && route?.module.workerLoader) {\n            return await handleLoader({\n                event,\n                loader: route.module.workerLoader,\n                routeId: route.id,\n                routePath: route.path,\n                loadContext,\n            }).then(responseHandler);\n        }\n        if (isActionRequest(event.request) && route?.module?.workerAction) {\n            return await handleAction({\n                event,\n                action: route.module.workerAction,\n                routeId: route.id,\n                routePath: route.path,\n                loadContext,\n            }).then(responseHandler);\n        }\n    }\n    catch (error) {\n        const handler = (error) => errorHandler(error, _arguments);\n        return _errorHandler({ error, handler });\n    }\n    return defaultHandler(_arguments);\n}\n/**\n * Handle a Remix worker loader request.\n */\nasync function handleLoader({ event, loadContext, loader, routeId, routePath }) {\n    const _arguments = createArgumentsFrom({ event, loadContext, path: routePath });\n    const result = await loader(_arguments);\n    if (result === undefined) {\n        throw new Error(`You defined a loader for route \"${routeId}\" but didn't return ` +\n            `anything from your \\`worker loader\\` function. Please return a value or \\`null\\`.`);\n    }\n    if (isDeferredData(result)) {\n        if (result.init && isRedirectStatusCode(result.init.status || 200)) {\n            return redirect(new Headers(result.init.headers).get('Location'), result.init);\n        }\n        const body = createDeferredReadableStream(result, event.request.signal, ServerMode.Production);\n        const init = result.init || {};\n        const headers = new Headers(init.headers);\n        headers.set('Content-Type', 'text/remix-deferred');\n        init.headers = headers;\n        return new Response(body, init);\n    }\n    return isResponse(result) ? result : json(result);\n}\n/**\n * Handle a Remix worker action request.\n */\nasync function handleAction({ action, event, loadContext, routeId, routePath }) {\n    const _arguments = createArgumentsFrom({ event, loadContext, path: routePath });\n    const result = await action(_arguments);\n    if (result === undefined) {\n        throw new Error(`You defined an action for route \"${routeId}\" but didn't return ` +\n            `anything from your \\`worker action\\` function. Please return a value or \\`null\\`.`);\n    }\n    return isResponse(result) ? result : json(result);\n}\n/**\n * Takes an data route error and returns remix expected json response\n */\nfunction _errorHandler({ error, handler: handleError }) {\n    if (isResponse(error)) {\n        error.headers.set('X-Remix-Catch', 'yes');\n        return error;\n    }\n    if (isRouteErrorResponse(error)) {\n        // @ts-expect-error\n        error.error && handleError(error.error);\n        return errorResponseToJson(error);\n    }\n    const errorInstance = error instanceof Error ? error : new Error('Unexpected Server Error');\n    handleError(errorInstance);\n    return json({ message: errorInstance.message }, {\n        status: 500,\n        headers: {\n            'X-Remix-Error': 'yes',\n        },\n    });\n}\n/**\n * Takes a response and returns a new response with the remix expected headers and status\n */\nfunction responseHandler(response) {\n    if (isRedirectResponse(response)) {\n        // We don't have any way to prevent a fetch request from following\n        // redirects. So we use the `X-Remix-Redirect` header to indicate the\n        // next URL, and then \"follow\" the redirect manually on the client.\n        const headers = new Headers(response.headers);\n        headers.set('X-Remix-Redirect', headers.get('Location'));\n        headers.set('X-Remix-Status', String(response.status));\n        headers.delete('Location');\n        if (response.headers.get('Set-Cookie') !== null) {\n            headers.set('X-Remix-Revalidate', 'yes');\n        }\n        return new Response(null, {\n            status: 204,\n            headers,\n        });\n    }\n    // Mark all successful responses with a header so we can identify in-flight\n    // network errors that are missing this header\n    !isRemixResponse(response) && response.headers.set('X-Remix-Response', 'yes');\n    return response;\n}\n", "import { matchPath } from '@remix-run/router';\n/**\n * Clones an object\n */\nexport function clone(_object) {\n    const init = {};\n    for (const property in _object) {\n        init[property] = _object[property];\n    }\n    return init;\n}\n/**\n * Gets the URL search parameters from a request.\n */\nexport function getURLParameters(request, path = '') {\n    const url = new URL(request.url);\n    const match = matchPath(path, url.pathname);\n    return {\n        ...Object.fromEntries(new URL(request.url).searchParams.entries()),\n        ...match?.params,\n    };\n}\n/**\n * Removes the all the index parameters from a request unless they are not empty.\n */\nexport function stripIndexParameter(request) {\n    const url = new URL(request.url);\n    const indexValues = url.searchParams.getAll('index');\n    const indexValuesToKeep = [];\n    url.searchParams.delete('index');\n    for (const indexValue of indexValues) {\n        if (indexValue) {\n            indexValuesToKeep.push(indexValue);\n        }\n    }\n    for (const toKeep of indexValuesToKeep) {\n        url.searchParams.append('index', toKeep);\n    }\n    // We need to set the duplex property, otherwise the request will fail in the worker.\n    // @ts-expect-error The duplex property is not defined in the Request type, yet. See: https://github.com/whatwg/fetch/pull/1493\n    return new Request(url.href, { ...clone(request), duplex: 'half' });\n}\n/**\n * Removes the data parameter from a request.\n */\nexport function stripDataParameter(request) {\n    const url = new URL(request.url);\n    url.searchParams.delete('_data');\n    // We need to set the duplex property, otherwise the request will fail in the worker.\n    // @ts-expect-error The duplex property is not defined in the Request type, yet. See: https://github.com/whatwg/fetch/pull/1493\n    return new Request(url.href, { ...clone(request), duplex: 'half' });\n}\n/**\n * Creates arguments for the Worker Actions and Loaders.\n */\nexport function createArgumentsFrom({ event, loadContext, path, }) {\n    const request = stripDataParameter(stripIndexParameter(event.request.clone()));\n    const parameters = getURLParameters(request, path);\n    return {\n        request,\n        params: parameters,\n        context: loadContext,\n    };\n}\n/**\n * Checks if a request is one of the methods.\n */\nfunction isMethod(request, methods) {\n    return methods.includes(request.method.toLowerCase());\n}\n/**\n * Checks if given request is a action request.\n */\nexport function isActionRequest(request) {\n    const url = new URL(request.url);\n    return isMethod(request, ['post', 'delete', 'put', 'patch']) && url.searchParams.get('_data');\n}\n/**\n * Checks if given request is a loader request.\n */\nexport function isLoaderRequest(request) {\n    const url = new URL(request.url);\n    return isMethod(request, ['get']) && url.searchParams.get('_data');\n}\n", "import { json } from '@remix-run/server-runtime/dist/responses.js';\n/**\n * Converts an error response to a JSON response.\n */\nexport function errorResponseToJson(errorResponse) {\n    // @ts-expect-error\n    return json(errorResponse.error || { message: 'Unexpected Server Error' }, {\n        status: errorResponse.status,\n        statusText: errorResponse.statusText,\n        headers: {\n            'X-Remix-Error': 'yes',\n        },\n    });\n}\n/**\n * Checks if a response is a Remix response by checking if it has any `X-Remix` headers.\n */\nexport function isRemixResponse(response) {\n    return Array.from(response.headers.keys()).some(key => key.toLowerCase().startsWith('x-remix-'));\n}\n", "// @ts-expect-error\n// eslint-disable-next-line import/no-unresolved\nimport * as build from '@remix-pwa/build/magic';\nimport { handleRequest } from './utils/handle-request.js';\nconst _self = self;\n/**\n * Creates the load context for the worker action and loader.\n */\nfunction createContext(event) {\n    // getLoadContext is a function exported by the `entry.worker.js`\n    const context = build.entry.module.getLoadContext?.(event) || {};\n    return {\n        event,\n        fetchFromServer: () => fetch(event.request.clone()),\n        // NOTE: we want the user to override the above properties if needed.\n        ...context,\n    };\n}\n// if the user export a `defaultFetchHandler` inside the entry.worker.js, we use that one as default handler\nconst defaultHandler = build.entry.module.defaultFetchHandler ||\n    ((event) => fetch(event.request.clone()));\n// if the user export a `errorHandler` inside the entry.worker.js, we use that one as default handler\nconst defaultErrorHandler = build.entry.module.errorHandler ||\n    ((error, { request }) => {\n        if (!request.signal.aborted) {\n            console.error(error);\n        }\n    });\n_self.__workerManifest = {\n    assets: build.assets,\n    routes: build.routes,\n};\n// DO NOT OVERRIDE!!!\n_self.addEventListener('fetch', \n/**\n * The main fetch event listener callback.\n */\nevent => {\n    /* Main request handler */\n    const response = handleRequest({\n        event,\n        routes: build.routes,\n        defaultHandler,\n        errorHandler: defaultErrorHandler,\n        loadContext: createContext(event),\n    });\n    return event.respondWith(response);\n});\n"],
  "mappings": "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",
  "names": ["createMemoryHistory", "options", "initialEntries", "initialIndex", "v5Compat", "entries", "map", "entry", "index", "createMemoryLocation", "state", "undefined", "clampIndex", "length", "action", "Action", "Pop", "listener", "n", "Math", "min", "max", "getCurrentLocation", "to", "key", "location", "createLocation", "pathname", "warning", "charAt", "JSON", "stringify", "createHref", "createPath", "history", "createURL", "URL", "encodeLocation", "path", "parsePath", "search", "hash", "push", "Push", "nextLocation", "splice", "delta", "replace", "Replace", "go", "nextIndex", "listen", "fn", "createBrowserHistory", "createBrowserLocation", "window", "globalHistory", "usr", "createBrowserHref", "getUrlBasedHistory", "createHashHistory", "createHashLocation", "substr", "startsWith", "createHashHref", "base", "document", "querySelector", "href", "getAttribute", "url", "hashIndex", "indexOf", "slice", "validateHashLocation", "invariant", "value", "message", "Error", "cond", "console", "warn", "e", "createKey", "random", "toString", "getHistoryState", "idx", "current", "_extends", "_ref", "parsedPath", "searchIndex", "getLocation", "validateLocation", "defaultView", "getIndex", "replaceState", "handlePop", "historyState", "pushState", "error", "DOMException", "name", "assign", "origin", "addEventListener", "PopStateEventType", "removeEventListener", "isIndexRoute", "route", "convertRoutesToDataRoutes", "routes", "mapRouteProperties", "parentPath", "manifest", "treePath", "id", "join", "children", "indexRoute", "pathOrLayoutRoute", "matchRoutes", "locationArg", "basename", "stripBasename", "branches", "flattenRoutes", "rankRouteBranches", "matches", "i", "matchRouteBranch", "safelyDecodeURI", "convertRouteMatchToUiMatch", "match", "loaderData", "params", "data", "handle", "parentsMeta", "flattenRoute", "relativePath", "meta", "caseSensitive", "childrenIndex", "joinPaths", "routesMeta", "concat", "score", "computeScore", "forEach", "_route$path", "includes", "exploded", "explodeOptionalSegments", "segments", "split", "first", "rest", "isOptional", "endsWith", "required", "restExploded", "result", "subpath", "sort", "a", "b", "compareIndexes", "initialScore", "some", "isSplat", "splatPenalty", "indexRouteValue", "filter", "s", "reduce", "segment", "paramRe", "test", "dynamicSegmentValue", "emptySegmentValue", "staticSegmentValue", "siblings", "every", "branch", "matchedParams", "matchedPathname", "end", "remainingPathname", "matchPath", "Object", "pathnameBase", "normalizePathname", "generatePath", "originalPath", "prefix", "p", "String", "array", "isLastSegment", "star", "keyMatch", "optional", "param", "pattern", "matcher", "paramNames", "compilePath", "captureGroups", "memo", "paramName", "splatValue", "safelyDecodeURIComponent", "regexpSource", "_", "RegExp", "decodeURI", "decodeURIComponent", "toLowerCase", "startIndex", "nextChar", "resolvePath", "fromPathname", "toPathname", "resolvePathname", "normalizeSearch", "normalizeHash", "relativeSegments", "pop", "getInvalidPathError", "char", "field", "dest", "getPathContributingMatches", "resolveTo", "toArg", "routePathnames", "locationPathname", "isPathRelative", "isEmptyPath", "from", "routePathnameIndex", "toSegments", "shift", "hasExplicitTrailingSlash", "hasCurrentTrailingSlash", "getToPathname", "isTrackedPromise", "Promise", "_tracked", "unwrapTrackedPromise", "_error", "_data", "isRouteErrorResponse", "status", "statusText", "internal", "createRouter", "init", "routerWindow", "isBrowser", "createElement", "isServer", "detectErrorBoundary", "hasErrorBoundary", "defaultMapRouteProperties", "dataRoutes", "inFlightDataRoutes", "future", "v7_normalizeFormMethod", "v7_prependBasename", "unlistenHistory", "subscribers", "Set", "savedScrollPositions", "getScrollRestorationKey", "getScrollPosition", "initialScrollRestored", "hydrationData", "initialMatches", "initialErrors", "getInternalRouterError", "getShortCircuitMatches", "initialized", "m", "lazy", "loader", "router", "historyAction", "navigation", "IDLE_NAVIGATION", "restoreScrollPosition", "preventScrollReset", "revalidation", "actionData", "errors", "fetchers", "Map", "blockers", "pendingAction", "HistoryAction", "pendingPreventScrollReset", "pendingNavigationController", "isUninterruptedRevalidation", "isRevalidationRequired", "cancelledDeferredRoutes", "cancelledFetcherLoads", "fetchControllers", "incrementingLoadId", "pendingNavigationLoadId", "fetchReloadIds", "fetchRedirectIds", "fetchLoadMatches", "activeDeferreds", "blockerFunctions", "ignoreNextHistoryUpdate", "initialize", "size", "blockerKey", "shouldBlockNavigation", "currentLocation", "updateBlocker", "proceed", "reset", "set", "IDLE_BLOCKER", "updateState", "startNavigation", "dispose", "clear", "abort", "deleteFetcher", "deleteBlocker", "subscribe", "add", "delete", "newState", "subscriber", "completeNavigation", "_location$state", "_location$state2", "isActionReload", "formMethod", "isMutationMethod", "_isRedirect", "keys", "mergeLoaderData", "k", "getSavedScrollPosition", "navigate", "opts", "normalizedPath", "normalizeTo", "fromRouteId", "relative", "submission", "normalizeNavigateOptions", "userReplace", "formAction", "pendingError", "revalidate", "interruptActiveLoads", "startUninterruptedRevalidation", "overrideNavigation", "saveScrollPosition", "routesToUse", "loadingNavigation", "notFoundMatches", "cancelActiveDeferreds", "isHashChangeOnly", "AbortController", "request", "createClientSideRequest", "signal", "pendingActionData", "findNearestBoundary", "actionOutput", "handleAction", "shortCircuited", "pendingActionError", "getLoadingNavigation", "Request", "handleLoaders", "fetcherSubmission", "getSubmittingNavigation", "actionMatch", "getTargetMatch", "type", "ResultType", "method", "routeId", "callLoaderOrAction", "aborted", "isRedirectResult", "startRedirectNavigation", "isErrorResult", "boundaryMatch", "isDeferredResult", "activeSubmission", "getSubmissionFromNavigation", "matchesToLoad", "revalidatingFetchers", "getMatchesToLoad", "updatedFetchers", "markFetchRedirectsDone", "rf", "fetcher", "get", "revalidatingFetcher", "getLoadingFetcher", "has", "abortFetcher", "controller", "abortPendingFetchRevalidations", "f", "results", "loaderResults", "fetcherResults", "callLoadersAndMaybeResolveData", "redirect", "findRedirect", "fetcherKey", "processLoaderData", "deferredData", "done", "didAbortFetchLoads", "abortStaleFetchLoads", "shouldUpdateFetchers", "getFetcher", "IDLE_FETCHER", "fetch", "setFetcherError", "handleFetcherAction", "handleFetcherLoader", "requestMatches", "existingFetcher", "getSubmittingFetcher", "abortController", "fetchRequest", "originatingLoadId", "actionResult", "doneFetcher", "getDoneFetcher", "loadingFetcher", "revalidationRequest", "loadId", "loadFetcher", "staleKey", "r", "resolveDeferredData", "_temp", "redirectLocation", "isDocumentReload", "reloadDocument", "ABSOLUTE_URL_REGEX", "redirectHistoryAction", "formEncType", "redirectPreserveMethodStatusCodes", "currentMatches", "fetchersToLoad", "all", "resolveDeferredResults", "markFetchersDone", "doneKeys", "landedId", "yeetedKeys", "getBlocker", "blocker", "newBlocker", "_ref2", "Array", "blockerFunction", "predicate", "cancelledRouteIds", "dfd", "cancel", "enableScrollRestoration", "positions", "getPosition", "getKey", "y", "getScrollKey", "_internalSetRoutes", "newRoutes", "_internalFetchControllers", "_internalActiveDeferreds", "createStaticHandler", "query", "_temp2", "requestContext", "isValidMethod", "methodNotAllowedMatches", "statusCode", "loaderHeaders", "actionHeaders", "queryImpl", "isResponse", "queryRoute", "_temp3", "find", "values", "_result$activeDeferre", "UNSAFE_DEFERRED_SYMBOL", "routeMatch", "submit", "loadRouteData", "isQueryRouteResponse", "response", "isRedirectResponse", "isRouteRequest", "isStaticRequest", "Response", "headers", "Location", "context", "loaderRequest", "getLoaderMatchesUntilBoundary", "acc", "processRouteLoaderData", "executedLoaders", "fromEntries", "getStaticContextFromError", "newContext", "_deepestRenderedBoundaryId", "isSubmissionNavigation", "formData", "body", "prependBasename", "contextualMatches", "activeRouteMatch", "hasNakedIndexQuery", "normalizeFormMethod", "isFetcher", "getInvalidBodyError", "rawFormMethod", "toUpperCase", "stripHashFromPath", "text", "FormData", "URLSearchParams", "_ref3", "json", "parse", "searchParams", "convertFormDataToSearchParams", "convertSearchParamsToFormData", "append", "boundaryId", "boundaryMatches", "findIndex", "currentUrl", "nextUrl", "navigationMatches", "isNewLoader", "currentRouteMatch", "nextRouteMatch", "shouldRevalidateLoader", "currentParams", "nextParams", "defaultShouldRevalidate", "isNewRouteInstance", "fetcherMatches", "fetcherMatch", "shouldRevalidate", "currentLoaderData", "currentMatch", "isNew", "isMissingData", "currentPath", "loaderMatch", "arg", "routeChoice", "loadLazyRouteModule", "lazyRoute", "routeToUpdate", "routeUpdates", "lazyRouteProperty", "staticRouteValue", "isPropertyStaticallyDefined", "immutableRouteKeys", "resultType", "onReject", "runHandler", "handler", "reject", "abortPromise", "race", "handlerError", "catch", "redirectStatusCodes", "protocol", "isSameBasename", "queryRouteResponse", "contentType", "ErrorResponseImpl", "isDeferredData", "_result$init", "_result$init2", "deferred", "Headers", "foundError", "newLoaderData", "mergedLoaderData", "hasOwnProperty", "eligibleMatches", "reverse", "_temp4", "errorMessage", "resolveData", "obj", "validRequestMethods", "validMutationMethods", "signals", "isRevalidatingLoader", "then", "unwrap", "unwrappedData", "getAll", "v", "pathMatches", "AbortedDeferredError", "DeferredData", "defer", "redirectDocument", "validMutationMethodsArr", "validRequestMethodsArr", "paths", "responseInit", "constructor", "pendingKeysSet", "deferredKeys", "isArray", "onAbort", "unlistenAbortSignal", "trackPromise", "promise", "onSettle", "defineProperty", "undefinedError", "emit", "settledKey", "resolve", "pendingKeys", "Boolean", "Symbol", "ServerMode", "json", "defer", "redirect", "redirectDocument", "isDeferredData", "isResponse", "redirectStatusCodes", "isRedirectStatusCode", "isRedirectResponse", "isTrackedPromise", "createDeferredReadableStream", "HANDLE", "MIGRATED", "CACHE_EMPTY", "Strategy", "keys", "b", "keys", "swr", "self", "dataCache", "documentCache", "location", "target", "entry", "entry", "entry", "b", "asap", "DexieError", "type", "handler", "resolve", "reject", "wrap", "props", "trans", "Promise", "keys", "i", "args", "Table", "count", "ctx", "Collection", "cmp", "direction", "addRange", "ranges", "WhereClause", "indexedDB", "p", "Transaction", "db", "tables", "keyPath", "compound", "result", "req", "openCursor", "query", "ev", "hasGetAll", "IDBKeyRange", "Version", "Dexie", "Debug.debug", "Debug.getErrorWithStack", "safari14Workaround", "primaryKey", "dxTrans", "clone", "target", "key", "state", "_Dexie", "Debug.setDebug", "type", "workerLoader", "message", "workerAction", "workerLoader", "flights", "f", "workerAction", "workerAction", "workerLoader", "workerAction", "workerAction", "workerLoader", "import_responses", "isMethod", "isLoaderRequest", "defaultHandler", "routes", "isLoaderRequest", "handler", "error"]
}
